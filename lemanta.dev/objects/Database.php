<?php
  // Impera CMS: модуль базы данных.
  // Copyright AIMatrix, 2011.
  // http://imperacms.ru

  // дополнение расширения файла безопасным (не приводящему к исполнению),
  // список допустимых расширений файлов для медиа файла
  define('ADMIN_FILES_CLASS_SAFE_EXTENSION', '');
  define('ADMIN_FILES_CLASS_EXTENSION_LIST', 'xls|doc|xlsx|docx|txt|wri|csv|rar|zip|7z|arj|lha|lz|lzh|ice|tar|tg|tgz|bz|bz2|bzip|bzip2|gz|gzip|exe|iso|msi|jar|jad|js|swf|flv|avi|mov|mkv|mpg|mpeg|mp4|wmv|3gp|vob|mp3|m3u|wav|wma|ogg|flac|mid|jpg|jpeg|png|gif|tga|tif|bmp|svg|wmf|ico|pdf|psd|ai|cdr|ttf|hlp|chm');

  define("TAKE_ONLY_FIRST_ITEMS_COMMAND_ALL_AVAILABLE", 0);
  define("TAKE_ONLY_FIRST_ITEMS_MODE_AS_LISTED", FALSE);
  define("TAKE_ONLY_FIRST_ITEMS_MODE_RANDOM", TRUE);

  define("PRODUCTS_ENABLED_MODE_ANY", FALSE);
  define("PRODUCTS_ENABLED_MODE_ONLY_ENABLED", TRUE);
  define("CATEGORIES_ENABLED_MODE_ANY", PRODUCTS_ENABLED_MODE_ANY);
  define("CATEGORIES_ENABLED_MODE_ONLY_ENABLED", PRODUCTS_ENABLED_MODE_ONLY_ENABLED);

  define("CATEGORIES_SORT_MODE_AS_IS", 0);
  define("CATEGORIES_SORT_MODE_BY_NAME", CATEGORIES_SORT_MODE_AS_IS + 1);

  define("SELECT_CATEGORIES_MODE_AS_IS", 0);
  define("SELECT_CATEGORIES_MODE_ONLY_PRICE1", SELECT_CATEGORIES_MODE_AS_IS + 1);
  define("SELECT_CATEGORIES_MODE_ONLY_PRICE2", SELECT_CATEGORIES_MODE_ONLY_PRICE1 + 1);
  define("SELECT_CATEGORIES_MODE_ONLY_PRICE3", SELECT_CATEGORIES_MODE_ONLY_PRICE2 + 1);
  define("SELECT_CATEGORIES_MODE_ONLY_PRICE4", SELECT_CATEGORIES_MODE_ONLY_PRICE3 + 1);
  define("SELECT_CATEGORIES_MODE_ONLY_PRICE5", SELECT_CATEGORIES_MODE_ONLY_PRICE4 + 1);
  define("SELECT_CATEGORIES_MODE_ONLY_PRICE6", SELECT_CATEGORIES_MODE_ONLY_PRICE5 + 1);
  define("SELECT_CATEGORIES_MODE_ONLY_PRICE7", SELECT_CATEGORIES_MODE_ONLY_PRICE6 + 1);
  define("SELECT_CATEGORIES_MODE_ONLY_PRICE8", SELECT_CATEGORIES_MODE_ONLY_PRICE7 + 1);

  define("DONT_MAKE_IMAGE_RECACHING", FALSE);
  define("MAKE_IMAGE_RECACHING_IF_ENABLED", TRUE);

  define("PRODUCTS_ARRAY_MODE_THIS_IS_ARRAY", FALSE);
  define("PRODUCTS_ARRAY_MODE_THIS_IS_ITEM", TRUE);

  define("PRODUCTS_COMPACT_ARRAY_FOR_CONFIGURATOR", 0);
  define("PRODUCTS_COMPACT_ARRAY_FOR_SITEMAP", PRODUCTS_COMPACT_ARRAY_FOR_CONFIGURATOR + 1);
  define("PRODUCTS_COMPACT_ARRAY_FOR_PRICE1", PRODUCTS_COMPACT_ARRAY_FOR_SITEMAP + 1);
  define("PRODUCTS_COMPACT_ARRAY_FOR_PRICE2", PRODUCTS_COMPACT_ARRAY_FOR_PRICE1 + 1);
  define("PRODUCTS_COMPACT_ARRAY_FOR_PRICE3", PRODUCTS_COMPACT_ARRAY_FOR_PRICE2 + 1);
  define("PRODUCTS_COMPACT_ARRAY_FOR_PRICE4", PRODUCTS_COMPACT_ARRAY_FOR_PRICE3 + 1);
  define("PRODUCTS_COMPACT_ARRAY_FOR_PRICE5", PRODUCTS_COMPACT_ARRAY_FOR_PRICE4 + 1);
  define("PRODUCTS_COMPACT_ARRAY_FOR_PRICE6", PRODUCTS_COMPACT_ARRAY_FOR_PRICE5 + 1);
  define("PRODUCTS_COMPACT_ARRAY_FOR_PRICE7", PRODUCTS_COMPACT_ARRAY_FOR_PRICE6 + 1);
  define("PRODUCTS_COMPACT_ARRAY_FOR_PRICE8", PRODUCTS_COMPACT_ARRAY_FOR_PRICE7 + 1);

  define("GET_PRODUCT_MODE_BY_PRODUCT_URL", FALSE);
  define("GET_PRODUCT_MODE_BY_PRODUCT_ID", TRUE);

  define("GET_GROUPS_MODE_FOR_ANY", "*");
  define("GET_GROUPS_MODE_FOR_AUTHORIZED", TRUE);
  define("GET_GROUPS_MODE_FOR_UNAUTHORIZED", FALSE);

  define("FIX_SIMPLE_TEXTAREA_TEXT_MODE_NO_ACTION", 0);
  define("FIX_SIMPLE_TEXTAREA_TEXT_MODE_ALL_TAGS_CLEAR", FIX_SIMPLE_TEXTAREA_TEXT_MODE_NO_ACTION + 1);

  define("PROCESS_IMAGE_FIELD_WIDTH", 0);
  define("PROCESS_IMAGE_FIELD_HEIGHT", PROCESS_IMAGE_FIELD_WIDTH + 1);
  define("PROCESS_IMAGE_FIELD_TYPE", PROCESS_IMAGE_FIELD_HEIGHT + 1);
  define("PROCESS_IMAGE_STRETCH_SMALL_MODE_OK", TRUE);
  define("PROCESS_IMAGE_STRETCH_SMALL_MODE_NO", FALSE);

  define("CHECK_SUBDOMAIN_USING_MODE_BY_BRANDID", 0);
  define("CHECK_SUBDOMAIN_USING_MODE_BY_CATEGORYID", CHECK_SUBDOMAIN_USING_MODE_BY_BRANDID + 1);
  define("CHECK_SUBDOMAIN_USING_MODE_BY_PRODUCTID", CHECK_SUBDOMAIN_USING_MODE_BY_CATEGORYID + 1);
  define("CHECK_SUBDOMAIN_USING_MODE_BY_USERID", CHECK_SUBDOMAIN_USING_MODE_BY_PRODUCTID + 1);





  // названия динамических параметров
  define("REQUEST_PARAM_NAME_THEME", "theme");
  define("REQUEST_PARAM_NAME_SECTION", "section");
  define("REQUEST_PARAM_NAME_MODULE", "module");
  define("REQUEST_PARAM_NAME_AFFILIATE", "aref");
  define("COOKIE_PARAM_NAME_AFFILIATE", "affiliate");
  define("REQUEST_PARAM_NAME_PAGE", "page");
  define('REQUEST_PARAM_NAME_ITEMID', 'item_id');
  define("REQUEST_PARAM_NAME_DELETEIDS", "delete_items");
  define("REQUEST_PARAM_NAME_USERID", "user_id");
  define("REQUEST_PARAM_NAME_FROM", "from");
  define("REQUEST_PARAM_NAME_IGNORE_POST", "ignore_post");
  define('REQUEST_PARAM_NAME_POST', 'post');
  define("REQUEST_PARAM_NAME_POST_THISONE", "post_this_one");
  define("REQUEST_PARAM_NAME_POST_MINI", "post_mini");
  define("REQUEST_PARAM_NAME_POST_AS_ACCEPT", "post_as_accept");
  define("REQUEST_PARAM_NAME_POST_AS_DISLOCATE", "post_as_dislocate");
  define("REQUEST_PARAM_NAME_POST_AS_DISLOCATE_FILTER", "post_as_dislocate_filter");
  define("REQUEST_PARAM_NAME_DISLOCATE_ID", "dislocate_id");
  define("REQUEST_PARAM_NAME_DISLOCATE_TO", "dislocate_to");
  define('REQUEST_PARAM_NAME_SETUP', 'setup');
  define('REQUEST_PARAM_NAME_START', 'start');
  define("REQUEST_PARAM_NAME_SORT", "sort");
  define("REQUEST_PARAM_NAME_SORT_DIRECTION", "sort_direction");
  define("REQUEST_PARAM_NAME_SORT_LACONICAL", "sort_laconical");
  define("REQUEST_PARAM_NAME_TYPE", "type");
  define("REQUEST_PARAM_NAME_NOTIFY_TYPE", REQUEST_PARAM_NAME_TYPE);
  define("REQUEST_PARAM_NAME_TOKEN", "token");
  define("REQUEST_PARAM_NAME_ACTION", "act");
  define("REQUEST_PARAM_NAME_USER_ACTION", "action");
  define("REQUEST_PARAM_NAME_KEYWORD", "keyword");
  define("REQUEST_PARAM_NAME_CATALOG_MODE", "mode");
  define("REQUEST_PARAM_NAME_SHOWALL_MODE", "show_all");
  define("REQUEST_PARAM_NAME_CATEGORY_ID", "category_id");
  define("REQUEST_PARAM_NAME_BRAND_ID", "brand_id");
  define("REQUEST_PARAM_NAME_PRODUCT_ID", "product_id");
  define("REQUEST_PARAM_NAME_DELETE_PRODUCT_ID", "delete_product_id");
  define("REQUEST_PARAM_NAME_VARIANT_ID", "variant_id");
  define("REQUEST_PARAM_NAME_OBJECT_ID", "object_id");
  define('REQUEST_PARAM_NAME_GROUP_ID', 'group_id');
  define('REQUEST_PARAM_NAME_PRICE_ID', 'price_id');
  define('REQUEST_PARAM_NAME_AFFILIATE_ID', 'affiliate_id');
  define("REQUEST_PARAM_NAME_CREDIT_ID", "credit_id");
  define("REQUEST_PARAM_NAME_CREDIT_FIELDS", "credit_fields");
  define("REQUEST_PARAM_NAME_CREDIT_PROGRAM", "credit_program");
  define("REQUEST_PARAM_NAME_IMPORT_INFO", "import_info");
  define("REQUEST_PARAM_NAME_SITEMAP_FORMAT", "format");
  define("REQUEST_PARAM_NAME_PRICELIST_FORMAT", "format");
  define("REQUEST_PARAM_NAME_CART_DEFER", "defer");
  define("REQUEST_PARAM_NAME_CART_QUICK", "quickcontent");
  define("REQUEST_PARAM_NAME_CART_RECHANGE", "rechange");
  define("REQUEST_PARAM_NAME_AMOUNT", "amount");
  define("REQUEST_PARAM_NAME_AMOUNTS", "amounts");
  define("REQUEST_PARAM_NAME_PROPERTIES", "properties");
  define("REQUEST_PARAM_NAME_SUBMIT_ORDER", "submit_order");
  define("REQUEST_PARAM_NAME_CONFIGURATOR_AS_QUICKORDER", "cataloged");
  define("REQUEST_PARAM_NAME_DAY", "day");
  define("REQUEST_PARAM_NAME_MONTH", "month");
  define("REQUEST_PARAM_NAME_YEAR", "year");
  define("REQUEST_PARAM_NAME_TITLE", "title");
  define("REQUEST_PARAM_NAME_NAME", "name");
  define("REQUEST_PARAM_NAME_DESCRIPTION", "description");
  define("REQUEST_PARAM_NAME_CONTENT", "content");
  define("REQUEST_PARAM_NAME_PRICE", "price");
  define("REQUEST_PARAM_NAME_LINK", "link");
  define("REQUEST_PARAM_NAME_ENABLED", "enabled");
  define("REQUEST_PARAM_NAME_FILTER_DAY", "filter_day");
  define("REQUEST_PARAM_NAME_FILTER_MONTH", "filter_month");
  define("REQUEST_PARAM_NAME_FILTER_YEAR", "filter_year");
  define("REQUEST_PARAM_NAME_FILTER_COUNTRY", "filter_country");
  define("REQUEST_PARAM_NAME_FILTER_REGION", "filter_region");
  define("REQUEST_PARAM_NAME_FILTER_TOWN", "filter_town");
  define("REQUEST_PARAM_NAME_FILTER_SCHOOL", "filter_school");
  define("REQUEST_PARAM_NAME_FILTER_CLASS", "filter_class");
  define("REQUEST_PARAM_NAME_FILTER_LESSON", "filter_lesson");
  define("REQUEST_PARAM_NAME_FILTER_CATEGORY", "filter_category");
  define("REQUEST_PARAM_NAME_FILTER_BRAND", "filter_brand");
  define("REQUEST_PARAM_NAME_FILTER_STOCK", "filter_stock");
  define("REQUEST_PARAM_NAME_FILTER_USER", "filter_user");
  define("REQUEST_PARAM_NAME_FILTER_PARTNER", "filter_partner");
  define("REQUEST_PARAM_NAME_FILTER_GROUP", "filter_group");
  define("REQUEST_PARAM_NAME_FILTER_PRICEGROUP", "filter_pricegroup");
  define("REQUEST_PARAM_NAME_FILTER_SECTION", "filter_section");
  define("REQUEST_PARAM_NAME_FILTER_HIT", "filter_hit");
  define("REQUEST_PARAM_NAME_FILTER_NEWEST", "filter_newest");
  define("REQUEST_PARAM_NAME_FILTER_ACTIONAL", "filter_actional");
  define("REQUEST_PARAM_NAME_FILTER_AWAITED", "filter_awaited");
  define("REQUEST_PARAM_NAME_FILTER_YMARKET", "filter_ymarket");
  define("REQUEST_PARAM_NAME_FILTER_VKONTAKTE", "filter_vkontakte");
  define("REQUEST_PARAM_NAME_FILTER_ENABLED", "filter_enabled");
  define('REQUEST_PARAM_NAME_FILTER_DELETED', 'filter_deleted');
  define("REQUEST_PARAM_NAME_FILTER_COMING", "filter_coming");
  define("REQUEST_PARAM_NAME_FILTER_PROCESSING", "filter_processing");
  define("REQUEST_PARAM_NAME_FILTER_DONE", "filter_done");
  define("REQUEST_PARAM_NAME_FILTER_CANCELED", "filter_canceled");
  define("REQUEST_PARAM_NAME_FILTER_INPRODUCT", "filter_inproduct");
  define("REQUEST_PARAM_NAME_FILTER_INFILTER", "filter_infilter");
  define("REQUEST_PARAM_NAME_FILTER_INCOMPARE", "filter_incompare");
  define("REQUEST_PARAM_NAME_FILTER_HIDDEN", "filter_hidden");
  define("REQUEST_PARAM_NAME_FILTER_VISIBLE", "filter_visible");
  define("REQUEST_PARAM_NAME_FILTER_ENABLEDEBIT", "filter_enable_debit");
  define("REQUEST_PARAM_NAME_FILTER_ENABLECREDIT", "filter_enable_credit");
  define("REQUEST_PARAM_NAME_FILTER_COMMENTED", "filter_commented");
  define("REQUEST_PARAM_NAME_FILTER_LISTED", "filter_listed");
  define("REQUEST_PARAM_NAME_FILTER_INFORMATIVE", "filter_informative");
  define("REQUEST_PARAM_NAME_FILTER_DOMAINED", "filter_domained");
  define("REQUEST_PARAM_NAME_FILTER_IMAGED", "filter_imaged");
  define("REQUEST_PARAM_NAME_FILTER_FILED", "filter_filed");
  define("REQUEST_PARAM_NAME_FILTER_ARTICLED", "filter_articled");
  define("REQUEST_PARAM_NAME_FILTER_NEWSED", "filter_newsed");
  define("REQUEST_PARAM_NAME_FILTER_MENU", "filter_menu");
  define("REQUEST_PARAM_NAME_FILTER_MODULE", "filter_module");
  define("REQUEST_PARAM_NAME_FILTER_OBJECTED", "filter_objected");
  define("REQUEST_PARAM_NAME_FILTER_SEOED", "filter_SEOed");
  define("REQUEST_PARAM_NAME_FILTER_URLSPECIAL", "filter_urlspecial");
  define("REQUEST_PARAM_NAME_FILTER_NOTRSS", "filter_notrss");
  define("REQUEST_PARAM_NAME_FILTER_NOTEXPORT", "filter_notexport");
  define("REQUEST_PARAM_NAME_FILTER_NONCREDITABLE", "filter_noncreditable");
  define('REQUEST_PARAM_NAME_FILTER_NONUSABLE', 'filter_nonusable');
  define("REQUEST_PARAM_NAME_FILTER_VALUABLE", "filter_valuable");
  define("REQUEST_PARAM_NAME_FILTER_PLUGIN", "filter_plugin");
  define("REQUEST_PARAM_NAME_FILTER_AUTOMATIC", "filter_automatic");
  define("REQUEST_PARAM_NAME_FILTER_INTERFACED", "filter_interfaced");
  define("REQUEST_PARAM_NAME_FILTER_NOACCESS", "filter_noaccess");
  define("REQUEST_PARAM_NAME_FILTER_NOREGISTER", "filter_noregister");
  define("REQUEST_PARAM_NAME_FILTER_NOCOMMENT", "filter_nocomment");
  define("REQUEST_PARAM_NAME_FILTER_NOCALLME", "filter_nocallme");
  define("REQUEST_PARAM_NAME_FILTER_NOADMIN", "filter_noadmin");
  define("REQUEST_PARAM_NAME_FILTER_ATTEMPTED", "filter_attempted");
  define("REQUEST_PARAM_NAME_FILTER_SEARCH", "filter_search");
  define("REQUEST_PARAM_NAME_FILTER_SEARCHCOSTFROM", "filter_cost_from");
  define("REQUEST_PARAM_NAME_FILTER_SEARCHCOSTTO", "filter_cost_to");
  define("REQUEST_PARAM_NAME_FILTER_SEARCHDATEFROM", "filter_date_from");
  define("REQUEST_PARAM_NAME_FILTER_SEARCHDATETO", "filter_date_to");
  define("REQUEST_PARAM_NAME_FILTER_DELIVERY", "filter_delivery");
  define("REQUEST_PARAM_NAME_FILTER_PAYMENT", "filter_payment");
  define("REQUEST_PARAM_NAME_FILTER_PAYSTATUS", "filter_paystatus");
  define("REQUEST_PARAM_NAME_FILTER_CREDITABLE", "filter_creditable");
  define("REQUEST_PARAM_NAME_FILTER_AFFILIATE", "filter_affiliate");
  define("REQUEST_PARAM_NAME_FILTER_MANUALLY", "filter_manually");
  define("REQUEST_PARAM_NAME_VIEW_MODE", "view_mode");
  define("REQUEST_PARAM_NAME_BAN_SELECTED", "ban_selected");
  define("ACTION_REQUEST_PARAM_NAME_IMAGENUMBER", "image_num");
  define("ACTION_REQUEST_PARAM_NAME_IMAGETOKEN", "image_token");
  define("ACTION_REQUEST_PARAM_NAME_IMAGEFILENAME", "image_filename");
  define("ACTION_REQUEST_PARAM_NAME_IMAGEALT", "image_alt");
  define("ACTION_REQUEST_PARAM_NAME_IMAGETEXT", "image_text");
  define("ACTION_REQUEST_PARAM_NAME_IMAGEVIEW", "image_view");
  define("ACTION_REQUEST_PARAM_NAME_FILENUMBER", "file_num");
  define("ACTION_REQUEST_PARAM_NAME_FILETOKEN", "file_token");
  define("ACTION_REQUEST_PARAM_NAME_FILEFILENAME", "file_filename");
  define("ACTION_REQUEST_PARAM_NAME_FILEALT", "file_alt");
  define("ACTION_REQUEST_PARAM_NAME_FILETEXT", "file_text");

  // названия значений динамических параметров
  define("ACTION_REQUEST_PARAM_VALUE_MOVEUP", "move_up");
  define("ACTION_REQUEST_PARAM_VALUE_MOVEDOWN", "move_down");
  define("ACTION_REQUEST_PARAM_VALUE_MOVEFIRST", "move_first");
  define("ACTION_REQUEST_PARAM_VALUE_MOVELAST", "move_last");
  define("ACTION_REQUEST_PARAM_VALUE_ENABLED", "enabled");
  define("ACTION_REQUEST_PARAM_VALUE_HIGHLIGHTED", "highlighted");
  define("ACTION_REQUEST_PARAM_VALUE_COMING", "coming");
  define("ACTION_REQUEST_PARAM_VALUE_PROCESSING", "processing");
  define("ACTION_REQUEST_PARAM_VALUE_DONE", "done");
  define("ACTION_REQUEST_PARAM_VALUE_CANCELED", "canceled");
  define("ACTION_REQUEST_PARAM_VALUE_PAYMENT", "payment");
  define("ACTION_REQUEST_PARAM_VALUE_INPRODUCT", "in_product");
  define("ACTION_REQUEST_PARAM_VALUE_INFILTER", "in_filter");
  define("ACTION_REQUEST_PARAM_VALUE_INCOMPARE", "in_compare");
  define("ACTION_REQUEST_PARAM_VALUE_LISTED", "listed");
  define("ACTION_REQUEST_PARAM_VALUE_COMMENTED", "commented");
  define("ACTION_REQUEST_PARAM_VALUE_DOMAINED", "domained");
  define("ACTION_REQUEST_PARAM_VALUE_INFORMATIVE", "informative");
  define("ACTION_REQUEST_PARAM_VALUE_HIDDEN", "hidden");
  define("ACTION_REQUEST_PARAM_VALUE_VISIBLE", "visible");
  define("ACTION_REQUEST_PARAM_VALUE_ENABLEDEBIT", "enable_debit");
  define("ACTION_REQUEST_PARAM_VALUE_ENABLECREDIT", "enable_credit");
  define("ACTION_REQUEST_PARAM_VALUE_NOACCESS", "no_access");
  define("ACTION_REQUEST_PARAM_VALUE_NOREGISTER", "no_register");
  define("ACTION_REQUEST_PARAM_VALUE_NOCOMMENT", "no_comment");
  define("ACTION_REQUEST_PARAM_VALUE_NOCALLME", "no_callme");
  define("ACTION_REQUEST_PARAM_VALUE_NOADMIN", "no_admin");
  define("ACTION_REQUEST_PARAM_VALUE_EDIT", "edit");
  define("ACTION_REQUEST_PARAM_VALUE_EDIT_NEW", "edit_new");
  define("ACTION_REQUEST_PARAM_VALUE_EDIT_ALL", "edit_all");
  define("ACTION_REQUEST_PARAM_VALUE_COPY", "copy");
  define("ACTION_REQUEST_PARAM_VALUE_CREATE", "create");
  define("ACTION_REQUEST_PARAM_VALUE_DOWNLOAD", "download");
  define("ACTION_REQUEST_PARAM_VALUE_UPLOAD", "upload");
  define("ACTION_REQUEST_PARAM_VALUE_RESTORE", "restore");
  define("ACTION_REQUEST_PARAM_VALUE_DELETE", "delete");
  define("ACTION_REQUEST_PARAM_VALUE_MASSDELETE", "mass_delete");
  define("ACTION_REQUEST_PARAM_VALUE_NEW", "new");
  define("ACTION_REQUEST_PARAM_VALUE_HIT", "hit");
  define("ACTION_REQUEST_PARAM_VALUE_NEWEST", "newest");
  define("ACTION_REQUEST_PARAM_VALUE_ACTIONAL", "actional");
  define("ACTION_REQUEST_PARAM_VALUE_AWAITED", "awaited");
  define("ACTION_REQUEST_PARAM_VALUE_YMARKET", "ymarket");
  define("ACTION_REQUEST_PARAM_VALUE_VKONTAKTE", "vkontakte");
  define("ACTION_REQUEST_PARAM_VALUE_MAIN", "main");
  define("ACTION_REQUEST_PARAM_VALUE_DEFAULT", "default");
  define("ACTION_REQUEST_PARAM_VALUE_DEFAULTA", "defaulta");
  define("ACTION_REQUEST_PARAM_VALUE_DELETEEMPTIES", "delete_empties");
  define("ACTION_REQUEST_PARAM_VALUE_DELETEIMAGE", "delete_image");
  define("ACTION_REQUEST_PARAM_VALUE_DELETEFILE", "delete_file");
  define("ACTION_REQUEST_PARAM_VALUE_VALUABLE", "valuable");
  define("ACTION_REQUEST_PARAM_VALUE_PLUGIN", "plugin");
  define("ACTION_REQUEST_PARAM_VALUE_IMPORT", "import");

    define('USERACTION_REQUEST_PARAM_VALUE_RELOGIN', 'relogin');
    define('USERACTION_REQUEST_PARAM_VALUE_LOGOUT', 'logout');



    define('SITEMAP_REQUEST_PARAM_VALUE_GOOGLE', 'google');
    define('PRICELIST_REQUEST_PARAM_VALUE_YANDEX', 'yandex');
    define('CATALOG_MODE_REQUEST_PARAM_VALUE_CATALOG', 'catalog');
    define('CATALOG_MODE_REQUEST_PARAM_VALUE_BEST', 'best');
    define('CATALOG_MODE_REQUEST_PARAM_VALUE_HIT', 'hit');
    define('CATALOG_MODE_REQUEST_PARAM_VALUE_NEWEST', 'newest');
    define('CATALOG_MODE_REQUEST_PARAM_VALUE_ACTIONAL', 'actional');
    define('CATALOG_MODE_REQUEST_PARAM_VALUE_AWAITED', 'awaited');
    define('CATALOG_MODE_REQUEST_PARAM_VALUE_NEW', 'new');
    define('CATALOG_MODE_REQUEST_PARAM_VALUE_ORDERED', 'ordered');
    define('CATALOG_MODE_REQUEST_PARAM_VALUE_COMMENTED', 'commented');
    define('CATALOG_MODE_REQUEST_PARAM_VALUE_DISCOUNTED', 'discounted');
    define('NOTIFY_TYPE_REQUEST_PARAM_VALUE_EXIST', 'exist');
    define('NOTIFY_TYPE_REQUEST_PARAM_VALUE_PRODUCT', 'product');
    define('NOTIFY_TYPE_REQUEST_PARAM_VALUE_NEWSITEM', 'newsitem');
    define('NOTIFY_TYPE_REQUEST_PARAM_VALUE_ARTICLE', 'article');
    define('NOTIFY_TYPE_REQUEST_PARAM_VALUE_USER', 'user');
    define('NOTIFY_TYPE_REQUEST_PARAM_VALUE_ALL', 'all');



    // значения динамического параметра REQUEST_PARAM_NAME_SORT_DIRECTION
    define('SORT_DIRECTION_ASCENDING', 0);
    define('SORT_DIRECTION_DESCENDING', SORT_DIRECTION_ASCENDING + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_VIEW_MODE
    define('VIEW_MODE_COMPACT', 0);
    define('VIEW_MODE_STANDARD', VIEW_MODE_COMPACT + 1);
    define('VIEW_MODE_FULL', VIEW_MODE_STANDARD + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к категориям
    define('SORT_CATEGORIES_MODE_AS_IS', 1);
    define('SORT_CATEGORIES_MODE_BY_NAME', SORT_CATEGORIES_MODE_AS_IS + 1);
    define('SORT_CATEGORIES_MODE_BY_BROWSED', SORT_CATEGORIES_MODE_BY_NAME + 1);
    define('SORT_CATEGORIES_MODE_BY_URL', SORT_CATEGORIES_MODE_BY_BROWSED + 1);
    define('SORT_CATEGORIES_MODE_BY_MENU', SORT_CATEGORIES_MODE_BY_URL + 1);
    define('SORT_CATEGORIES_MODE_BY_OBJECTS', SORT_CATEGORIES_MODE_BY_MENU + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к брендам
    define('SORT_BRANDS_MODE_AS_IS', 1);
    define('SORT_BRANDS_MODE_BY_NAME', SORT_BRANDS_MODE_AS_IS + 1);
    define('SORT_BRANDS_MODE_BY_BROWSED', SORT_BRANDS_MODE_BY_NAME + 1);
    define('SORT_BRANDS_MODE_BY_URL', SORT_BRANDS_MODE_BY_BROWSED + 1);
    define('SORT_BRANDS_MODE_BY_MENU', SORT_BRANDS_MODE_BY_URL + 1);
    define('SORT_BRANDS_MODE_BY_OBJECTS', SORT_BRANDS_MODE_BY_MENU + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к свойствам товаров
    define('SORT_PROPERTIES_MODE_AS_IS', 1);
    define('SORT_PROPERTIES_MODE_BY_NAME', SORT_PROPERTIES_MODE_AS_IS + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к складам
    define('SORT_STOCKS_MODE_AS_IS', 1);
    define('SORT_STOCKS_MODE_BY_NAME', SORT_STOCKS_MODE_AS_IS + 1);
    define('SORT_STOCKS_MODE_BY_CREATED', SORT_STOCKS_MODE_BY_NAME + 1);
    define('SORT_STOCKS_MODE_BY_MODIFIED', SORT_STOCKS_MODE_BY_CREATED + 1);
    define('SORT_STOCKS_MODE_BY_BROWSED', SORT_STOCKS_MODE_BY_MODIFIED + 1);
    define('SORT_STOCKS_MODE_BY_URL', SORT_STOCKS_MODE_BY_BROWSED + 1);
    define('SORT_STOCKS_MODE_BY_OBJECTS', SORT_STOCKS_MODE_BY_URL + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к товарам
    define('SORT_PRODUCTS_MODE_DEFAULT', -1);
    define('SORT_PRODUCTS_MODE_AS_IS', 0);
    define('SORT_PRODUCTS_MODE_BY_PRICE', SORT_PRODUCTS_MODE_AS_IS + 1);
    define('SORT_PRODUCTS_MODE_BY_QUANTITY', SORT_PRODUCTS_MODE_BY_PRICE + 1);
    define('SORT_PRODUCTS_MODE_BY_ORDERSCOUNT', SORT_PRODUCTS_MODE_BY_QUANTITY + 1);
    define('SORT_PRODUCTS_MODE_BY_ORDERSSUM', SORT_PRODUCTS_MODE_BY_ORDERSCOUNT + 1);
    define('SORT_PRODUCTS_MODE_BY_VARIANTSCOUNT', SORT_PRODUCTS_MODE_BY_ORDERSSUM + 1);
    define('SORT_PRODUCTS_MODE_BY_NAME', SORT_PRODUCTS_MODE_BY_VARIANTSCOUNT + 1);
    define('SORT_PRODUCTS_MODE_BY_CATEGORY', SORT_PRODUCTS_MODE_BY_NAME + 1);
    define('SORT_PRODUCTS_MODE_BY_BRAND', SORT_PRODUCTS_MODE_BY_CATEGORY + 1);
    define('SORT_PRODUCTS_MODE_BY_CREATED', SORT_PRODUCTS_MODE_BY_BRAND + 1);
    define('SORT_PRODUCTS_MODE_BY_MODIFIED', SORT_PRODUCTS_MODE_BY_CREATED + 1);
    define('SORT_PRODUCTS_MODE_BY_ORDERED', SORT_PRODUCTS_MODE_BY_MODIFIED + 1);
    define('SORT_PRODUCTS_MODE_BY_COMMENTED', SORT_PRODUCTS_MODE_BY_ORDERED + 1);
    define('SORT_PRODUCTS_MODE_BY_COMMENTS', SORT_PRODUCTS_MODE_BY_COMMENTED + 1);
    define('SORT_PRODUCTS_MODE_BY_BROWSED', SORT_PRODUCTS_MODE_BY_COMMENTS + 1);
    define('SORT_PRODUCTS_MODE_BY_VOTES', SORT_PRODUCTS_MODE_BY_BROWSED + 1);
    define('SORT_PRODUCTS_MODE_BY_RATING', SORT_PRODUCTS_MODE_BY_VOTES + 1);
    define('SORT_PRODUCTS_MODE_BY_URL', SORT_PRODUCTS_MODE_BY_RATING + 1);
    define('SORT_PRODUCTS_MODE_BY_MENU', SORT_PRODUCTS_MODE_BY_URL + 1);
    define('SORT_PRODUCTS_MODE_BY_OBJECTS', SORT_PRODUCTS_MODE_BY_MENU + 1);
    define('SORT_PRODUCTS_MODE_BY_PCODE', SORT_PRODUCTS_MODE_BY_OBJECTS + 1);
    define('SORT_PRODUCTS_MODE_BY_USER', SORT_PRODUCTS_MODE_BY_PCODE + 1);
    define('SORT_PRODUCTS_MODE_BY_OLDPRICE', SORT_PRODUCTS_MODE_BY_USER + 1);
    define('SORT_PRODUCTS_MODE_BY_TEMPPRICE', SORT_PRODUCTS_MODE_BY_OLDPRICE + 1);
    define('SORT_PRODUCTS_MODE_BY_PRIORITYDISCOUNT', SORT_PRODUCTS_MODE_BY_TEMPPRICE + 1);
    define('SORT_PRODUCTS_MODE_BY_PRICE_QUANTITY', SORT_PRODUCTS_MODE_BY_PRIORITYDISCOUNT + 1);
    define('SORT_PRODUCTS_MODE_BY_QUANTITY_PRICE', SORT_PRODUCTS_MODE_BY_PRICE_QUANTITY + 1);
    define('SORT_PRODUCTS_MODE_BY_ACTION_START_DATE', SORT_PRODUCTS_MODE_BY_QUANTITY_PRICE + 1);
    define('SORT_PRODUCTS_MODE_BY_ACTION_END_DATE', SORT_PRODUCTS_MODE_BY_ACTION_START_DATE + 1);

    // значения динамического параметра REQUEST_PARAM_NAME_TYPE применительно к товарам
    define('TYPE_PRODUCTS_ANY', 0);
    define('TYPE_PRODUCTS_HIT', TYPE_PRODUCTS_ANY + 1);
    define('TYPE_PRODUCTS_NEWEST', TYPE_PRODUCTS_HIT + 1);
    define('TYPE_PRODUCTS_ACTIONAL', TYPE_PRODUCTS_NEWEST + 1);
    define('TYPE_PRODUCTS_AWAITED', TYPE_PRODUCTS_ACTIONAL + 1);
    define('TYPE_PRODUCTS_ORDERED', TYPE_PRODUCTS_AWAITED + 1);
    define('TYPE_PRODUCTS_COMMENTED', TYPE_PRODUCTS_ORDERED + 1);
    define('TYPE_PRODUCTS_NONUSABLE', TYPE_PRODUCTS_COMMENTED + 1);
    define('TYPE_PRODUCTS_DOMAINED', TYPE_PRODUCTS_NONUSABLE + 1);
    define('TYPE_PRODUCTS_TEMPLATED', TYPE_PRODUCTS_DOMAINED + 1);
    define('TYPE_PRODUCTS_NEWEST_MIXED', TYPE_PRODUCTS_TEMPLATED + 1);
    define('TYPE_PRODUCTS_CANONIZED', TYPE_PRODUCTS_NEWEST_MIXED + 1);
    define('TYPE_PRODUCTS_DISCOUNTED', TYPE_PRODUCTS_CANONIZED + 1);

    // значения префиксных команд в строке поиска товаров
    define('SEARCH_PRODUCTS_COMMAND_MODIFIED_DATE', 'mdate:');
    define('SEARCH_PRODUCTS_COMMAND_CREATED_DATE', 'cdate:');
    define('SEARCH_PRODUCTS_COMMAND_TEMPLATE', 'tpl:');
    define('SEARCH_PRODUCTS_COMMAND_TAG', 'tag:');
    define('SEARCH_PRODUCTS_COMMAND_TAG_KEYWORDS', 'tag_kwd:');
    define('SEARCH_PRODUCTS_COMMAND_KEYWORDS', 'kwd:');
    define('SEARCH_PRODUCTS_COMMAND_PRODUCT_CODE', 'pcode:');
    define('SEARCH_PRODUCTS_COMMAND_PRODUCT_ID', 'pid:');
    define('SEARCH_PRODUCTS_COMMAND_BRAND', 'brand:');



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к комплектам товаров
    define('SORT_PRODUCTSKITS_MODE_AS_IS', 1);
    define('SORT_PRODUCTSKITS_MODE_BY_NAME', SORT_PRODUCTSKITS_MODE_AS_IS + 1);
    define('SORT_PRODUCTSKITS_MODE_BY_QUANTITY', SORT_PRODUCTSKITS_MODE_BY_NAME + 1);
    define('SORT_PRODUCTSKITS_MODE_BY_ROWCOUNT', SORT_PRODUCTSKITS_MODE_BY_QUANTITY + 1);
    define('SORT_PRODUCTSKITS_MODE_BY_CREATED', SORT_PRODUCTSKITS_MODE_BY_ROWCOUNT + 1);
    define('SORT_PRODUCTSKITS_MODE_BY_MODIFIED', SORT_PRODUCTSKITS_MODE_BY_CREATED + 1);
    define('SORT_PRODUCTSKITS_MODE_BY_BROWSED', SORT_PRODUCTSKITS_MODE_BY_MODIFIED + 1);
    define('SORT_PRODUCTSKITS_MODE_BY_URL', SORT_PRODUCTSKITS_MODE_BY_BROWSED + 1);

    // значения префиксных команд в строке поиска комплектов товаров
    define('SEARCH_PRODUCTSKITS_COMMAND_PRODUCT_ID', 'pid:');



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к заказам
    define('SORT_ORDERS_MODE_AS_IS', 1);
    define('SORT_ORDERS_MODE_BY_NAME', SORT_ORDERS_MODE_AS_IS + 1);
    define('SORT_ORDERS_MODE_BY_PHONE', SORT_ORDERS_MODE_BY_NAME + 1);
    define('SORT_ORDERS_MODE_BY_EMAIL', SORT_ORDERS_MODE_BY_PHONE + 1);
    define('SORT_ORDERS_MODE_BY_ICQ', SORT_ORDERS_MODE_BY_EMAIL + 1);
    define('SORT_ORDERS_MODE_BY_SKYPE', SORT_ORDERS_MODE_BY_ICQ + 1);
    define('SORT_ORDERS_MODE_BY_PAYMENT_DATE', SORT_ORDERS_MODE_BY_SKYPE + 1);
    define('SORT_ORDERS_MODE_BY_PAYMENT_NAME', SORT_ORDERS_MODE_BY_PAYMENT_DATE + 1);
    define('SORT_ORDERS_MODE_BY_DELIVERY_NAME', SORT_ORDERS_MODE_BY_PAYMENT_NAME + 1);
    define('SORT_ORDERS_MODE_BY_SUM', SORT_ORDERS_MODE_BY_DELIVERY_NAME + 1);
    define('SORT_ORDERS_MODE_BY_QUANTITY', SORT_ORDERS_MODE_BY_SUM + 1);
    define('SORT_ORDERS_MODE_BY_ROWCOUNT', SORT_ORDERS_MODE_BY_QUANTITY + 1);
    define('SORT_ORDERS_MODE_BY_IP', SORT_ORDERS_MODE_BY_ROWCOUNT + 1);
    define('SORT_ORDERS_MODE_BY_DATE', SORT_ORDERS_MODE_BY_IP + 1);

    // значения динамического параметра REQUEST_PARAM_NAME_TYPE применительно к заказам
    define('TYPE_ORDERS_ANY', 0);
    define('TYPE_ORDERS_COMING', TYPE_ORDERS_ANY + 1);
    define('TYPE_ORDERS_PROCESSING', TYPE_ORDERS_COMING + 1);
    define('TYPE_ORDERS_DONE', TYPE_ORDERS_PROCESSING + 1);
    define('TYPE_ORDERS_CANCELED', TYPE_ORDERS_DONE + 1);

    // значения префиксных команд в строке поиска заказов
    define('SEARCH_ORDERS_COMMAND_NAME', 'name:');
    define('SEARCH_ORDERS_COMMAND_ADDRESS', 'addr:');
    define('SEARCH_ORDERS_COMMAND_PHONE', 'phone:');
    define('SEARCH_ORDERS_COMMAND_EMAIL', 'email:');
    define('SEARCH_ORDERS_COMMAND_ICQ', 'icq:');
    define('SEARCH_ORDERS_COMMAND_SKYPE', 'skype:');
    define('SEARCH_ORDERS_COMMAND_IP', 'ip:');
    define('SEARCH_ORDERS_COMMAND_DATE', 'date:');
    define('SEARCH_ORDERS_COMMAND_PAYMENT_DATE', 'paydate:');
    define('SEARCH_ORDERS_COMMAND_TODATE', 'todate:');
    define('SEARCH_ORDERS_COMMAND_TOTIME', 'totime:');
    define('SEARCH_ORDERS_COMMAND_USER_ID', 'uid:');
    define('SEARCH_ORDERS_COMMAND_PRODUCT_ID', 'pid:');
    define('SEARCH_ORDERS_COMMAND_DELIVERY_ID', 'deliveryid:');
    define('SEARCH_ORDERS_COMMAND_PAYMENT_ID', 'payid:');



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к стадиям заказа
    define('SORT_ORDERSPHASES_MODE_AS_IS', 1);
    define('SORT_ORDERSPHASES_MODE_BY_CREATED', SORT_ORDERSPHASES_MODE_AS_IS);
    define('SORT_ORDERSPHASES_MODE_BY_NAME', SORT_ORDERSPHASES_MODE_BY_CREATED + 1);
    define('SORT_ORDERSPHASES_MODE_BY_MODIFIED', SORT_ORDERSPHASES_MODE_BY_NAME + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к кредитным программам
    define('SORT_CREDITPROGRAMS_MODE_AS_IS', 1);
    define('SORT_CREDITPROGRAMS_MODE_BY_CREATED', SORT_CREDITPROGRAMS_MODE_AS_IS + 1);
    define('SORT_CREDITPROGRAMS_MODE_BY_NAME', SORT_CREDITPROGRAMS_MODE_BY_CREATED + 1);
    define('SORT_CREDITPROGRAMS_MODE_BY_TERM', SORT_CREDITPROGRAMS_MODE_BY_NAME + 1);
    define('SORT_CREDITPROGRAMS_MODE_BY_PERCENT', SORT_CREDITPROGRAMS_MODE_BY_TERM + 1);
    define('SORT_CREDITPROGRAMS_MODE_BY_MODIFIED', SORT_CREDITPROGRAMS_MODE_BY_PERCENT + 1);

    // значения типов запрашиваемых полей для кредитной программы
    define('FIELDTYPE_CREDITPROGRAMS_STRING', 1);
    define('FIELDTYPE_CREDITPROGRAMS_TEXT', FIELDTYPE_CREDITPROGRAMS_STRING + 1);
    define('FIELDTYPE_CREDITPROGRAMS_DATE', FIELDTYPE_CREDITPROGRAMS_TEXT + 1);
    define('FIELDTYPE_CREDITPROGRAMS_NUMBER', FIELDTYPE_CREDITPROGRAMS_DATE + 1);
    define('FIELDTYPE_CREDITPROGRAMS_PHONE', FIELDTYPE_CREDITPROGRAMS_NUMBER + 1);
    define('FIELDTYPE_CREDITPROGRAMS_EMAIL', FIELDTYPE_CREDITPROGRAMS_PHONE + 1);
    define('FIELDTYPE_CREDITPROGRAMS_URL', FIELDTYPE_CREDITPROGRAMS_EMAIL + 1);
    define('FIELDTYPE_CREDITPROGRAMS_FILE', FIELDTYPE_CREDITPROGRAMS_URL + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к статьям
    define('SORT_ARTICLES_MODE_AS_IS', 1);
    define('SORT_ARTICLES_MODE_BY_HEADER', SORT_ARTICLES_MODE_AS_IS + 1);
    define('SORT_ARTICLES_MODE_BY_CREATED', SORT_ARTICLES_MODE_BY_HEADER + 1);
    define('SORT_ARTICLES_MODE_BY_MODIFIED', SORT_ARTICLES_MODE_BY_CREATED + 1);
    define('SORT_ARTICLES_MODE_BY_DATE', SORT_ARTICLES_MODE_BY_MODIFIED + 1);
    define('SORT_ARTICLES_MODE_BY_BROWSED', SORT_ARTICLES_MODE_BY_DATE + 1);
    define('SORT_ARTICLES_MODE_BY_URL', SORT_ARTICLES_MODE_BY_BROWSED + 1);
    define('SORT_ARTICLES_MODE_BY_MENU', SORT_ARTICLES_MODE_BY_URL + 1);
    define('SORT_ARTICLES_MODE_BY_OBJECTS', SORT_ARTICLES_MODE_BY_MENU + 1);
    define('SORT_ARTICLES_MODE_BY_VOTES', SORT_ARTICLES_MODE_BY_OBJECTS + 1);
    define('SORT_ARTICLES_MODE_BY_RATING', SORT_ARTICLES_MODE_BY_VOTES + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к новостям
    define('SORT_NEWS_MODE_AS_IS', 1);
    define('SORT_NEWS_MODE_BY_HEADER', SORT_NEWS_MODE_AS_IS + 1);
    define('SORT_NEWS_MODE_BY_CREATED', SORT_NEWS_MODE_BY_HEADER + 1);
    define('SORT_NEWS_MODE_BY_MODIFIED', SORT_NEWS_MODE_BY_CREATED + 1);
    define('SORT_NEWS_MODE_BY_DATE', SORT_NEWS_MODE_BY_MODIFIED + 1);
    define('SORT_NEWS_MODE_BY_BROWSED', SORT_NEWS_MODE_BY_DATE + 1);
    define('SORT_NEWS_MODE_BY_URL', SORT_NEWS_MODE_BY_BROWSED + 1);
    define('SORT_NEWS_MODE_BY_MENU', SORT_NEWS_MODE_BY_URL + 1);
    define('SORT_NEWS_MODE_BY_OBJECTS', SORT_NEWS_MODE_BY_MENU + 1);
    define('SORT_NEWS_MODE_BY_VOTES', SORT_NEWS_MODE_BY_OBJECTS + 1);
    define('SORT_NEWS_MODE_BY_RATING', SORT_NEWS_MODE_BY_VOTES + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к специальным страницам
    define('SORT_SECTIONS_MODE_AS_IS', 1);
    define('SORT_SECTIONS_MODE_BY_HEADER', SORT_SECTIONS_MODE_AS_IS + 1);
    define('SORT_SECTIONS_MODE_BY_CREATED', SORT_SECTIONS_MODE_BY_HEADER + 1);
    define('SORT_SECTIONS_MODE_BY_MODIFIED', SORT_SECTIONS_MODE_BY_CREATED + 1);
    define('SORT_SECTIONS_MODE_BY_DATE', SORT_SECTIONS_MODE_BY_MODIFIED + 1);
    define('SORT_SECTIONS_MODE_BY_BROWSED', SORT_SECTIONS_MODE_BY_DATE + 1);
    define('SORT_SECTIONS_MODE_BY_URL', SORT_SECTIONS_MODE_BY_BROWSED + 1);
    define('SORT_SECTIONS_MODE_BY_MENU', SORT_SECTIONS_MODE_BY_URL + 1);
    define('SORT_SECTIONS_MODE_BY_OBJECTS', SORT_SECTIONS_MODE_BY_MENU + 1);
    define('SORT_SECTIONS_MODE_BY_MODULE', SORT_SECTIONS_MODE_BY_OBJECTS + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к медиафайлам
    define('SORT_FILES_MODE_AS_IS', 1);
    define('SORT_FILES_MODE_BY_HEADER', SORT_FILES_MODE_AS_IS + 1);
    define('SORT_FILES_MODE_BY_CREATED', SORT_FILES_MODE_BY_HEADER + 1);
    define('SORT_FILES_MODE_BY_MODIFIED', SORT_FILES_MODE_BY_CREATED + 1);
    define('SORT_FILES_MODE_BY_BROWSED', SORT_FILES_MODE_BY_MODIFIED + 1);
    define('SORT_FILES_MODE_BY_URL', SORT_FILES_MODE_BY_BROWSED + 1);
    define('SORT_FILES_MODE_BY_MENU', SORT_FILES_MODE_BY_URL + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к меню
    define('SORT_MENUS_MODE_AS_IS', 1);
    define('SORT_MENUS_MODE_BY_NAME', SORT_MENUS_MODE_AS_IS + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к настройкам
    define('SORT_SETTINGS_MODE_AS_IS', 1);
    define('SORT_SETTINGS_MODE_BY_NAME', SORT_SETTINGS_MODE_AS_IS + 1);
    define('SORT_SETTINGS_MODE_BY_DESCRIPTION', SORT_SETTINGS_MODE_BY_NAME + 1);
    define('SORT_SETTINGS_MODE_BY_CATEGORY', SORT_SETTINGS_MODE_BY_DESCRIPTION + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к зарегистрированным модулям
    define('SORT_MODULES_MODE_AS_IS', 1);
    define('SORT_MODULES_MODE_BY_NAME', SORT_MODULES_MODE_AS_IS + 1);
    define('SORT_MODULES_MODE_BY_CLASS', SORT_MODULES_MODE_BY_NAME + 1);
    define('SORT_MODULES_MODE_BY_FILENAME', SORT_MODULES_MODE_BY_CLASS + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к вариантам импорта
    define('SORT_IMPORTS_MODE_AS_IS', 1);
    define('SORT_IMPORTS_MODE_BY_CREATED', SORT_IMPORTS_MODE_AS_IS);
    define('SORT_IMPORTS_MODE_BY_NAME', SORT_IMPORTS_MODE_AS_IS + 1);
    define('SORT_IMPORTS_MODE_BY_LASTUSED', SORT_IMPORTS_MODE_BY_NAME + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к пользователям
    define('SORT_USERS_MODE_AS_IS', 1);
    define('SORT_USERS_MODE_BY_CREATED', SORT_USERS_MODE_AS_IS);
    define('SORT_USERS_MODE_BY_NAME', SORT_USERS_MODE_BY_CREATED + 1);
    define('SORT_USERS_MODE_BY_EMAIL', SORT_USERS_MODE_BY_NAME + 1);
    define('SORT_USERS_MODE_BY_PHONE', SORT_USERS_MODE_BY_EMAIL + 1);
    define('SORT_USERS_MODE_BY_ICQ', SORT_USERS_MODE_BY_PHONE + 1);
    define('SORT_USERS_MODE_BY_SKYPE', SORT_USERS_MODE_BY_ICQ + 1);
    define('SORT_USERS_MODE_BY_GROUP', SORT_USERS_MODE_BY_SKYPE + 1);
    define('SORT_USERS_MODE_BY_CASH', SORT_USERS_MODE_BY_GROUP + 1);
    define('SORT_USERS_MODE_BY_ORDERS', SORT_USERS_MODE_BY_CASH + 1);
    define('SORT_USERS_MODE_BY_MODIFIED', SORT_USERS_MODE_BY_ORDERS + 1);
    define('SORT_USERS_MODE_BY_BIRTHDAY', SORT_USERS_MODE_BY_MODIFIED + 1);

    // значения префиксных команд в строке поиска пользователей
    define('SEARCH_USERS_COMMAND_NAME', 'name:');
    define('SEARCH_USERS_COMMAND_ADDRESS', 'addr:');
    define('SEARCH_USERS_COMMAND_PHONE', 'phone:');
    define('SEARCH_USERS_COMMAND_EMAIL', 'email:');
    define('SEARCH_USERS_COMMAND_ICQ', 'icq:');
    define('SEARCH_USERS_COMMAND_SKYPE', 'skype:');
    define('SEARCH_USERS_COMMAND_IP', 'ip:');
    define('SEARCH_USERS_COMMAND_CREATED', 'date:');
    define('SEARCH_USERS_COMMAND_MODIFIED', 'modified:');
    define('SEARCH_USERS_COMMAND_BIRTHDAY', 'birthday:');
    define('SEARCH_USERS_COMMAND_USER_ID', 'uid:');



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к складам
    define('SORT_BANNEDS_MODE_AS_IS', 1);
    define('SORT_BANNEDS_MODE_BY_IP', SORT_BANNEDS_MODE_AS_IS + 1);
    define('SORT_BANNEDS_MODE_BY_CREATED', SORT_BANNEDS_MODE_BY_IP + 1);
    define('SORT_BANNEDS_MODE_BY_MODIFIED', SORT_BANNEDS_MODE_BY_CREATED + 1);
    define('SORT_BANNEDS_MODE_BY_ATTEMPTS', SORT_BANNEDS_MODE_BY_MODIFIED + 1);
    define('SORT_BANNEDS_MODE_BY_ATTEMPTS_DATE', SORT_BANNEDS_MODE_BY_ATTEMPTS + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к запросам связи
    define('SORT_CALLME_MODE_AS_IS', 1);
    define('SORT_CALLME_MODE_BY_NAME', SORT_CALLME_MODE_AS_IS + 1);
    define('SORT_CALLME_MODE_BY_PHONE', SORT_CALLME_MODE_BY_NAME + 1);
    define('SORT_CALLME_MODE_BY_EMAIL', SORT_CALLME_MODE_BY_PHONE + 1);
    define('SORT_CALLME_MODE_BY_ICQ', SORT_CALLME_MODE_BY_EMAIL + 1);
    define('SORT_CALLME_MODE_BY_SKYPE', SORT_CALLME_MODE_BY_ICQ + 1);
    define('SORT_CALLME_MODE_BY_IP', SORT_CALLME_MODE_BY_SKYPE + 1);
    define('SORT_CALLME_MODE_BY_CREATED', SORT_CALLME_MODE_BY_IP + 1);

    // значения префиксных команд в строке поиска запросов связи
    define('SEARCH_CALLME_COMMAND_NAME', 'name:');
    define('SEARCH_CALLME_COMMAND_PHONE', 'phone:');
    define('SEARCH_CALLME_COMMAND_EMAIL', 'email:');
    define('SEARCH_CALLME_COMMAND_ICQ', 'icq:');
    define('SEARCH_CALLME_COMMAND_SKYPE', 'skype:');
    define('SEARCH_CALLME_COMMAND_IP', 'ip:');
    define('SEARCH_CALLME_COMMAND_DATE', 'date:');



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к уведомлениям
    define('SORT_NOTIFIES_MODE_AS_IS', 1);
    define('SORT_NOTIFIES_MODE_BY_TYPE', SORT_NOTIFIES_MODE_AS_IS + 1);
    define('SORT_NOTIFIES_MODE_BY_USER', SORT_NOTIFIES_MODE_BY_TYPE + 1);
    define('SORT_NOTIFIES_MODE_BY_PHONE', SORT_NOTIFIES_MODE_BY_USER + 1);
    define('SORT_NOTIFIES_MODE_BY_EMAIL', SORT_NOTIFIES_MODE_BY_PHONE + 1);
    define('SORT_NOTIFIES_MODE_BY_ICQ', SORT_NOTIFIES_MODE_BY_EMAIL + 1);
    define('SORT_NOTIFIES_MODE_BY_SKYPE', SORT_NOTIFIES_MODE_BY_ICQ + 1);
    define('SORT_NOTIFIES_MODE_BY_OBJECT', SORT_NOTIFIES_MODE_BY_SKYPE + 1);
    define('SORT_NOTIFIES_MODE_BY_IP', SORT_NOTIFIES_MODE_BY_OBJECT + 1);
    define('SORT_NOTIFIES_MODE_BY_CREATED', SORT_NOTIFIES_MODE_BY_IP + 1);
    define('SORT_NOTIFIES_MODE_BY_MODIFIED', SORT_NOTIFIES_MODE_BY_CREATED + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к странам
    define('SORT_COUNTRIES_MODE_AS_IS', 1);
    define('SORT_COUNTRIES_MODE_BY_NAME', SORT_COUNTRIES_MODE_AS_IS + 1);
    define('SORT_COUNTRIES_MODE_BY_URL', SORT_COUNTRIES_MODE_BY_NAME + 1);
    define('SORT_COUNTRIES_MODE_BY_BROWSED', SORT_COUNTRIES_MODE_BY_URL + 1);
    define('SORT_COUNTRIES_MODE_BY_REGIONSCOUNT', SORT_COUNTRIES_MODE_BY_BROWSED + 1);
    define('SORT_COUNTRIES_MODE_BY_TOWNSCOUNT', SORT_COUNTRIES_MODE_BY_REGIONSCOUNT + 1);
    define('SORT_COUNTRIES_MODE_BY_USERSCOUNT', SORT_COUNTRIES_MODE_BY_TOWNSCOUNT + 1);
    define('SORT_COUNTRIES_MODE_BY_ORDERSCOUNT', SORT_COUNTRIES_MODE_BY_USERSCOUNT + 1);
    define('SORT_COUNTRIES_MODE_BY_CREATED', SORT_COUNTRIES_MODE_BY_ORDERSCOUNT + 1);
    define('SORT_COUNTRIES_MODE_BY_MODIFIED', SORT_COUNTRIES_MODE_BY_CREATED + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к областям
    define('SORT_REGIONS_MODE_AS_IS', 1);
    define('SORT_REGIONS_MODE_BY_NAME', SORT_REGIONS_MODE_AS_IS + 1);
    define('SORT_REGIONS_MODE_BY_URL', SORT_REGIONS_MODE_BY_NAME + 1);
    define('SORT_REGIONS_MODE_BY_BROWSED', SORT_REGIONS_MODE_BY_URL + 1);
    define('SORT_REGIONS_MODE_BY_COUNTRIESCOUNT', SORT_REGIONS_MODE_BY_BROWSED + 1);
    define('SORT_REGIONS_MODE_BY_TOWNSCOUNT', SORT_REGIONS_MODE_BY_COUNTRIESCOUNT + 1);
    define('SORT_REGIONS_MODE_BY_USERSCOUNT', SORT_REGIONS_MODE_BY_TOWNSCOUNT + 1);
    define('SORT_REGIONS_MODE_BY_ORDERSCOUNT', SORT_REGIONS_MODE_BY_USERSCOUNT + 1);
    define('SORT_REGIONS_MODE_BY_CREATED', SORT_REGIONS_MODE_BY_ORDERSCOUNT + 1);
    define('SORT_REGIONS_MODE_BY_MODIFIED', SORT_REGIONS_MODE_BY_CREATED + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к городам
    define('SORT_TOWNS_MODE_AS_IS', 1);
    define('SORT_TOWNS_MODE_BY_NAME', SORT_TOWNS_MODE_AS_IS + 1);
    define('SORT_TOWNS_MODE_BY_URL', SORT_TOWNS_MODE_BY_NAME + 1);
    define('SORT_TOWNS_MODE_BY_BROWSED', SORT_TOWNS_MODE_BY_URL + 1);
    define('SORT_TOWNS_MODE_BY_COUNTRIESCOUNT', SORT_TOWNS_MODE_BY_BROWSED + 1);
    define('SORT_TOWNS_MODE_BY_REGIONSCOUNT', SORT_TOWNS_MODE_BY_COUNTRIESCOUNT + 1);
    define('SORT_TOWNS_MODE_BY_USERSCOUNT', SORT_TOWNS_MODE_BY_REGIONSCOUNT + 1);
    define('SORT_TOWNS_MODE_BY_ORDERSCOUNT', SORT_TOWNS_MODE_BY_USERSCOUNT + 1);
    define('SORT_TOWNS_MODE_BY_CREATED', SORT_TOWNS_MODE_BY_ORDERSCOUNT + 1);
    define('SORT_TOWNS_MODE_BY_MODIFIED', SORT_TOWNS_MODE_BY_CREATED + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к учебным заведениям
    define('SORT_SCHOOLS_MODE_AS_IS', 1);
    define('SORT_SCHOOLS_MODE_BY_NAME', SORT_SCHOOLS_MODE_AS_IS + 1);
    define('SORT_SCHOOLS_MODE_BY_URL', SORT_SCHOOLS_MODE_BY_NAME + 1);
    define('SORT_SCHOOLS_MODE_BY_BROWSED', SORT_SCHOOLS_MODE_BY_URL + 1);
    define('SORT_SCHOOLS_MODE_BY_USERSCOUNT', SORT_SCHOOLS_MODE_BY_BROWSED + 1);
    define('SORT_SCHOOLS_MODE_BY_CREATED', SORT_SCHOOLS_MODE_BY_USERSCOUNT + 1);
    define('SORT_SCHOOLS_MODE_BY_MODIFIED', SORT_SCHOOLS_MODE_BY_CREATED + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к типам учебных заведений
    define('SORT_SCHOOLSTYPES_MODE_AS_IS', 1);
    define('SORT_SCHOOLSTYPES_MODE_BY_CREATED', SORT_SCHOOLSTYPES_MODE_AS_IS);
    define('SORT_SCHOOLSTYPES_MODE_BY_NAME', SORT_SCHOOLSTYPES_MODE_BY_CREATED + 1);
    define('SORT_SCHOOLSTYPES_MODE_BY_MODIFIED', SORT_SCHOOLSTYPES_MODE_BY_NAME + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к предметам учебных заведений
    define('SORT_SCHOOLSLESSONS_MODE_AS_IS', 1);
    define('SORT_SCHOOLSLESSONS_MODE_BY_CREATED', SORT_SCHOOLSLESSONS_MODE_AS_IS);
    define('SORT_SCHOOLSLESSONS_MODE_BY_NAME', SORT_SCHOOLSLESSONS_MODE_BY_CREATED + 1);
    define('SORT_SCHOOLSLESSONS_MODE_BY_MODIFIED', SORT_SCHOOLSLESSONS_MODE_BY_NAME + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к классам учебных заведений
    define('SORT_SCHOOLSCLASSES_MODE_AS_IS', 1);
    define('SORT_SCHOOLSCLASSES_MODE_BY_CREATED', SORT_SCHOOLSCLASSES_MODE_AS_IS);
    define('SORT_SCHOOLSCLASSES_MODE_BY_NAME', SORT_SCHOOLSCLASSES_MODE_BY_CREATED + 1);
    define('SORT_SCHOOLSCLASSES_MODE_BY_MODIFIED', SORT_SCHOOLSCLASSES_MODE_BY_NAME + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к способам доставки
    define('SORT_DELIVERIES_MODE_AS_IS', 1);
    define('SORT_DELIVERIES_MODE_BY_NAME', SORT_DELIVERIES_MODE_AS_IS + 1);
    define('SORT_DELIVERIES_MODE_BY_PRICE', SORT_DELIVERIES_MODE_BY_NAME + 1);
    define('SORT_DELIVERIES_MODE_BY_FREEFROM', SORT_DELIVERIES_MODE_BY_PRICE + 1);
    define('SORT_DELIVERIES_MODE_BY_DISCOUNT', SORT_DELIVERIES_MODE_BY_FREEFROM + 1);
    define('SORT_DELIVERIES_MODE_BY_CREATED', SORT_DELIVERIES_MODE_BY_DISCOUNT + 1);
    define('SORT_DELIVERIES_MODE_BY_MODIFIED', SORT_DELIVERIES_MODE_BY_CREATED + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к типам доставки
    define('SORT_DELIVERIESTYPES_MODE_AS_IS', 1);
    define('SORT_DELIVERIESTYPES_MODE_BY_CREATED', SORT_DELIVERIESTYPES_MODE_AS_IS);
    define('SORT_DELIVERIESTYPES_MODE_BY_NAME', SORT_DELIVERIESTYPES_MODE_BY_CREATED + 1);
    define('SORT_DELIVERIESTYPES_MODE_BY_MODIFIED', SORT_DELIVERIESTYPES_MODE_BY_NAME + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к срокам отправки
    define('SORT_SHIPPINGSTERMS_MODE_AS_IS', 1);
    define('SORT_SHIPPINGSTERMS_MODE_BY_CREATED', SORT_SHIPPINGSTERMS_MODE_AS_IS);
    define('SORT_SHIPPINGSTERMS_MODE_BY_NAME', SORT_SHIPPINGSTERMS_MODE_BY_CREATED + 1);
    define('SORT_SHIPPINGSTERMS_MODE_BY_MODIFIED', SORT_SHIPPINGSTERMS_MODE_BY_NAME + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к способам оплаты
    define('SORT_PAYMENTS_MODE_AS_IS', 1);
    define('SORT_PAYMENTS_MODE_BY_NAME', SORT_PAYMENTS_MODE_AS_IS + 1);
    define('SORT_PAYMENTS_MODE_BY_CURRENCY', SORT_PAYMENTS_MODE_BY_NAME + 1);
    define('SORT_PAYMENTS_MODE_BY_CREATED', SORT_PAYMENTS_MODE_BY_CURRENCY + 1);
    define('SORT_PAYMENTS_MODE_BY_MODIFIED', SORT_PAYMENTS_MODE_BY_CREATED + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к валютам
    define('SORT_CURRENCIES_MODE_AS_IS', 1);
    define('SORT_CURRENCIES_MODE_BY_NAME', SORT_CURRENCIES_MODE_AS_IS + 1);
    define('SORT_CURRENCIES_MODE_BY_ISOCODE', SORT_CURRENCIES_MODE_BY_NAME + 1);
    define('SORT_CURRENCIES_MODE_BY_RATEFROM', SORT_CURRENCIES_MODE_BY_ISOCODE + 1);
    define('SORT_CURRENCIES_MODE_BY_RATETO', SORT_CURRENCIES_MODE_BY_RATEFROM + 1);
    define('SORT_CURRENCIES_MODE_BY_CREATED', SORT_CURRENCIES_MODE_BY_RATETO + 1);
    define('SORT_CURRENCIES_MODE_BY_MODIFIED', SORT_CURRENCIES_MODE_BY_CREATED + 1);



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к купонам
    define('SORT_COUPONS_MODE_AS_IS', 1);
    define('SORT_COUPONS_MODE_BY_NAME', SORT_COUPONS_MODE_AS_IS + 1);
    define('SORT_COUPONS_MODE_BY_CODE', SORT_COUPONS_MODE_BY_NAME + 1);
    define('SORT_COUPONS_MODE_BY_COUNT', SORT_COUPONS_MODE_BY_CODE + 1);
    define('SORT_COUPONS_MODE_BY_DISCOUNT', SORT_COUPONS_MODE_BY_COUNT + 1);
    define('SORT_COUPONS_MODE_BY_GROUP', SORT_COUPONS_MODE_BY_DISCOUNT + 1);
    define('SORT_COUPONS_MODE_BY_PRICE', SORT_COUPONS_MODE_BY_GROUP + 1);
    define('SORT_COUPONS_MODE_BY_AFFILIATE', SORT_COUPONS_MODE_BY_PRICE + 1);
    define('SORT_COUPONS_MODE_BY_USER', SORT_COUPONS_MODE_BY_AFFILIATE + 1);
    define('SORT_COUPONS_MODE_BY_ORDER', SORT_COUPONS_MODE_BY_USER + 1);
    define('SORT_COUPONS_MODE_BY_CREATED', SORT_COUPONS_MODE_BY_ORDER + 1);
    define('SORT_COUPONS_MODE_BY_MODIFIED', SORT_COUPONS_MODE_BY_CREATED + 1);
    define('SORT_COUPONS_MODE_BY_EXPIRED', SORT_COUPONS_MODE_BY_MODIFIED + 1);
    define('SORT_COUPONS_MODE_BY_PRINTER', SORT_COUPONS_MODE_BY_EXPIRED + 1);
    define('SORT_COUPONS_MODE_BY_EMAIL', SORT_COUPONS_MODE_BY_PRINTER + 1);
    define('SORT_COUPONS_MODE_BY_PHONE', SORT_COUPONS_MODE_BY_EMAIL + 1);

    // значения префиксных команд в строке поиска купонов
    define('SEARCH_COUPONS_COMMAND_DISCOUNT', 'sdisc:');
    define('SEARCH_COUPONS_COMMAND_GROUP_DISCOUNT', 'gdisc:');
    define('SEARCH_COUPONS_COMMAND_MODIFIED_DATE', 'mdate:');
    define('SEARCH_COUPONS_COMMAND_CREATED_DATE', 'cdate:');
    define('SEARCH_COUPONS_COMMAND_EXPIRED_DATE', 'edate:');
    define('SEARCH_COUPONS_COMMAND_DISCHARGED_DATE', 'ddate:');
    define('SEARCH_COUPONS_COMMAND_AFFILIATE', 'affil:');
    define('SEARCH_COUPONS_COMMAND_USER', 'buyer:');
    define('SEARCH_COUPONS_COMMAND_GROUP', 'group:');
    define('SEARCH_COUPONS_COMMAND_PRICE', 'price:');
    define('SEARCH_COUPONS_COMMAND_ORDER', 'order:');
    define('SEARCH_COUPONS_COMMAND_PRINTER', 'print:');
    define('SEARCH_COUPONS_COMMAND_EMAIL', 'email:');
    define('SEARCH_COUPONS_COMMAND_PHONE', 'phone:');



    // значения динамического параметра REQUEST_PARAM_NAME_SORT применительно к поисковым сопровождениям
    define('SORT_SEARCHES_MODE_AS_IS', 1);
    define('SORT_SEARCHES_MODE_BY_NAME', SORT_SEARCHES_MODE_AS_IS + 1);
    define('SORT_SEARCHES_MODE_BY_ESCORT_URL', SORT_SEARCHES_MODE_BY_NAME + 1);
    define('SORT_SEARCHES_MODE_BY_TARGET_URL', SORT_SEARCHES_MODE_BY_ESCORT_URL + 1);
    define('SORT_SEARCHES_MODE_BY_REFERER', SORT_SEARCHES_MODE_BY_TARGET_URL + 1);
    define('SORT_SEARCHES_MODE_BY_BROWSED', SORT_SEARCHES_MODE_BY_REFERER + 1);
    define('SORT_SEARCHES_MODE_BY_CREATED', SORT_SEARCHES_MODE_BY_BROWSED + 1);
    define('SORT_SEARCHES_MODE_BY_MODIFIED', SORT_SEARCHES_MODE_BY_CREATED + 1);

    // значения динамического параметра REQUEST_PARAM_NAME_TYPE применительно к поисковым сопровождениям
    define('TYPE_SEARCHES_ANY', 0);
    define('TYPE_SEARCHES_NEW', TYPE_SEARCHES_ANY + 1);
    define('TYPE_SEARCHES_ESCORTING', TYPE_SEARCHES_NEW + 1);

    // значения префиксных команд в строке поиска товаров
    define('SEARCH_SEARCHES_COMMAND_MODIFIED_DATE', 'mdate:');
    define('SEARCH_SEARCHES_COMMAND_CREATED_DATE', 'cdate:');
    define('SEARCH_SEARCHES_COMMAND_REFERER', 'ref:');
    define('SEARCH_SEARCHES_COMMAND_ESCORT_URL', 'eurl:');
    define('SEARCH_SEARCHES_COMMAND_TARGET_URL', 'turl:');
    define('SEARCH_SEARCHES_COMMAND_NAME', 'text:');
    define('SEARCH_SEARCHES_COMMAND_ID', 'id:');



  // значения режимов возврата результата методом get_categories() объекта класса DatabaseEX
  define("GET_CATEGORIES_MODE_WITH_MISSING_BRANCHES", TRUE);
  define("GET_CATEGORIES_MODE_STANDARD", FALSE);

  // значения режимов возврата результата методом get_brands() объекта класса DatabaseEX
  define("GET_BRANDS_MODE_WITH_MISSING_BRANCHES", TRUE);
  define("GET_BRANDS_MODE_STANDARD", FALSE);

  // значения полноты выбираемых записей методом get_products() объекта класса DatabaseEX
  define("GET_PRODUCTS_COMPLETENESS_FOR_CATALOG", 0);
  define("GET_PRODUCTS_COMPLETENESS_FOR_CATALOGMAP", GET_PRODUCTS_COMPLETENESS_FOR_CATALOG + 1);
  define("GET_PRODUCTS_COMPLETENESS_FOR_SITEMAP", GET_PRODUCTS_COMPLETENESS_FOR_CATALOGMAP + 1);
  define("GET_PRODUCTS_COMPLETENESS_FOR_CONFIGURATOR", GET_PRODUCTS_COMPLETENESS_FOR_SITEMAP + 1);
  define("GET_PRODUCTS_COMPLETENESS_FOR_PRICES", GET_PRODUCTS_COMPLETENESS_FOR_CONFIGURATOR + 1);
  define("GET_PRODUCTS_COMPLETENESS_FOR_EDITORDER", GET_PRODUCTS_COMPLETENESS_FOR_PRICES + 1);

  // значения режимов возврата результата методом db->settings->get()
  define("GET_SETTINGS_MODE_AS_SETTINGS", TRUE);
  define("GET_SETTINGS_MODE_AS_ITEMS", FALSE);

  // значения режимов возврата результата методом get_menus() объекта класса DatabaseEX
  define("GET_MENUS_MODE_INDEXED_BY_NAME", TRUE);
  define("GET_MENUS_MODE_INDEXED_BY_ID", FALSE);

  // маркер файла миниатюры
  define("THUMBNAIL_FILENAME_MARKER", "thumb.");

  // маркер выбора записей с недействительным идентификатором
  define("SELECT_RECORDS_PARAM_INVALID_ID", -2147483647);

  // интервал между перепроверками таблиц базы данных
  define("DATABASE_RECHECKING_LIFETIME", 24 * 60 * SECONDS_IN_MINUTE);



    // типичные размеры некоторых полей таблиц базы данных
    define('DATABASE_FIELDSIZE_ID', 20);
    define('DATABASE_FIELDSIZE_NAME', 256);
    define('DATABASE_FIELDSIZE_PASSWORD', 256);
    define('DATABASE_FIELDSIZE_QUANTITY', 11);
    define('DATABASE_FIELDSIZE_LIFETIME', 11);
    define('DATABASE_FIELDSIZE_PRICE', '17,6');
    define('DATABASE_FIELDSIZE_CASH', '12,4');
    define('DATABASE_FIELDSIZE_PERCENT', '5,2');



    // размеры некоторых полей таблицы пользователей
    define('DATABASE_USERS_FIELDSIZE_ID', DATABASE_FIELDSIZE_ID);
    define('DATABASE_USERS_FIELDSIZE_NAME', DATABASE_FIELDSIZE_NAME);
    define('DATABASE_USERS_FIELDSIZE_NICKNAME', 64);
    define('DATABASE_USERS_FIELDSIZE_EMAIL', 256);
    define('DATABASE_USERS_FIELDSIZE_PHONE', 256);
    define('DATABASE_USERS_FIELDSIZE_ICQ', 256);
    define('DATABASE_USERS_FIELDSIZE_SKYPE', 256);
    define('DATABASE_USERS_FIELDSIZE_ADDRESS', 512);
    define('DATABASE_USERS_PASSWORD_MAXSIZE', 50);
    define('DATABASE_USERS_FIELDSIZE_IP', 256);
    define('DATABASE_USERS_FIELDSIZE_TOKEN', 256);



    // размеры некоторых полей таблицы заказов
    define('DATABASE_ORDERS_FIELDSIZE_ID', DATABASE_FIELDSIZE_ID);
    define('DATABASE_ORDERS_FIELDSIZE_CODE', 256);
    define('DATABASE_ORDERS_FIELDSIZE_NAME', DATABASE_FIELDSIZE_NAME);
    define('DATABASE_ORDERS_FIELDSIZE_EMAIL', DATABASE_USERS_FIELDSIZE_EMAIL);
    define('DATABASE_ORDERS_FIELDSIZE_PHONE', DATABASE_USERS_FIELDSIZE_PHONE);
    define('DATABASE_ORDERS_FIELDSIZE_ICQ', DATABASE_USERS_FIELDSIZE_ICQ);
    define('DATABASE_ORDERS_FIELDSIZE_SKYPE', DATABASE_USERS_FIELDSIZE_SKYPE);
    define('DATABASE_ORDERS_FIELDSIZE_ADDRESS', DATABASE_USERS_FIELDSIZE_ADDRESS);
    define('DATABASE_ORDERS_FIELDSIZE_TODATE', 256);
    define('DATABASE_ORDERS_FIELDSIZE_TOTIME', 256);
    define('DATABASE_ORDERS_FIELDSIZE_COMMENT', 8192);
    define('DATABASE_ORDERS_FIELDSIZE_DELIVERYTRACKING', 256);
    define('DATABASE_ORDERS_FIELDSIZE_IP', DATABASE_USERS_FIELDSIZE_IP);



    // размеры некоторых полей таблицы отзывов на товары
    define('DATABASE_PRODUCTSCOMMENTS_FIELDSIZE_NAME', DATABASE_FIELDSIZE_NAME);
    define('DATABASE_PRODUCTSCOMMENTS_FIELDSIZE_EMAIL', DATABASE_USERS_FIELDSIZE_EMAIL);
    define('DATABASE_PRODUCTSCOMMENTS_FIELDSIZE_COMMENT', DATABASE_ORDERS_FIELDSIZE_COMMENT);



    // размеры некоторых полей таблицы способов оплаты
    define('DATABASE_PAYMENTS_FIELDSIZE_ID', DATABASE_FIELDSIZE_ID);
    define('DATABASE_PAYMENTS_FIELDSIZE_NAME', DATABASE_FIELDSIZE_NAME);



    // размеры некоторых полей таблицы статей
    define('DATABASE_ARTICLESCOMMENTS_FIELDSIZE_NAME', DATABASE_FIELDSIZE_NAME);
    define('DATABASE_ARTICLESCOMMENTS_FIELDSIZE_EMAIL', DATABASE_USERS_FIELDSIZE_EMAIL);
    define('DATABASE_ARTICLESCOMMENTS_FIELDSIZE_COMMENT', DATABASE_ORDERS_FIELDSIZE_COMMENT);



    // размеры некоторых полей таблицы новостей
    define('DATABASE_NEWSCOMMENTS_FIELDSIZE_NAME', DATABASE_FIELDSIZE_NAME);
    define('DATABASE_NEWSCOMMENTS_FIELDSIZE_EMAIL', DATABASE_USERS_FIELDSIZE_EMAIL);
    define('DATABASE_NEWSCOMMENTS_FIELDSIZE_COMMENT', DATABASE_ORDERS_FIELDSIZE_COMMENT);



    // размеры некоторых полей таблицы обратной связи
    define('DATABASE_FEEDBACK_FIELDSIZE_ID', DATABASE_FIELDSIZE_ID);
    define('DATABASE_FEEDBACK_FIELDSIZE_NAME', DATABASE_FIELDSIZE_NAME);
    define('DATABASE_FEEDBACK_FIELDSIZE_EMAIL', DATABASE_USERS_FIELDSIZE_EMAIL);
    define('DATABASE_FEEDBACK_FIELDSIZE_COMMENT', 65536);
    define('DATABASE_FEEDBACK_FIELDSIZE_IP', DATABASE_USERS_FIELDSIZE_IP);



    // размеры некоторых полей таблицы "Позвоните мне"
    define('DATABASE_CALLME_FIELDSIZE_NAME', DATABASE_FIELDSIZE_NAME);
    define('DATABASE_CALLME_FIELDSIZE_EMAIL', DATABASE_USERS_FIELDSIZE_EMAIL);
    define('DATABASE_CALLME_FIELDSIZE_PHONE', DATABASE_USERS_FIELDSIZE_PHONE);
    define('DATABASE_CALLME_FIELDSIZE_ICQ', DATABASE_USERS_FIELDSIZE_ICQ);
    define('DATABASE_CALLME_FIELDSIZE_SKYPE', DATABASE_USERS_FIELDSIZE_SKYPE);
    define('DATABASE_CALLME_FIELDSIZE_COMMENT', DATABASE_ORDERS_FIELDSIZE_COMMENT);



    // размеры некоторых полей таблицы "Уведомить меня"
    define('DATABASE_NOTIFIES_FIELDSIZE_USERID', DATABASE_FIELDSIZE_ID);
    define('DATABASE_NOTIFIES_FIELDSIZE_EMAIL', DATABASE_USERS_FIELDSIZE_EMAIL);
    define('DATABASE_NOTIFIES_FIELDSIZE_PHONE', DATABASE_USERS_FIELDSIZE_PHONE);
    define('DATABASE_NOTIFIES_FIELDSIZE_ICQ', DATABASE_USERS_FIELDSIZE_ICQ);
    define('DATABASE_NOTIFIES_FIELDSIZE_SKYPE', DATABASE_USERS_FIELDSIZE_SKYPE);
    define('DATABASE_NOTIFIES_FIELDSIZE_IP', DATABASE_USERS_FIELDSIZE_IP);
    define('DATABASE_NOTIFIES_FIELDSIZE_TOKEN', DATABASE_USERS_FIELDSIZE_TOKEN);



    // размеры некоторых полей таблицы учебных заведений
    define('DATABASE_SCHOOLS_FIELDSIZE_ADDRESS', DATABASE_USERS_FIELDSIZE_ADDRESS);



    // размеры некоторых полей таблицы менюшек
    define('DATABASE_MENUS_FIELDSIZE_ID', DATABASE_FIELDSIZE_ID);
    define('DATABASE_MENUS_FIELDSIZE_NAME', DATABASE_FIELDSIZE_NAME);



    // размеры некоторых полей таблицы состояний заказа
    define('DATABASE_ORDERS_PHASES_FIELDSIZE_ID', DATABASE_FIELDSIZE_ID);
    define('DATABASE_ORDERS_PHASES_FIELDSIZE_NAME', DATABASE_FIELDSIZE_NAME);



    // размеры некоторых полей таблицы валют
    define('DATABASE_CURRENCIES_FIELDSIZE_ID', DATABASE_FIELDSIZE_ID);
    define('DATABASE_CURRENCIES_FIELDSIZE_NAME', 32);
    define('DATABASE_CURRENCIES_FIELDSIZE_SIGN', 32);
    define('DATABASE_CURRENCIES_FIELDSIZE_ISOCODE', 3);



    // размеры некоторых полей таблицы кредитных программ
    define('DATABASE_CREDIT_PROGRAMS_FIELDSIZE_ID', DATABASE_FIELDSIZE_ID);
    define('DATABASE_CREDIT_PROGRAMS_FIELDSIZE_NAME', 64);



    // имена таблиц базы данных
    define('DATABASE_CATEGORIES_TABLENAME', 'categories');
    define('DATABASE_BRANDS_TABLENAME', 'brands');
    define('DATABASE_PRODUCTS_TABLENAME', 'products');
    define('DATABASE_PRODUCTS_CATEGORIES_TABLENAME', 'products_categories');
    define('DATABASE_PRODUCTS_VARIANTS_TABLENAME', 'products_variants');
    define('DATABASE_PRODUCTS_COMMENTS_TABLENAME', 'products_comments');
    define('DATABASE_PRODUCTS_RELATED_TABLENAME', 'related_products');
    define('DATABASE_PROPERTIES_TABLENAME', 'properties');
    define('DATABASE_USERS_TABLENAME', 'users');
    define('DATABASE_MENUS_TABLENAME', 'menu');
    define('DATABASE_NOTIFIES_TABLENAME', 'notifies');
    define('DATABASE_FEEDBACK_TABLENAME', 'feedback');
    define('DATABASE_IMPORTS_TABLENAME', 'imports');
    define('DATABASE_ORDERS_TABLENAME', 'orders');
    define('DATABASE_ORDERS_PHASES_TABLENAME', 'orders_phases');
    define('DATABASE_ORDERS_PRODUCTS_TABLENAME', 'orders_products');
    define('DATABASE_CREDIT_PROGRAMS_TABLENAME', 'credit_programs');
    define('DATABASE_PROPERTIES_VALUES_TABLENAME', 'properties_values');
    define('DATABASE_GROUPS_TABLENAME', 'groups');
    define('DATABASE_PAYMENT_METHODS_TABLENAME', 'payment_methods');
    define('DATABASE_COUPONS_TABLENAME', 'coupons');
    define('DATABASE_SEARCHES_TABLENAME', 'searches');



  // имена кеш-таблиц и времена жизни их контента (в секундах)
  define('DATABASE_CACHE_CBPRODUCTS_SHORTVERSION_TABLENAME', 'cache_cbproducts_sv'); define('DATABASE_CACHE_CBPRODUCTS_SHORTVERSION_LIFETIME', 60 * SECONDS_IN_MINUTE);
                                                                                     define('DATABASE_CACHE_PRODUCTS_LIFETIME', 60 * SECONDS_IN_MINUTE);
  define('DATABASE_CACHE_CATEGORIES_TABLENAME', 'cache_categories');                 define('DATABASE_CACHE_CATEGORIES_LIFETIME', 60 * SECONDS_IN_MINUTE);
  define('DATABASE_CACHE_BRANDS_TABLENAME', 'cache_brands');                         define('DATABASE_CACHE_BRANDS_LIFETIME', 60 * SECONDS_IN_MINUTE);
  define('DATABASE_CACHE_USERS_SHORTVERSION_TABLENAME', 'cache_users_sv');           define('DATABASE_CACHE_USERS_SHORTVERSION_LIFETIME', 60 * SECONDS_IN_MINUTE);
  define('DATABASE_CACHE_MENUS_SHORTVERSION_TABLENAME', 'cache_menus_sv');           define('DATABASE_CACHE_MENUS_SHORTVERSION_LIFETIME', 60 * SECONDS_IN_MINUTE);

  // =========================================================================
  // Класс DatabaseEX (модуль базы данных)
  // =========================================================================

  class DatabaseEX {

    // родительский объект
    public $parent;
    public $cms;

    // конфигурационная информация
    public $config;

    // настройки сайта
    public $root_dir;
    public $root_url;

    // валюты, валюта
    public $currencies;
    public $currency;

    // текст сообщения об ошибке
    public $error_msg;

    // указатель соединения с MySQL,
    // результат запроса
    private $link;
    public $res_id;

    // включена ли трассировка,
    // история запросов,
    // использованное запросами время (в микросекундах)
    public $tracing = FALSE;
    public $history = array();
    public $used_time = 0;

    // включена ли трассировка методов,
    // история методов,
    // стек истории методов
    public $tracing_methods = FALSE;
    public $history_methods = array();
    private $history_methods_stack = array();



        // конструктор класса ====================================================

        public function __construct ( & $cms, & $config, & $root_dir, & $root_url ) {

            // инициализируем свойства объекта
            $this->parent = & $cms;
            $this->cms = & $cms;
            $this->config = & $config;
            $this->root_dir = & $root_dir;
            $this->root_url = & $root_url;
            $this->link = 0;
            $this->res_id = FALSE;
            $this->error_msg = '';

            // отменяем трассировку методов и очищаем ее историю
            $this->tracing_methods = FALSE;
            $this->clear_tracing_methods();
        }



        // ===================================================================
        /**
        *  Догрузчик моделей базы данных
        *
        *  @access  public
        *  @param   string  $name   объектно-полевое имя модели
        *  @return  object          догруженный объект
        */
        // ===================================================================

        public function __get ( $name ) {

            // получаем из имя_модели класс ИмяМодели
            $class = preg_replace('/[^a-z0-9]+/i', ' ', $name);
            $class = ucwords(strtolower($class));
            $class = str_replace(' ', '', $class);
            if ($class != '') {

                // подгружаем файл модели
                $file = dirname(__FILE__) . '/.db-models/' . $class . '.php';
                if (is_file($file) && is_readable($file)) {
                    require_once($file);
                    $class .= 'DBModel';

                    // создаем и возвращаем объект модели
                    if (class_exists($class)) return new $class($this->cms);
                }
            }

            // иначе возвращаем НЕТ МОДЕЛИ
            return null;
        }



        // ===================================================================
        /**
        *  Подключение к базе данных MySQL
        *
        *  @access  public
        *  @return  mixed       объект подключения
        *                       FALSE если ошибка
        */
        // ===================================================================

        public function connect () {
            if (function_exists('mysqli_connect')) $this->link = mysqli_connect($this->config->dbhost, $this->config->dbuser, $this->config->dbpass);
            elseif (function_exists('mysql_connect')) $this->link = mysql_connect($this->config->dbhost, $this->config->dbuser, $this->config->dbpass);
            else return FALSE;

            if ($this->link === FALSE) {
                $this->error_msg = 'Could not connect to the database on ' . $this->config->dbhost;
                return FALSE;
            }

            if (function_exists('mysqli_select_db')) $result = mysqli_select_db($this->link, $this->config->dbname);
            elseif (function_exists('mysql_select_db')) $result = mysql_select_db($this->config->dbname, $this->link);
            else return FALSE;

            if (!$result) {
                $this->error_msg = 'Could not select the ' . $this->config->dbname . ' database';
                return FALSE;
            }
            return $this->link;
        }



        // ===================================================================
        /**
        *  Отключение от базы данных MySQL
        *
        *  @access  public
        *  @return  boolean     TRUE если отключено
        *                       FALSE если ошибка
        */
        // ===================================================================

        public function disconnect () {
            if (function_exists('mysqli_close')) $result = mysqli_close($this->link);
            elseif (function_exists('mysql_close')) $result = mysql_close($this->link);
            else return FALSE;

            if (!$result) {
                $this->error_msg = 'Could not close the ' . $this->config->dbname . ' database';
                return FALSE;
            }
            return TRUE;
        }



        // ===================================================================
        /**
        *  Получение безопасного значения для MySQL-запроса
        *
        *  @access  public
        *  @param   mixed   $value  значение
        *  @return  mixed           безопасное значение
        */
        // ===================================================================

        public function query_value ( $value ) {

            // если это число с плавающей точкой, преобразуем в строку
            if (is_float($value)) $value = str_replace(',', '.', strval($value));

            // экранируем спецсимволы
            if (function_exists('mysqli_real_escape_string')) return mysqli_real_escape_string($this->link, $value);
            elseif (function_exists('mysql_real_escape_string')) return mysql_real_escape_string($value, $this->link);
            else return $value;
        }



        // ===================================================================
        /**
        *  Выполнение MySQL-запроса
        *
        *  @access  public
        *  @param   string  $q      текст запроса
        *  @return  mixed           TRUE или результат запроса (для SELECT, SHOW, DESCRIBE, EXPLAIN)
        *                           FALSE если ошибка
        */
        // ===================================================================

        public function query ( $q ) {

            // если подключены к MySQL
            if ($this->link) {
                $time = function_exists('microtime') ? microtime(TRUE) : 0;

                // если включена трассировка методов
                if ($this->tracing_methods) {

                    // создаем объект сведений
                    $object = new stdClass;
                    $object->is_method = FALSE;
                    $object->name = $q;
                    $object->error = '';
                    $object->affected_rows = 0;
                    $object->timestamp = time();
                    $object->start_time = function_exists('microtime') ? microtime(TRUE) : $object->timestamp;
                    $object->end_time = $object->start_time;
                    $object->used_time = 0;
                    $object->total_used_time = 0;
                    $object->start_memory = function_exists('memory_get_usage') ? memory_get_usage(TRUE) : 0;
                    $object->end_memory = $object->start_memory;
                    $object->occupy_memory = 0;
                    $object->peak_memory = function_exists('memory_get_peak_usage') ? memory_get_peak_usage(TRUE) : 0;
                    $object->actions = array();

                    // если стек трассировки не пуст
                    $index = count($this->history_methods_stack) - 1;
                    if ($index >= 0) {

                        // добавляем в ветку "листок"
                        $previous = & $this->history_methods_stack[$index];
                        $index = count($previous->actions) - 1;
                        if ($index >= 0) {
                            $object->total_used_time = $previous->actions[$index]->total_used_time;
                        } else {
                            $object->total_used_time = $previous->total_used_time;
                        }
                        $previous->actions[] = & $object;

                        // иначе стек трассировки пуст
                    } else {

                        // создаем новый "листок" в истории
                        $index = count($this->history_methods) - 1;
                        if ($index >= 0) {
                            $object->total_used_time = $this->history_methods[$index]->total_used_time;
                        }
                        $this->history_methods[] = & $object;
                    }
                }

                // выполняем запрос
                if (function_exists('mysqli_query')) $this->res_id = mysqli_query($this->link, $q);
                elseif (function_exists('mysql_query')) $this->res_id = mysql_query($q, $this->link);
                else return FALSE;

                // если включена трассировка методов
                if ($this->tracing_methods) {

                    // запоминаем ошибку, если была
                    if (function_exists('mysqli_error')) $object->error = mysqli_error($this->link);
                    elseif (function_exists('mysql_error')) $object->error = mysql_error($this->link);

                    // запоминаем количество результата
                    if ($this->res_id !== FALSE) {
                        if (function_exists('mysqli_affected_rows')) $object->affected_rows = @ mysqli_affected_rows($this->link);
                        elseif (function_exists('mysql_affected_rows')) $object->affected_rows = @ mysql_affected_rows($this->link);
                    }

                    // вычисляем затраты времени и памяти
                    $object->end_time = function_exists('microtime') ? microtime(TRUE) : $object->timestamp;
                    $object->used_time = abs($object->end_time - $object->start_time);
                    $object->total_used_time += $object->used_time;
                    $object->end_memory = function_exists('memory_get_usage') ? memory_get_usage(TRUE) : 0;
                    $object->occupy_memory = $object->end_memory - $object->start_memory;
                    $object->peak_memory = function_exists('memory_get_peak_usage') ? memory_get_peak_usage(TRUE) : 0;
                }

                // если включена трассировка, сохраняем в истории
                if ($this->tracing) {
                    $time = (function_exists('microtime') ? microtime(TRUE) : 0) - $time;
                    $this->used_time += $time;
                    $this->history[md5($q) . '_' . (count($this->history) + 1)] = array($time, $this->used_time, $q);
                }

            // иначе не подключены к MySQL
            } else {
                $this->error_msg = 'Could not execute query to ' . $this->config->dbname . ' database, wrong database link.';
                return FALSE;
            }

            // если нет результата запроса
            if ($this->res_id === FALSE) {
                $this->error_msg = 'Could not execute query to ' . $this->config->dbname . ' database, wrong result id.';
                return FALSE;
            }
            return $this->res_id;
        }

    function results() {
      if ($this->res_id === FALSE) {
        $this->error_msg = "Could not execute query to " . $this->config->dbname . " database, wrong result id";
        return FALSE;
      }
      $result = array();
      while ($row = $this->fetch_object($this->res_id)) array_push($result, $row);
      return $result;
    }

    function result() {
      if ($this->res_id === FALSE) {
        $this->error_msg = "Could not execute query to " . $this->config->dbname . " database, wrong result id";
        return FALSE;
      }
      $row = $this->fetch_object($this->res_id);
      return $row;
    }

    function result_for_items_count() {
      $result = 0;
      if ($this->res_id !== FALSE) {
        $row = $this->fetch_object($this->res_id);
        if (isset($row->itemscount) == TRUE) $result = $row->itemscount;
      }
      return $result;
    }



        // возврат идентификатора добавленной записи =============================

        public function insert_id () {
            if (function_exists('mysqli_insert_id')) return mysqli_insert_id($this->link);
            elseif (function_exists('mysql_insert_id')) return mysql_insert_id($this->link);
            else return 0;
        }



        // возврат числа прочитанных запросом записей ============================

        public function num_rows ( & $resource ) {

            // если нет результатов запроса
            if ($resource === FALSE) return 0;

            // возвращаем число записей
            if (function_exists('mysqli_num_rows')) return mysqli_num_rows($resource);
            elseif (function_exists('mysql_num_rows')) return mysql_num_rows($resource);
            else return 0;
        }



        // возврат числа прочитанных запросом полей ==============================

        public function num_fields ( & $resource ) {

            // если нет результатов запроса
            if ($resource === FALSE) return 0;

            // возвращаем число полей
            if (function_exists('mysqli_num_fields')) return mysqli_num_fields($resource);
            elseif (function_exists('mysql_num_fields')) return mysql_num_fields($resource);
            else return 0;
        }



        // возврат числа затронутых запросом записей =============================

        public function affected_rows () {
            if (function_exists('mysqli_affected_rows')) return mysqli_affected_rows($this->link);
            elseif (function_exists('mysql_affected_rows')) return mysql_affected_rows($this->link);
            else return 0;
        }



        // излечение массива данных из результата запроса ========================

        public function fetch_row ( & $resource ) {

            // если нет результатов запроса
            if ($resource === FALSE) return FALSE;

            // возвращаем массив данных
            if (function_exists('mysqli_fetch_row')) return mysqli_fetch_row($resource);
            elseif (function_exists('mysql_fetch_row')) return mysql_fetch_row($resource);
            else return FALSE;
        }



        // излечение ассоциативного массива данных из результата запроса =========

        public function fetch_assoc ( & $resource ) {

            // если нет результатов запроса
            if ($resource === FALSE) return FALSE;

            // возвращаем ассоциативный массив данных
            if (function_exists('mysqli_fetch_assoc')) return mysqli_fetch_assoc($resource);
            elseif (function_exists('mysql_fetch_assoc')) return mysql_fetch_assoc($resource);
            else return FALSE;
        }



        // извлечение объекта данных из результата запроса =======================

        public function fetch_object ( & $resource ) {

            // если нет результатов запроса
            if ($resource === FALSE) return FALSE;

            // возвращаем объект данных
            if (function_exists('mysqli_fetch_object')) return mysqli_fetch_object($resource);
            elseif (function_exists('mysql_fetch_object')) return mysql_fetch_object($resource);
            else return FALSE;
        }



        // извлечение данных о поле записи =======================================

        public function fetch_field ( & $resource, $index ) {

            // если нет результатов запроса
            if ($resource === FALSE) return FALSE;

            // возвращаем данные о поле
            if (function_exists('mysqli_fetch_field')) return mysqli_fetch_field($resource);
            elseif (function_exists('mysql_fetch_field')) return mysql_fetch_field($resource, $index);
            else return FALSE;
        }



        // освобождение памяти от результатов запроса ============================

        public function free_result ( & $resource ) {

            // если нет результатов запроса
            if ($resource === FALSE) return TRUE;

            // освобождаем память
            if (function_exists('mysqli_free_result')) {
                mysqli_free_result($resource);
                return TRUE;
            } elseif (function_exists('mysql_free_result')) return mysql_free_result($resource);
            else return FALSE;
        }



        // возврат описания ошибки выполнения запроса ============================

        public function error () {
            if (function_exists('mysqli_error')) return mysqli_error($this->link);
            elseif (function_exists('mysql_error')) return mysql_error($this->link);
            else return '';
        }



    // очистка истории трассировки методов ===================================

    public function clear_tracing_methods () {

        // очищаем историю трассировки методов
        $this->history_methods = array();
        $this->history_methods_stack = array();
    }



    // открытие трассировки метода ===========================================

    public function open_tracing_method ( $method ) {

        // если включена трассировка методов
        if ($this->tracing_methods) {

            // создаем объект сведений
            $object = new stdClass;
            $object->is_method = TRUE;
            $object->name = trim($method);
            $object->error = '';
            $object->timestamp = time();
            $object->start_time = function_exists('microtime') ? microtime(TRUE) : $object->timestamp;
            $object->end_time = $object->start_time;
            $object->used_time = 0;
            $object->total_used_time = 0;
            $object->start_memory = function_exists('memory_get_usage') ? memory_get_usage(TRUE) : 0;
            $object->end_memory = $object->start_memory;
            $object->occupy_memory = 0;
            $object->peak_memory = function_exists('memory_get_peak_usage') ? memory_get_peak_usage(TRUE) : 0;
            $object->actions = array();

            // если стек трассировки не пуст (этот метод был вызван из другого трассируемого)
            $index = count($this->history_methods_stack) - 1;
            if ($index >= 0) {

                // добавляем в ветку узел
                $previous = & $this->history_methods_stack[$index];
                $index = count($previous->actions) - 1;
                if ($index >= 0) {
                    $object->total_used_time = $previous->actions[$index]->total_used_time;
                } else {
                    $object->total_used_time = $previous->total_used_time;
                }
                $previous->actions[] = & $object;
                $this->history_methods_stack[] = & $object;

            // иначе стек трассировки пуст
            } else {

                // создаем новую ветку в истории
                $index = count($this->history_methods) - 1;
                if ($index >= 0) {
                    $object->total_used_time = $this->history_methods[$index]->total_used_time;
                }
                $this->history_methods[] = & $object;
                $this->history_methods_stack[] = & $object;
            }
        }
    }



    // закрытие трассировки метода ===========================================

    public function close_tracing_method () {

        // если включена трассировка методов
        if ($this->tracing_methods) {

            // если стек трассировки не пуст
            $index = count($this->history_methods_stack) - 1;
            if ($index >= 0) {

                // вычисляем затраты времени и памяти в закрываемой трассировке метода
                $object = & $this->history_methods_stack[$index];
                if (!is_object($object)) $object = new stdClass;
                $object->end_time = function_exists('microtime') ? microtime(TRUE) : $object->timestamp;
                $object->used_time = abs($object->end_time - (isset($object->start_time) ? $object->start_time : 0));
                $object->total_used_time += $object->used_time;
                $object->end_memory = function_exists('memory_get_usage') ? memory_get_usage(TRUE) : 0;
                $object->occupy_memory = $object->end_memory - (isset($object->start_memory) ? $object->start_memory : 0);
                $object->peak_memory = function_exists('memory_get_peak_usage') ? memory_get_peak_usage(TRUE) : 0;

                // выталкиваем из стека более ненужный последний элемент
                array_pop($this->history_methods_stack);
            }
        }
    }



    // отображение панели трассировки методов ================================

    public function tracing_methods_panel () {

        // если включена трассировка методов
        if ($this->tracing_methods) {

            // если есть результаты трассировки
            if (is_array($this->history_methods) && !empty($this->history_methods)) {
                $div_style = 'background: #ccc;'
                           . 'border: 0 solid;'
                           . 'outline: 0 solid;'
                           . 'color: #000;'
                           . 'clear: both;'
                           . 'display: block;'
                           . 'float: none;'
                           . 'position: absolute;'
                           . 'margin: 0;'
                           . 'padding: 0;'
                           . 'opacity: 0.3;'
                           . 'overflow: hidden;'
                           . 'font-family: Verdana, Tahoma, Arial;'
                           . 'font-size: 8pt;'
                           . 'font-style: normal;'
                           . 'font-weight: normal;'
                           . 'line-height: 24px;'
                           . 'height: 24px;'
                           . 'left: 0;'
                           . 'top: 0;'
                           . 'width: 200px;'
                           . 'white-space: pre;'
                           . 'text-align: left;'
                           . 'text-decoration: none;'
                           . 'z-index: 1000000;';
                echo '<div style="' . $div_style . '" onmouseover="this.style.opacity = 1.0; this.style.height = \'auto\'; this.style.width = \'100%\';" '
                                                   . 'onclick="this.style.opacity = .3; this.style.height = \'24px\'; this.style.width = \'200px\'; event.cancelBubble = true; return false;">'
                       . '<b style="margin-left: 15px;">Результаты трассировки</b><br>';
                $this->tracing_methods_panel_list($this->history_methods);
                echo '</div>';
            }
        }
    }



    // отображение структуры панели трассировки методов ======================

    private function tracing_methods_panel_list ( & $items = array(), $prev_start = null, $prev_end = null ) {

        // если включена трассировка методов
        if ($this->tracing_methods) {

            // если есть результаты трассировки
            if (is_array($items) && !empty($items)) {
                echo '<ul style="border-left: #999 1px dotted; border-bottom: #999 1px dotted; list-style: none; margin: 0 0 0 30px; padding: 0 0 0 5px;">';
                $prev = $prev_start;
                $number = 1;
                $count = count($items);
                foreach ($items as & $item) {

                    // если замечены пред сегментные потери времени
                    if (!is_null($prev)) {
                        if ($number == 1) {
                            $me = sprintf('%1.7f', $item->start_time);
                            $he = sprintf('%1.7f', $prev_start);
                            $inter = sprintf('%1.7f', $me - $he);
                            if ($inter > 0) {
                                echo '<li>'
                                       . '<span style="background: #bbb; color: #999;">'
                                           . '&nbsp; пред сегментное время ' . ($inter >= 0.025 ? '<span style="color: #80f;">' . $inter . '</span>'
                                                                                                : $inter) . ' &nbsp;'
                                       . '</span>'
                                   . '</li>';
                            }

                        // если замечены межсегментные потери времени
                        } else {
                            $me = sprintf('%1.7f', $item->start_time);
                            $he = sprintf('%1.7f', $prev);
                            $inter = sprintf('%1.7f', $me - $he);
                            if ($inter > 0) {
                                echo '<li>'
                                       . '<span style="background: #bbb; color: #999;">'
                                           . '&nbsp; межсегментное время ' . ($inter >= 0.025 ? '<span style="color: #80f;">' . $inter . '</span>'
                                                                                              : $inter) . ' &nbsp;'
                                       . '</span>'
                                   . '</li>';
                            }
                        }
                    }

                    // запоминаем временную точку межсегмента
                    $prev = $item->end_time;

                    $used = sprintf('%1.7f', $item->used_time);

                    $error = trim($item->error);
                    if ($error != '') $error = '<div style="background: #c22; color: #fff; border-radius: 2px; margin: 3px 2px; padding: 2px 3px;">' . $error . '</div>';

                    // если это был метод
                    if ($item->is_method) {
                        $name = explode(' ', trim($item->name), 2);
                        $name[1] = isset($name[1]) ? trim($name[1]) : '';
                        $over_memory = $item->end_memory - $item->start_memory;
                        echo '<li>'
                               . '<span style="color: #999;">'
                                   . date('H:i.s', $item->timestamp) . ' &nbsp; '
                                   . 'время'
                               . '</span> '
                               . ($used >= 0.025 ? '<span style="color: #80f;">' . $used . '</span> &nbsp; '
                                                 : '<span style="color: #080;">' . $used . '</span> &nbsp; ')
                               . '<span style="color: #999;">ram</span> '
                               . '<span style="color: #c60;">' . number_format($item->peak_memory / 1204, 0, '.', ' ') . ' кб</span> &nbsp; '
                               . ($over_memory != 0 ? '<span style="color: #80f;" title="потребил еще ' . number_format($over_memory, 0, '.', ' ') . ' байт">' . number_format($item->end_memory / 1204, 0, '.', ' ') . ' кб</span> &nbsp; '
                                                    : '<span style="color: #08f;">' . number_format($item->end_memory / 1204, 0, '.', ' ') . ' кб</span> &nbsp; ')
                               . '<span style="color: #999;">' . number_format($item->start_memory / 1204, 0, '.', ' ') . ' кб</span> &nbsp; '
                               . 'метод &nbsp; <span style="color: #999;">' . $name[0] . '</span>'
                               . ($name[1] != '' ? ' <span style="color: #a00;">' . $name[1] . '</span>'
                                                 : '')
                               . $error;
                        if (isset($item->actions)) $this->tracing_methods_panel_list($item->actions,
                                                                                     $item->start_time,
                                                                                     $item->end_time);
                        echo '</li>';

                    // иначе это был запрос
                    } else {
                        $affected_rows = !empty($item->affected_rows) ? '<div style="background: #999; color: #fff; border-radius: 2px; font-size: 8pt; margin: 3px 2px; padding: 0 3px;">обработано рядов: ' . $item->affected_rows . '</div>' : '';

                        $name = str_ireplace(' SELECT ', '<br>SELECT ', $item->name);
                        $name = str_ireplace('SELECT ', '<span style="color: #04f;">SELECT</span> ', $name);
                        $name = str_ireplace(' FROM ', '<br><span style="color: #04f;">FROM</span> ', $name);
                        $name = str_ireplace(' LEFT JOIN ', '<br><span style="color: #04f;">LEFT JOIN</span> ', $name);
                        $name = str_ireplace(' RIGHT JOIN ', '<br><span style="color: #04f;">RIGHT JOIN</span> ', $name);
                        $name = str_ireplace(' WHERE ', '<br><span style="color: #04f;">WHERE</span> ', $name);
                        $name = str_ireplace(' HAVING ', '<br><span style="color: #04f;">HAVING</span> ', $name);
                        $name = str_ireplace(' GROUP BY ', '<br><span style="color: #04f;">GROUP BY</span> ', $name);
                        $name = str_ireplace(' ORDER BY ', '<br><span style="color: #04f;">ORDER BY</span> ', $name);
                        $name = str_ireplace(' LIMIT ', '<br><span style="color: #04f;">LIMIT</span> ', $name);
                        $name = str_ireplace(' CHANGE ', ' <span style="color: #04f;">CHANGE</span> ', $name);
                        $name = str_ireplace(' IN (', ' <span style="color: #080;">IN</span> (', $name);
                        $name = str_replace(' ON ', ' <span style="color: #080;">ON</span> ', $name);
                        $name = str_replace(' AND ', ' <span style="color: #080;">AND</span> ', $name);
                        $name = str_replace(' OR ', ' <span style="color: #080;">OR</span> ', $name);
                        $name = str_replace(' AS ', ' <span style="color: #080;">AS</span> ', $name);
                        $name = str_replace(' CASE ', ' <span style="color: #080;">CASE</span> ', $name);
                        $name = str_replace(' WHEN ', ' <span style="color: #080;">WHEN</span> ', $name);
                        $name = str_replace(' THEN ', ' <span style="color: #080;">THEN</span> ', $name);
                        $name = str_replace(' ELSE ', ' <span style="color: #080;">ELSE</span> ', $name);
                        $name = preg_replace('/\s(ASC|DESC|END|WRITE|READ)([\s,;\)])/', ' <span style="color: #080;">$1</span>$2', $name);
                        $name = preg_replace('/(\s|,|\(?)(ABS|SUM|COUNT|MIN|MAX|SQL_CALC_FOUND_ROWS|FOUND_ROWS|DATE_FORMAT|STR_TO_DATE|INDEX|PRIMARY\s+KEY|TRIM|BIGINT|VARCHAR|TINYINT|FLOAT|INT)([\s\(])/', '$1<span style="color: #c60;">$2</span>$3', $name);
                        $over_memory = $item->end_memory - $item->start_memory;
                        echo '<li>'
                               . '<table border="0" cellpadding="0" cellspacing="0" style="border: 0 solid; margin: 0 15px 0 0; padding: 0;">'
                                   . '<tr>'
                                       . '<td nowrap style="border: 0 solid; margin: 0; padding: 0; vertical-align: top;">'
                                           . '<span style="color: #999;">'
                                               . date('H:i.s', $item->timestamp) . ' &nbsp; '
                                               . 'время'
                                           . '</span> '
                                           . ($used >= 0.025 ? '<span style="color: #80f;">' . $used . '</span> &nbsp; '
                                                             : '<span style="color: #080;">' . $used . '</span> &nbsp; ')
                                           . '<span style="color: #999;">ram</span> '
                                           . '<span style="color: #c60;">' . number_format($item->peak_memory / 1204, 0, '.', ' ') . ' кб</span> &nbsp; '
                                           . ($over_memory != 0 ? '<span style="color: #80f;" title="потребил еще ' . number_format($over_memory, 0, '.', ' ') . ' байт">' . number_format($item->end_memory / 1204, 0, '.', ' ') . ' кб</span> &nbsp; '
                                                                : '<span style="color: #08f;">' . number_format($item->end_memory / 1204, 0, '.', ' ') . ' кб</span> &nbsp; ')
                                           . '<span style="color: #999;">' . number_format($item->start_memory / 1204, 0, '.', ' ') . ' кб</span> &nbsp; '
                                           . 'запрос &nbsp;'
                                       . '</td>'
                                       . '<td style="background: #bbb; border: #ccc 1px solid; color: #008; margin: 0; padding: 0 5px; white-space: normal;" width="100%">'
                                           . '<div style="line-height: 24px; height: 24px; overflow: hidden;" '
                                                . 'onclick="this.style.height = (this.style.height == \'auto\') ? \'24px\' : \'auto\'; event.cancelBubble = true; return false;">'
                                               . $name
                                           . '</div>'
                                           . $error
                                           . $affected_rows
                                       . '</td>'
                                   . '</tr>'
                               . '</table>'
                           . '</li>';
                    }

                    // если замечены пост сегментные потери времени
                    if ($number == $count) {
                        $me = sprintf('%1.7f', $item->end_time);
                        $he = sprintf('%1.7f', $prev_end);
                        $inter = sprintf('%1.7f', $he - $me);
                        if ($inter > 0) {
                            echo '<li>'
                                   . '<span style="background: #bbb; color: #999;">'
                                       . '&nbsp; пост сегментное время ' . ($inter >= 0.025 ? '<span style="color: #80f;">' . $inter . '</span>'
                                                                                            : $inter) . ' &nbsp;'
                                   . '</span>'
                               . '</li>';
                        }
                    }
                    $number++;
                }
                echo '</ul>';
            }
        }
    }



    // дампинг таблиц базы данных в файл =====================================

    public function mysqldump ($filename, $dbtables = array()) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB mysqldump");

      // если удалось создать файл
      if ($handle = @fopen($filename, "wb")) {

        // разбираем список дампируемых таблиц
        $query = "все";
        if (is_array($dbtables) && !empty($dbtables)) {
          $query = "";
          foreach ($dbtables as $index => &$item) {
            if (!is_string($item)) $item = "";
            $item = preg_replace("'[^a-z0-9_\-\.]'", "", strtolower($item));
            $item = explode(".", $item, 3);
            $item = isset($item[1]) ? $item[1] : (isset($item[0]) ? $item[0] : "");

            // если имя таблицы задано и это не кеш-таблица
            if (($item != "") && (substr($item, 0, 6) != "cache_")
            && ($item != DATABASE_CACHE_CBPRODUCTS_SHORTVERSION_TABLENAME)
            && ($item != DATABASE_CACHE_CATEGORIES_TABLENAME)
            && ($item != DATABASE_CACHE_BRANDS_TABLENAME)
            && ($item != DATABASE_CACHE_USERS_SHORTVERSION_TABLENAME)
            && ($item != DATABASE_CACHE_MENUS_SHORTVERSION_TABLENAME)) {
              if ($query != "") $query .= ", ";
              $query .= $item;

            // иначе имя не задано или это кеш-таблица
            } else {
              unset($dbtables[$index]);
            }
          }
          $dbtables = array_values($dbtables);
          if ($query == "") $query = "все";
        }
        $query .= " (кроме кеш-таблиц)";

        // записываем заголовок файла
        @fwrite($handle, "-- Impera CMS: дамп таблиц базы данных.\r\n"
                       . "-- Версия системы: " . IMPERA_CMS_CURRENT_VERSION . "\r\n"
                       . "-- http://aimatrix.itak.info\r\n"
                       . "--\r\n"
                       . "-- Время создания: " . date("Y-m-d H:i:s", time()) . "\r\n"
                       . "-- Предписанный список таблиц: " . $query . "\r\n\r\n");

        // получаем список таблиц
        $query = "SHOW TABLES";
        $result = $this->query($query);
        if (!empty($result)) {

          // перебираем список
          while ($row = $this->fetch_row($result)) {
            $item = isset($row[0]) ? strtolower(trim($row[0])) : "";
            $item = preg_replace("'[^a-z0-9_\-\.]'", "", $item);
            $item = explode(".", $item, 3);
            $item = isset($item[1]) ? $item[1] : (isset($item[0]) ? $item[0] : "");

            // если это предписанная и не кеш-таблица
            if (($item != "") && (substr($item, 0, 6) != "cache_")
            && ($item != DATABASE_CACHE_CBPRODUCTS_SHORTVERSION_TABLENAME)
            && ($item != DATABASE_CACHE_CATEGORIES_TABLENAME)
            && ($item != DATABASE_CACHE_BRANDS_TABLENAME)
            && ($item != DATABASE_CACHE_USERS_SHORTVERSION_TABLENAME)
            && ($item != DATABASE_CACHE_MENUS_SHORTVERSION_TABLENAME)
            && (empty($dbtables) || in_array($item, $dbtables))) {

              // запираем таблицу
              $item = trim($row[0]);
              $query = "LOCK TABLES `" . $item . "` WRITE;";
              $this->query($query);

              // делаем дамп таблицы
              $this->mysqldump_table_structure($item, $handle);
              $this->mysqldump_table_data($item, $handle);

              // отпираем таблицу
              $query = "UNLOCK TABLES;";
              $this->query($query);
            }
          }

        // иначе не получен список таблиц
        } else {
          @fwrite($handle, "-- ОШИБКА: не получен список таблиц базы данных или их нет\r\n\r\n");
        }

        // закрываем файл
        @fclose($handle);

        // освобождаем память от запроса
        $this->free_result($result);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // дампинг структуры таблицы базы данных в файловый поток ================

    private function mysqldump_table_structure ($table, &$handle) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB mysqldump_table_structure");

      // записываем заголовок блока
      @fwrite($handle, "-- ----------------------------------------------------------------------------\r\n"
                     . "--\r\n"
                     . "-- ТАБЛИЦА " . $table . ": структура\r\n"
                     . "--\r\n"
                     . "-- ----------------------------------------------------------------------------\r\n\r\n"
                     . "DROP TABLE IF EXISTS `" . $table . "`;\r\n\r\n");

      // получаем структуру таблицы
      $query = "SHOW CREATE TABLE `" . $table . "`;";
      $result = $this->query($query);
      if (!empty($result) && ($row = $this->fetch_assoc($result)) && isset($row["Create Table"])) {
        @fwrite($handle, $row["Create Table"] . ";\r\n\r\n");

      // иначе не получена структура таблицы
      } else {
        @fwrite($handle, "-- ОШИБКА: не получена структура таблицы\r\n\r\n");
      }

      // освобождаем память от запроса
      $this->free_result($result);

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // дампинг содержимого таблицы базы данных в файловый поток ==============

    private function mysqldump_table_data ($table, &$handle) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB mysqldump_table_data");

      // записываем заголовок блока
      @fwrite($handle, "-- ----------------------------------------------------------------------------\r\n"
                     . "--\r\n"
                     . "-- ТАБЛИЦА " . $table . ": содержимое\r\n"
                     . "--\r\n"
                     . "-- ----------------------------------------------------------------------------\r\n\r\n");

      // читаем таблицу небольшими порциями (чтобы не перегружать память на больших таблицах),
      // предполагая что таблица уже заперта (чтобы не сменился порядок записей при поблочном чтении)
      $start = 0;
      $count = 50;
      $types = array();
      $fields = 0;
      do {

        // получаем записи таблицы
        $query = "SELECT * "
               . "FROM `" . $table . "` "
               . "LIMIT " . $start . ", " . $count . ";";
        $result = $this->query($query);
        $readed = !empty($result);

        // если есть какой-то результат
        if ($readed) {

          // если есть прочитанные записи
          $rows = $this->num_rows($result);
          $readed = $rows > 0;
          if ($readed) {

            // если еще не собирали информацию о типах полей
            if (empty($types) || ($fields == 0)) {
              $fields = $this->num_fields($result);

              // собираем типы полей
              $i = 0;
              while ($i < $fields) {
                $meta = $this->fetch_field($result, $i);
                array_push($types, isset($meta->type) ? strtolower(trim($meta->type)) : "");
                $i++;
              }
            }

            // перебираем записи
            if ($fields > 0) {
              $command = "INSERT INTO `" . $table . "` VALUES (";
              while ($row = $this->fetch_row($result)) {
                $values = "";

                // перебираем поля записи
                $i = 0;
                while ($i < $fields) {
                  if (!isset($row[$i]) || is_null($row[$i])) {
                    $values .= "NULL";
                  } else {
                    switch ($types[$i]) {
                      case "int":
                        $values .= intval($row[$i]);
                        break;
                      case "string":
                      case "blob":
                      default:
                        $values .= "'" . $this->query_value($row[$i]) . "'";
                    }
                  }
                  $i++;
                  if ($i < $fields) $values .= ", ";
                }

                // записываем содержимое записи
                @fwrite($handle, $command . $values . ");\r\n");
              }
            }
          }
        }

        // освобождаем память от запроса
        $this->free_result($result);
        $start += $count;
      } while ($readed);

      // дописываем в файл пустую строку
      @fwrite($handle, "\r\n");

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // восстановление таблиц базы данных из дамп файла =======================

    public function mysqlrestore ($filename) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB mysqlrestore");

      // если удалось открыть файл
      if ($handle = @fopen($filename, "rb")) {

        // читаем файл построчно
        $query = "";
        $command = "";
        while (!@feof($handle)) {
          $line = @fgets($handle);
          if ($line === FALSE) break;
          $line = trim($line);

          // если не пустая строка и не комментарий, добавляем в накопитель
          if (($line != "") && (substr($line, 0, 2) != "--") && (substr($line, 0, 2) != "/*")) {
            $query .= $line . " ";

            // если еще только ищем команду
            if ($command == "") {

              // если нашли многострочную вставочную команду, сигнализируем ее выполнение
              $insert = "INSERT INTO ";
              $values = " VALUES ";
              if ((strtoupper(substr($query, 0, strlen($insert))) == $insert)
              && (strtoupper(substr($query, -strlen($values))) == $values)) {
                $command = $query;
                $query = "";
              }

            // иначе уже выполняем какую-то многострочную команду
            } else {

              // если нашли табличную команду, забываем о старой команде
              $drop = "DROP TABLE IF EXISTS ";
              $create = "CREATE TABLE ";
              if ((strtoupper(substr($query, 0, strlen($drop))) == $drop)
              || (strtoupper(substr($query, 0, strlen($create))) == $create)) $command = "";
            }

            // если нашли конец команды или фрагмента многострочной вставочной команды
            if ((substr($line, -1) == ";") || (($command != "") && (substr($line, -2) == "),"))) {

              // если это конец команды или последний фрагмент, готовим запрос
              if (substr($line, -1) == ";") {
                $query = $command . trim($query);

                // забываем о команде
                $command = "";

              // иначе это еще не конец, делаем из фрагмента запрос
              } else {
                $query = $command . substr(trim($query), 0, -1) . ";";
              }

              // выполняем запрос
              $this->query($query) or print("Ошибка выполнения запроса \"<b>" . $query . "</b>\": " . $this->error() . "<br><br>");
              $query = "";
            }
          }
        }

        // закрываем файл
        @fclose($handle);

        // уничтожаем все кеш-таблицы
        $this->drop_caches();
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // уничтожение всех кеш-таблиц ===========================================

    public function drop_caches () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB drop_caches");

      // получаем список таблиц
      $query = "SHOW TABLES";
      $result = $this->query($query);
      if (!empty($result)) {

        // перебираем список
        while ($row = $this->fetch_row($result)) {
          $item = isset($row[0]) ? strtolower(trim($row[0])) : "";
          $item = preg_replace("'[^a-z0-9_\-\.]'", "", $item);
          $item = explode(".", $item, 3);
          $item = isset($item[1]) ? $item[1] : (isset($item[0]) ? $item[0] : "");

          // если это кеш-таблица
          if (($item != "") && ((substr($item, 0, 6) == "cache_")
          || ($item == DATABASE_CACHE_CBPRODUCTS_SHORTVERSION_TABLENAME)
          || ($item == DATABASE_CACHE_CATEGORIES_TABLENAME)
          || ($item == DATABASE_CACHE_BRANDS_TABLENAME)
          || ($item == DATABASE_CACHE_USERS_SHORTVERSION_TABLENAME)
          || ($item == DATABASE_CACHE_MENUS_SHORTVERSION_TABLENAME))) {

            // удаляем таблицу
            $item = trim($row[0]);
            $query = "DROP TABLE `" . $item . "`;";
            $this->query($query);
          }
        }
      }

      // освобождаем память от запроса
      $this->free_result($result);

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }



    function reduce_space ( $text ) {
        return preg_replace('/[ \t]+/u', ' ', $text);
        return $text;
    }



    // =======================================================================
    // Преобразование значений в нужный тип.
    // =======================================================================

    public function value_as_string ($value)   {return trim($value);}
    public function value_as_float ($value)    {return $this->cms->number->floatValue($value);}
    public function value_as_positive ($value) {return abs($this->cms->number->floatValue($value));}
    public function value_as_integer ($value)  {return intval($value);}
    public function value_as_natural ($value)  {return abs(intval($value));}
    public function value_as_boolean ($value)  {return ($value != 1) ? 0 : 1;}
    public function value_as_date ($value)     {if (strval(intval($value)) == trim($value)) return date('Y-m-d H:i:s', intval($value)); return trim(substr(trim($value), 0, 19));}



    function fix_text_for_javascript($text) {
      $result = str_replace("<", " <", $text);
      $result = str_replace(">", "> ", $result);
      $result = str_replace("\\", "/", strip_tags($result));
      $result = str_replace("\"", " ", $result);
      $result = str_replace("'", " ", $result);
      $result = str_replace("\t", " ", $result);
      while (strpos($result, "  ") !== FALSE) $result = str_replace("  ", " ", $result);
      return trim($result);
    }

    // =======================================================================
    // Обновить/добавить запись в таблице базы данных (опциональные указаны в квадратных скобках):
    //   $record = запись
    //     [$record->$id_field] = признак "обновляем запись с таким идентификатором" (иначе запись будет добавлена)
    //     [$record->do_insert_operation] = булевой признак "все равно добавить запись" (не обновлять существующую, а именно добавить)
    //   $dbtable = имя таблицы
    //   $id_field = имя ключевого поля таблицы
    //   $fields = массив имен сохраняемых полей
    //   $values = массив значений сохраняемых полей, уже подготовленных для простой вставки в запрос (например 'it\'s string')
    // =======================================================================

    public function update_record (&$record, $dbtable, $id_field, &$fields, &$values) {

      // если запись непустая
      $id = 0;
      if (!empty($record)) {
        $query = "";

        // определяем ИД записи
        $id = isset($record->$id_field) ? trim($record->$id_field) : 0;

        // определяем, просили ли вставить запись (даже если сообщили ее ИД)
        $inserting = isset($record->do_insert_operation) && $record->do_insert_operation;

        // если ИД неизвестен или просили все равно сделать вставку
        if (empty($id) || $inserting) {

          // перечисляем имена полей
          foreach ($fields as &$field) {
            if ($query != "") $query .= ", ";
            $query .= "`" . $this->query_value($field) . "`";
          }

          // формируем запрос
          $query = "INSERT INTO `" . $dbtable . "` (" . $query . ") "
                 . "VALUES (" . implode(", ", $values) . ");";

        // иначе ИД известен
        } else {

          // перечисляем имена полей и присваивания
          foreach ($fields as $i => &$field) {
            if (isset($values[$i])) {
              if ($query != "") $query .= ", ";
              $query .= "`" . $this->query_value($field) . "` = " . $values[$i];
            }
          }

          // формируем запрос
          $query = "UPDATE `" . $dbtable . "` SET " . $query . " "
                 . "WHERE `" . $id_field . "` = '" . $this->query_value($id) . "';";
        }

        // выполняем запрос
        $this->query($query);

        // если запрос выполнен
        if ($this->res_id !== FALSE) {

          // если ИД был неизвестен или просили все равно сделать вставку
          if (empty($id) || $inserting) {

            // получаем ИД вставленной записи
            $id = $this->insert_id();

            // если ИД получен
            if (!empty($id)) {

              // передаем ИД во входную запись
              $record->$id_field = $id;

              // если в записи есть незаполненное поле URL (кроме таблицы imports), ставим равным ИД записи
              if (isset($record->url) && empty($record->url) && ($dbtable != "imports")) {
                $query = "UPDATE `" . $dbtable . "` "
                       . "SET `url` = `" . $this->query_value($id_field) . "` "
                       . "WHERE `" . $this->query_value($id_field) . "` = '" . $this->query_value($id) . "' "
                                   . "AND (`url` = '' OR `url` IS NULL);";
                $this->query($query);
              }

              // если в записи есть нулевое поле ORDER_NUM (вес), ставим равным ИД записи
              if (isset($record->order_num) && empty($record->order_num)) {
                $query = "UPDATE `" . $dbtable . "` "
                       . "SET `order_num` = " . $id_field . " "
                       . "WHERE `" . $this->query_value($id_field) . "` = '" . $this->query_value($id) . "' "
                                   . "AND (`order_num` = 0 OR `order_num` IS NULL);";
                $this->query($query);
              }

            // иначе ИД вставленной записи не получен
            } else {
              $id = 0;
            }
          }

        // иначе запрос не выполнен
        } else {
          $id = 0;
        }
      }

      // возвращаем ИД записи
      return $id;
    }

    function fix_simple_TEXTAREA_text_for_HTML($text, $mode = FIX_SIMPLE_TEXTAREA_TEXT_MODE_NO_ACTION) {
      switch ($mode) {
        case FIX_SIMPLE_TEXTAREA_TEXT_MODE_ALL_TAGS_CLEAR:
          $result = str_replace("\t", " ", strip_tags($text));
          $result = str_replace("\r", "\n", $result);
          while (strpos($result, " \n") !== FALSE) $result = str_replace(" \n", "\n", $result);
          while (strpos($result, "\n ") !== FALSE) $result = str_replace("\n ", "\n", $result);
          while (strpos($result, "  ") !== FALSE) $result = str_replace("  ", " ", $result);
          while (strpos($result, "\n\n") !== FALSE) $result = str_replace("\n\n", "\n", $result);
          $result = "<p style=\"text-align: justify;\">"
                     . str_replace("\n", "</p>\r\n<p style=\"text-align: justify;\">", trim($result))
                   . "</p>";
          break;
        case FIX_SIMPLE_TEXTAREA_TEXT_MODE_NO_ACTION:
        default:
          $result = $text;
      }
      return $result;
    }

    function fix_HTML_text_for_simple_TEXTAREA_object($text, $mode = FIX_SIMPLE_TEXTAREA_TEXT_MODE_NO_ACTION) {
      switch ($mode) {
        case FIX_SIMPLE_TEXTAREA_TEXT_MODE_ALL_TAGS_CLEAR:
          $result = str_replace("\t", " ", $text);
          $result = str_replace("\r", " ", $result);
          $result = str_replace("\n", " ", $result);
          $result = strip_tags($result, "<p><div><br>");
          $result = preg_replace("/<(p|h[1-6]|div)\s*[^>]*>/i", "", $result);
          $result = preg_replace("/<\/(p|h[1-6]|div)>/i", "\r\n", $result);
          $result = preg_replace("/<br\s*[^>]*>/i", "\r\n", $result);
          $result = str_replace("&nbsp;", " ", $result);
          while (strpos($result, " \r") !== FALSE) $result = str_replace(" \r", "\r", $result);
          while (strpos($result, "\n ") !== FALSE) $result = str_replace("\n ", "\n", $result);
          while (strpos($result, "  ") !== FALSE) $result = str_replace("  ", " ", $result);
          while (strpos($result, "\r\n\r\n") !== FALSE) $result = str_replace("\r\n\r\n", "\r\n", $result);
          $result = str_replace("\r\n", "\r\n\r\n", trim($result));
          break;
        case FIX_SIMPLE_TEXTAREA_TEXT_MODE_NO_ACTION:
        default:
          $result = $text;
      }
      return $result;
    }

    function get_compound_product_model_text(&$product) {
      $result = "";
      if (isset($product->category) && ($this->cms->settings->product_category_show == 1)) $result .= trim($product->category) . " ";
      if (isset($product->brand) && ($this->cms->settings->product_brand_show == 1)) $result .= trim($product->brand) . " ";
      if (isset($product->model)) $result = trim($result . $product->model);
      return $result;
    }

    function process_and_store_image($source_filename,
                                     $destination_filename,
                                     $width_limit, $height_limit,
                                     $stretch_small_mode = PROCESS_IMAGE_STRETCH_SMALL_MODE_NO,
                                     $quality = 90,
                                     $watermark_filename = "",
                                     $watermark_location = IMAGES_WATERMARK_LOCATION_RIGHTBOTTOM,
                                     $watermark_transparency = 75) {
      $result = FALSE;
      if (@file_exists($source_filename) == TRUE) {
        if ((function_exists("getimagesize") == TRUE) && (function_exists("gd_info") == TRUE) && (function_exists("imagedestroy") == TRUE)
        && (function_exists("imagecreatefromjpeg") == TRUE) && (function_exists("imagecreatefrompng") == TRUE) && (function_exists("imagecreatefromgif") == TRUE)
        && (function_exists("imagecreatetruecolor") == TRUE) && (function_exists("imagecopyresampled") == TRUE) && (function_exists("imagecopymerge") == TRUE)
        && (function_exists("imagejpeg") == TRUE) && (function_exists("imagepng") == TRUE) && (function_exists("imagegif") == TRUE)) {
          $size = @getimagesize($source_filename);
          if (($size[PROCESS_IMAGE_FIELD_TYPE] == IMAGETYPE_JPEG) || ($size[PROCESS_IMAGE_FIELD_TYPE] == IMAGETYPE_PNG) || ($size[PROCESS_IMAGE_FIELD_TYPE] == IMAGETYPE_GIF)) {
            $original_image = @gd_info();
            if ((isset($original_image['JPG Support']) || isset($original_image['JPEG Support']))
            && isset($original_image['PNG Support'])
            && isset($original_image['GIF Read Support']) && isset($original_image['GIF Create Support'])) {
              switch ($size[PROCESS_IMAGE_FIELD_TYPE]) {
                case IMAGETYPE_PNG:
                  $original_image = @imagecreatefrompng($source_filename);
                  break;
                case IMAGETYPE_GIF:
                  $original_image = @imagecreatefromgif($source_filename);
                  break;
                case IMAGETYPE_JPEG:
                default:
                  $original_image = @imagecreatefromjpeg($source_filename);
              }
              if ($original_image != FALSE) {
                $width_limit = @intval($width_limit);
                $height_limit = @intval($height_limit);
                if ($width_limit < 1) $width_limit = 1;
                if ($height_limit < 1) $height_limit = 1;
                $width = $size[PROCESS_IMAGE_FIELD_WIDTH];
                $height = $size[PROCESS_IMAGE_FIELD_HEIGHT];
                if ($width > $width_limit) {
                  $height = @intval($width_limit * $height / $width);
                  $width = $width_limit;
                }
                if ($height > $height_limit) {
                  $width = @intval($height_limit * $size[PROCESS_IMAGE_FIELD_WIDTH] / $size[PROCESS_IMAGE_FIELD_HEIGHT]);
                  $height = $height_limit;
                }
                if ($width < 1) $width = 1;
                if ($height < 1) $height = 1;
                if ((($size[PROCESS_IMAGE_FIELD_WIDTH] > $width) || ($size[PROCESS_IMAGE_FIELD_HEIGHT] > $height))
                || ((($size[PROCESS_IMAGE_FIELD_WIDTH] < $width) || ($size[PROCESS_IMAGE_FIELD_HEIGHT] < $height)) && ($stretch_small_mode === PROCESS_IMAGE_STRETCH_SMALL_MODE_OK))) {
                  $destination_image = @imagecreatetruecolor($width, $height);
                  $result = @imagecopyresampled($destination_image, $original_image, 0, 0, 0, 0, $width, $height, $size[PROCESS_IMAGE_FIELD_WIDTH], $size[PROCESS_IMAGE_FIELD_HEIGHT]);
                } else {
                  $destination_image = $original_image;
                  $result = TRUE;
                }
                if ($result == TRUE) {
                  if (($watermark_filename != "") && (@file_exists($watermark_filename) == TRUE)) {
                    if ($watermark_transparency < 1) $watermark_transparency = 1;
                    if ($watermark_transparency > 100) $watermark_transparency = 100;
                    $size = @getimagesize($watermark_filename);
                    if (($size[PROCESS_IMAGE_FIELD_TYPE] == IMAGETYPE_JPEG) || ($size[PROCESS_IMAGE_FIELD_TYPE] == IMAGETYPE_PNG) || ($size[PROCESS_IMAGE_FIELD_TYPE] == IMAGETYPE_GIF)) {
                      switch ($size[PROCESS_IMAGE_FIELD_TYPE]) {
                        case IMAGETYPE_PNG:
                          $watermark_image = @imagecreatefrompng($watermark_filename);
                          break;
                        case IMAGETYPE_GIF:
                          $watermark_image = @imagecreatefromgif($watermark_filename);
                          break;
                        case IMAGETYPE_JPEG:
                        default:
                          $watermark_image = @imagecreatefromjpeg($watermark_filename);
                      }
                      if ($watermark_image != FALSE) {
                        switch ($watermark_location) {
                          case IMAGES_WATERMARK_LOCATION_LEFTTOP:
                            $watermark_x = 0;
                            $watermark_y = 0;
                            break;
                          case IMAGES_WATERMARK_LOCATION_CENTERTOP:
                            $watermark_x = intval(($width - $size[PROCESS_IMAGE_FIELD_WIDTH]) / 2);
                            $watermark_y = 0;
                            break;
                          case IMAGES_WATERMARK_LOCATION_RIGHTTOP:
                            $watermark_x = $width - $size[PROCESS_IMAGE_FIELD_WIDTH];
                            $watermark_y = 0;
                            break;
                          case IMAGES_WATERMARK_LOCATION_LEFTCENTER:
                            $watermark_x = 0;
                            $watermark_y = intval(($height - $size[PROCESS_IMAGE_FIELD_HEIGHT]) / 2);
                            break;
                          case IMAGES_WATERMARK_LOCATION_CENTER:
                            $watermark_x = intval(($width - $size[PROCESS_IMAGE_FIELD_WIDTH]) / 2);
                            $watermark_y = intval(($height - $size[PROCESS_IMAGE_FIELD_HEIGHT]) / 2);
                            break;
                          case IMAGES_WATERMARK_LOCATION_RIGHTCENTER:
                            $watermark_x = $width - $size[PROCESS_IMAGE_FIELD_WIDTH];
                            $watermark_y = intval(($height - $size[PROCESS_IMAGE_FIELD_HEIGHT]) / 2);
                            break;
                          case IMAGES_WATERMARK_LOCATION_LEFTBOTTOM:
                            $watermark_x = 0;
                            $watermark_y = $height - $size[PROCESS_IMAGE_FIELD_HEIGHT];
                            break;
                          case IMAGES_WATERMARK_LOCATION_CENTERBOTTOM:
                            $watermark_x = intval(($width - $size[PROCESS_IMAGE_FIELD_WIDTH]) / 2);
                            $watermark_y = $height - $size[PROCESS_IMAGE_FIELD_HEIGHT];
                            break;
                          case IMAGES_WATERMARK_LOCATION_RIGHTBOTTOM:
                          default:
                            $watermark_x = $width - $size[PROCESS_IMAGE_FIELD_WIDTH];
                            $watermark_y = $height - $size[PROCESS_IMAGE_FIELD_HEIGHT];
                        }
                        $size = @imagecopymerge($destination_image,
                                                $watermark_image,
                                                $watermark_x,
                                                $watermark_y,
                                                0, 0, $size[PROCESS_IMAGE_FIELD_WIDTH], $size[PROCESS_IMAGE_FIELD_HEIGHT],
                                                $watermark_transparency);
                        @imagedestroy($watermark_image);
                      }
                    }
                  }
                  switch (strtolower(substr($destination_filename, strlen($destination_filename) - 4))) {
                    case ".png":
                      $result = @imagepng($destination_image, $destination_filename, 9, PNG_FILTER_NONE);
                      break;
                    case ".gif":
                      $result = @imagegif($destination_image, $destination_filename);
                      break;
                    case ".jpg":
                    default:
                      if ($quality < 1) $quality = 1;
                      if ($quality > 100) $quality = 100;
                      $result = @imagejpeg($destination_image, $destination_filename, $quality);
                  }
                }
                if ($destination_image != $original_image) @imagedestroy($destination_image);
                @imagedestroy($original_image);
              }
            }
          }
        }
      }
      return $result;
    }

    function fix_product_images_and_cache(&$product, $type, $recaching, &$recaching_timer, &$recaching_counter) {
      if (is_null($recaching_timer) == TRUE) $recaching_timer = 0;
      if (is_null($recaching_counter) == TRUE) $recaching_counter = 0;
      $slave_image = FALSE;
      $width_limit = $this->cms->settings->products_images_width;
      $height_limit = $this->cms->settings->products_images_height;
      $watermark_filename = ROOT_FOLDER_REFERENCE . $this->cms->settings->products_files_folder_prefix . "files/watermark_large.png";
      switch ($type) {
        case "small":
          $virtual_name = $product->product_id;
          $image_field = &$product->small_image;
          $width_limit = $this->cms->settings->products_thumbnail_width;
          $height_limit = $this->cms->settings->products_thumbnail_height;
          $watermark_filename = ROOT_FOLDER_REFERENCE . $this->cms->settings->products_files_folder_prefix . "files/watermark_small.png";
          break;
        case "large":
          $virtual_name = $product->product_id;
          $image_field = &$product->large_image;
          break;
        default:
          $virtual_name = $type;
          $type = "other";
          $image_field = &$product->filename;
          $slave_image = TRUE;
      }
if (isset($this->config->only_remote_images) && (strtolower(substr($image_field, 0, 4)) == "http")) {
  if (empty($product->small_image)) $product->small_image = $image_field;
  if (empty($product->large_image)) $product->large_image = $image_field;
  return;
}
      $image_filename = trim($image_field);
      if (strtolower(substr($image_filename, 0, strlen($this->root_url))) != strtolower($this->root_url)) {
        $prepath_images_template_corrector = "";
        $image_field = "";
        if ((isset($this->cms->settings->prepath_images_template_used) == TRUE) && ($this->cms->settings->prepath_images_template_used == 1)) {
          $prepath_images_template_corrector = "../../";
        }
        $filename = $image_filename;
        $filename = str_replace("\\", "/", $filename);
        $work_folder = getcwd();
        $work_folder = str_replace("\\", "/", $work_folder);
        if (substr($work_folder, strlen($work_folder) - 1) != "/") $work_folder = $work_folder . "/";
        $found = FALSE;
        $folder_path = "files/products";
        $folder_subpath = "";
        $folder_prefix = "";
        do {
          $success_folder = "";
          if (strpos($filename, "://") === FALSE) {
            if (isset($this->cms->settings->products_files_folder_prefix)) {
              $folder_prefix = str_replace("/", "", str_replace("\\", "", str_replace(":", "", $this->cms->settings->products_files_folder_prefix)));
            }
          } else {
            $folder_path = "images/products";
            $folder_subpath = "/" . $type;
            $filename = str_replace("/", "", str_replace("\\", "", str_replace(":", "", $virtual_name))) . ".jpg";
          }
          do {
            $dir = $this->root_dir;
            if (substr($dir, 0, 1) == "/") $dir = substr($dir, 1);
            $folder_bridge = "";
            do {
              $foldername = $folder_bridge . $folder_prefix . $folder_path;
              if (is_dir($work_folder . $foldername) == TRUE) {
                $success_folder = $work_folder . $foldername;
                $image_url = $folder_subpath . "/" . $filename;
                if (@file_exists($success_folder . $image_url) && !empty($filename)) {
                  $found = TRUE;
                  $size = getimagesize($success_folder . $image_url);
                  if ((isset($size[0]) == TRUE) && (isset($size[1]) == TRUE)) {
                    $product->image_width = $size[0];
                    $product->image_height = $size[1];
                    $product->image_vertical = ($size[1] > $size[0]);
                  }
                  $image_field = $prepath_images_template_corrector . $foldername . $image_url;
                  break 3;
                }
              }
              if ($dir == "") break;
              $folder_bridge = $folder_bridge . "../";
              $index = strpos($dir, "/");
              if ($index !== FALSE) {
                $dir = trim(substr($dir, $index + 1));
              } else {
                $dir = "";
              }
            } while (TRUE);
            if ($folder_prefix == "") break;
            $folder_prefix = "";
          } while (TRUE);
          if ($folder_path == "images/products") break;
          $filename = "://";
        } while (TRUE);
        if ((isset($this->cms->settings->images_caching_enabled) == TRUE) && ($this->cms->settings->images_caching_enabled == 1)
        && (isset($this->cms->settings->images_caching_lifetime) == TRUE) && (@intval($this->cms->settings->images_caching_lifetime) > 0)
        && ($recaching === MAKE_IMAGE_RECACHING_IF_ENABLED)
        && (((strtolower($_SERVER["HTTP_HOST"]) != "localhost") && ($_SERVER["HTTP_HOST"] != "127.0.0.1"))
        || ((isset($this->cms->settings->images_caching_for_localhost_enabled) == TRUE) && ($this->cms->settings->images_caching_for_localhost_enabled == 1)))) {
          if ($folder_path == "images/products") {
            if ($success_folder != "") {
              $recache_after = @intval($this->cms->settings->images_caching_lifetime);
              if (($found == FALSE) || (time() - @filemtime($success_folder . $image_url) > $recache_after)) {
                @mkdir($success_folder . $folder_subpath, 0777, TRUE);
                $filename = $image_filename;
                if (isset($this->cms->settings->images_caching_ip_resolves) == TRUE) {
                  $ip_resolves = str_replace("\r", "\n", trim($this->cms->settings->images_caching_ip_resolves));
                  $ip_resolves = str_replace("\t", " ", $ip_resolves);
                  while (strpos($ip_resolves, "  ") !== FALSE) $ip_resolves = str_replace("  ", " ", $ip_resolves);
                  while (strpos($ip_resolves, "\n\n") !== FALSE) $ip_resolves = str_replace("\n\n", "\n", $ip_resolves);
                  $ip_resolves = explode("\n", trim($ip_resolves));
                  foreach ($ip_resolves as $ip_resolve) {
                    $ip_resolve = trim($ip_resolve);
                    if ($ip_resolve != "") {
                      $ip_resolve = explode(" ", $ip_resolve);
                      if (count($ip_resolve) == 2) {
                        $filename = str_ireplace("://" . strtolower($ip_resolve[0]) . "/", "://" . strtolower($ip_resolve[1]) . "/", $filename);
                      }
                    }
                  }
                }
                if (@function_exists("microtime") == TRUE) {
                  $recaching_timer = microtime(TRUE);
                } else {
                  $recaching_timer = time();
                }
                $filename = @file_get_contents(trim($filename));
                if ($filename) {
                  @file_put_contents($success_folder . $image_url, $filename);
                  if ((isset($this->cms->settings->products_watermark_enabled) == FALSE) || ($this->cms->settings->products_watermark_enabled != 1)) $watermark_filename = "";
                  DatabaseEX::process_and_store_image($success_folder . $image_url,
                                                      $success_folder . $image_url,
                                                      $width_limit,
                                                      $height_limit,
                                                      PROCESS_IMAGE_STRETCH_SMALL_MODE_NO,
                                                      $this->cms->settings->products_images_quality,
                                                      $watermark_filename,
                                                      $this->cms->settings->products_watermark_location,
                                                      $this->cms->settings->products_watermark_transparency);
                  $recaching_counter = $recaching_counter + 1;
                }
                if (@function_exists("microtime") == TRUE) {
                  $recaching_timer = abs(@intval(microtime(TRUE) - $recaching_timer));
                } else {
                  $recaching_timer = abs(time() - $recaching_timer);
                }
                if ($found == FALSE) $image_field = $prepath_images_template_corrector . $foldername . $image_url;
              }
            }
          }
        } else {
          if ($slave_image == TRUE) {
            if ($found == FALSE) $image_field = $image_filename;
          }
        }
      }
    }

    public function fix_textfield_as_product_name(&$field) {
      $field = str_replace("&nbsp;", " ", $field);
//      $field = str_replace(chr(160), " ", $field);
      $field = str_replace("\t", " ", $field);
      $field = str_replace("\r", " ", $field);
      $field = str_replace("\n", " ", $field);
      while (strpos($field, "  ") !== FALSE) $field = str_replace("  ", " ", $field);
    }

    public function fix_textfield_as_product_description(&$field) {
      if ($this->cms->settings->products_wysiwyg_disabled == 1) {
        if ($this->cms->settings->products_wysiwyg_disabled_mode == FIX_SIMPLE_TEXTAREA_TEXT_MODE_ALL_TAGS_CLEAR) {
          $field = strip_tags($field, "<br>");
          $field = str_replace("\t", " ", $field);
          while (strpos($field, "  ") !== FALSE) $field = str_replace("  ", " ", $field);
          $field = str_ireplace("<br />", "<br>", $field);
          $field = str_ireplace("<br/>", "<br>", $field);
          $field = str_ireplace("<br>", "\n", $field);
          $field = str_replace("\r", "\n", $field);
          $field = str_replace("\n", "<br>", $field);
          $field = str_replace(" <br>", "<br>", $field);
          $field = str_replace("<br> ", "<br>", $field);
          while (strpos($field, "<br><br><br>") !== FALSE) $field = str_replace("<br><br><br>", "<br><br>", $field);
        }
      }
    }

    function fix_shop_section_value ( & $section ) {
        $section = @ intval($section);
        $section = max(1, $section);
        $section = min($section, 1000);
    }

    function get_subdomain_using(&$item, $subdomain, $exclude_id, $mode) {
      $item = null;
      $subdomain = trim($subdomain);
      if ($subdomain != "") {
        $brand_filter = "subdomain = '" . $this->query_value($subdomain) . "' ";
        $category_filter = $brand_filter;
        $product_filter = $brand_filter;
        $user_filter = $brand_filter;
        switch ($mode) {
          case CHECK_SUBDOMAIN_USING_MODE_BY_BRANDID:
            $brand_filter .= "AND brand_id != '" . $this->query_value($exclude_id) . "' ";
            break;
          case CHECK_SUBDOMAIN_USING_MODE_BY_CATEGORYID:
            $category_filter .= "AND category_id != '" . $this->query_value($exclude_id) . "' ";
            break;
          case CHECK_SUBDOMAIN_USING_MODE_BY_PRODUCTID:
            $product_filter .= "AND product_id != '" . $this->query_value($exclude_id) . "' ";
            break;
          case CHECK_SUBDOMAIN_USING_MODE_BY_USERID:
          default:
            $user_filter .= "AND user_id != '" . $this->query_value($exclude_id) . "' ";
        }
        $query = "SELECT * "
               . "FROM (SELECT (SELECT brand_id FROM " . DATABASE_BRANDS_TABLENAME . " WHERE " . $brand_filter . "LIMIT 1) AS brand_id, "
                            . "(SELECT category_id FROM " . DATABASE_CATEGORIES_TABLENAME . " WHERE " . $category_filter . "LIMIT 1) AS category_id, "
                            . "(SELECT product_id FROM products WHERE " . $product_filter . "LIMIT 1) AS product_id, "
                            . "(SELECT user_id FROM " . DATABASE_USERS_TABLENAME . " WHERE " . $user_filter . "LIMIT 1) AS user_id) AS result "
               . "WHERE brand_id IS NOT NULL "
                     . "OR category_id IS NOT NULL "
                     . "OR product_id IS NOT NULL "
                     . "OR user_id IS NOT NULL;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);
      }
    }

    function get_groups_array(&$groups, $mode = GET_GROUPS_MODE_FOR_ANY, $start = null, $maxcount = null) {
      $groups = array();
      $where = "";
      $limit = "";
      if (($mode === GET_GROUPS_MODE_FOR_AUTHORIZED) || ($mode === GET_GROUPS_MODE_FOR_UNAUTHORIZED)) {
        $where = "WHERE authorized = " . (($mode === GET_GROUPS_MODE_FOR_UNAUTHORIZED) ? "0" : "1") . " ";
      }
      if (!is_null($start) || !is_null($maxcount)) {
        if (!is_null($start)) {
          $start = @intval($start);
          if ($start < 1) {
            $start = "";
          } else {
            $start = $start . ", ";
          }
        } else {
          $start = "";
        }
        if (!is_null($maxcount)) {
          $limit = @intval($maxcount);
          if ($limit < 0) $limit = "";
        }
        $limit = "LIMIT " . $start . $limit;
      }
      $query = "SELECT SQL_CALC_FOUND_ROWS * "
             . "FROM groups "
             . $where
             . "ORDER BY discount ASC, "
                      . "from_sum ASC, "
                      . "name ASC "
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      foreach ($items as $item) {
        if (!empty($item)) {
          if (isset($item->group_id)) {
            $groups[$item->group_id] = $item;
            $groups[$item->group_id]->first = TRUE;
          }
        }
      }
      foreach ($groups as &$item) {
        if (isset($item->next_group_id) && !empty($item->next_group_id)
        && ($item->next_group_id != $item->group_id) && isset($groups[$item->next_group_id])) {
          $ring = FALSE;
          $group_id = $item->next_group_id;
          while (!$ring && isset($groups[$group_id]) && !empty($groups[$group_id]->next_group_id)) {
            $group_id = $groups[$group_id]->next_group_id;
            $ring = ($item->group_id == $group_id);
          }
          if (!$ring) {
            $item->next = &$groups[$item->next_group_id];
            $groups[$item->next_group_id]->first = FALSE;
          }
        } else {
          $item->next_group_id = 0;
          $item->next = null;
        }
      }
      return $count;
    }

    function fill_products_properties_values_to_products_by_ids(&$products, &$products_ids_filter, $products_array_mode) {
      if (!empty($products)) {
        if ($products_ids_filter != "") {
          $query = "SELECT * "
                 . "FROM properties, "
                      . DATABASE_PROPERTIES_VALUES_TABLENAME . " "
                 . "WHERE " . DATABASE_PROPERTIES_VALUES_TABLENAME . ".product_id in (" . $products_ids_filter . ") "
                       . "AND " . DATABASE_PROPERTIES_VALUES_TABLENAME . ".property_id = properties.property_id "
                       . "AND enabled = 1 "
                 . "ORDER BY properties.order_num ASC, "
                           . DATABASE_PROPERTIES_VALUES_TABLENAME . ".order_num ASC;";
          $result = $this->query($query);
          if (!empty($result)) {
            if ($products_array_mode === PRODUCTS_ARRAY_MODE_THIS_IS_ARRAY) {
              while ($row = $this->fetch_object($result)) {
                if (isset($products[$row->product_id])) {
                  if ($products[$row->product_id] !== FALSE) {
                    if (!isset($products[$row->product_id]->properties)) $products[$row->product_id]->properties = array();
                    $products[$row->product_id]->properties[] = $row;
                  }
                }
              }
              foreach ($products as &$row) {
                if ($row !== FALSE) {
                  if (!empty($row->properties)) {
                    $row->properties_tree = array();
                    foreach ($row->properties as &$property) {
                      if (!isset($row->properties_tree[$property->property_id])) {
                        $row->properties_tree[$property->property_id] = array();
                      }
                      $row->properties_tree[$property->property_id][$property->order_num] = &$property;
                    }
                  }
                }
              }
            } else {
              $products->properties[] = array();
              while ($row = $this->fetch_object($result)) $products->properties[] = $row;
              if (!empty($products->properties)) {
                $products->properties_tree = array();
                foreach ($products->properties as &$property) {
                  if (isset($property->property_id)) {
                    if (!isset($products->properties_tree[$property->property_id])) {
                      $products->properties_tree[$property->property_id] = array();
                    }
                    $products->properties_tree[$property->property_id][$property->order_num] = &$property;
                  }
                }
              }
            }
          }

          // освобождаем память от запроса
          $this->free_result($result);
        }
      }
    }

    function fill_product_wishlist_data(&$product, &$currency) {
      if (empty($product) == FALSE) {
        if (($this->cms->settings->vkontakte_wishlist_enabled == 1)
        && (($this->cms->settings->vkontakte_wishlist_selected_only != 1) || ($product->vkontakte == 1))) {
          if (empty($product->vkontakte_wishlist_data) == TRUE) {
            if (empty($currency) == FALSE) {
              $image_url = (($product->large_image != "") ? $product->large_image : $product->small_image);
              $wishlist = array();
              $wishlist["merchant_id"] = $this->fix_text_for_javascript(($this->cms->settings->vkontakte_wishlist_merchantid != "") ? $this->cms->settings->vkontakte_wishlist_merchantid : 0);
              $wishlist["item_id"] = $this->fix_text_for_javascript($product->product_id);
              $wishlist["item_name"] = $this->fix_text_for_javascript($product->category . " " . $product->brand . " " . $product->model);
              $wishlist["item_description"] = $this->fix_text_for_javascript(($product->description != "") ? $product->description : $product->body);
              $wishlist["item_currency"] = "RUB";
              $price = isset($product->variants[0]->discount_price) ? $product->variants[0]->discount_price * $currency->rate_from / $currency->rate_to : 0;
              if ($this->cms->number->floatValue($this->cms->settings->vkontakte_wishlist_cost_increase) > 0) {
                $price = $price + $price * ($this->cms->number->floatValue($this->cms->settings->vkontakte_wishlist_cost_increase) / 100);
              }
              $wishlist["item_price"] = @round($price, 2);
              if ($image_url != "") {
                if (strtolower(substr($image_url, 0, 7)) != "http://") $image_url = "http://" . $this->root_url . "/" . $image_url;
                $wishlist["item_photo_url"] = $image_url;
              }
              $wishlist["shipping_price"] = @round((($this->cms->settings->vkontakte_wishlist_delivery_cost != "") ? $this->cms->settings->vkontakte_wishlist_delivery_cost : 0), 2);
              ksort($wishlist);
              $signature = "";
              foreach ($wishlist as $key => $value) $signature .= $key . "=" . $value;
              $signature = md5($signature . $this->cms->settings->vkontakte_wishlist_secret);
              if ($this->cms->settings->vkontakte_wishlist_testmode == 1) {
                $wishlist["testmode"] = 1;
              }
              $wishlist["sig"] = $signature;
              $product->vkontakte_wishlist_data = "";
              foreach ($wishlist as $key => $value) {
                if (($key == "item_name") || ($key == "item_description") || ($key == "item_currency") || ($key == "item_photo_url") || ($key == "sig")) $value = "'" . $value . "'";
                if ($product->vkontakte_wishlist_data != "") $product->vkontakte_wishlist_data .= ", ";
                $product->vkontakte_wishlist_data .= $key . ": " . $value;
              }
            }
          }
        }
      }
    }

    function fill_products_wishlist_data(&$products, $products_array_mode) {
      if (empty($products) == FALSE) {
        if ($this->cms->settings->vkontakte_wishlist_enabled == 1) {
          $currency = null;
          foreach ($this->currencies as $item) {
            if (strtolower($item->code) == "rur") {
              $currency = $item;
              break;
            }
          }
          if (empty($currency) == FALSE) {
            if ($products_array_mode === PRODUCTS_ARRAY_MODE_THIS_IS_ARRAY) {
              foreach ($products as &$product) $this->fill_product_wishlist_data($product, $currency);
            } else {
              $this->fill_product_wishlist_data($products, $currency);
            }
          }
        }
      }
    }

    function fill_order_vkontakte_payment_data(&$order, &$currency) {
      if (empty($order) == FALSE) {
        if ($this->cms->settings->vkontakte_payment_enabled == 1) {
          if (empty($order->vkontakte_payment_data) == TRUE) {
            if (empty($currency) == FALSE) {
              $payment = array();
              $payment["merchant_id"] = $this->fix_text_for_javascript(($this->cms->settings->vkontakte_payment_merchantid != "") ? $this->cms->settings->vkontakte_payment_merchantid : 0);
              $payment["success_url"] = "http://" . $this->root_url . "/vk_success/";
              if ($this->cms->settings->vkontakte_payment_result_url != "") {
                if (((strtolower(substr(trim($this->cms->settings->vkontakte_payment_result_url), 0, 7)) == "http://") && (strlen(trim($this->cms->settings->vkontakte_payment_result_url)) > 7))
                || ((strtolower(substr(trim($this->cms->settings->vkontakte_payment_result_url), 0, 8)) == "https://") && (strlen(trim($this->cms->settings->vkontakte_payment_result_url)) > 8))) {
                  $payment["success_url"] = $this->cms->settings->vkontakte_payment_result_url;
                }
              }
              $payment["fail_url"] = "http://" . $this->root_url . "/vk_fail/";
              if ($this->cms->settings->vkontakte_payment_fail_url != "") {
                if (((strtolower(substr(trim($this->cms->settings->vkontakte_payment_fail_url), 0, 7)) == "http://") && (strlen(trim($this->cms->settings->vkontakte_payment_fail_url)) > 7))
                || ((strtolower(substr(trim($this->cms->settings->vkontakte_payment_fail_url), 0, 8)) == "https://") && (strlen(trim($this->cms->settings->vkontakte_payment_fail_url)) > 8))) {
                  $payment["fail_url"] = $this->cms->settings->vkontakte_payment_fail_url;
                }
              }
              $cost_increase = $this->cms->number->floatValue($this->cms->settings->vkontakte_payment_cost_increase) / 100;
              $payment["items"] = array();
              $index = 0;
              foreach ($order->products as $product) {
                if (empty($product) == FALSE) {
                  $payment["items"][$index] = array();
                  $payment["items"][$index]["id"] = $this->fix_text_for_javascript((($product->variant_id != $product->product_id) && ($product->variant_id != 0)) ? $product->variant_id : $product->product_id);
                  $payment["items"][$index]["name"] = "'" . $this->fix_text_for_javascript($product->product_name . ((($product->variant_name != $product->product_name) && ($product->variant_name != "")) ? " " . $product->variant_name : "")) . "'";
                  $payment["items"][$index]["description"] = "'" . $this->fix_text_for_javascript((($product->quantity < 0)) ? $this->cms->settings->cart_reservation_text : "") . "'";
                  $payment["items"][$index]["currency"] = "'RUB'";
                  $price = $product->price * $currency->rate_from / $currency->rate_to;
                  if ($cost_increase > 0) $price = $price + $price * $cost_increase;
                  $payment["items"][$index]["price"] = @round($price, 2);
                  $payment["items"][$index]["quantity"] = (($product->quantity != 0) ? abs(intval($product->quantity)) : 1);
                  if ($product->download != "") {
                    $payment["items"][$index]["digital"] = 1;
                  } else {
                    $payment["items"][$index]["digital"] = 1;  // ignore VK deliveries
                  }
                  $index = $index + 1;
                }
              }
              if ($order->delivery_price != 0) {
                $payment["items"][$index] = array();
                $payment["items"][$index]["id"] = 100000;
                $payment["items"][$index]["name"] = "'Доставка (" . $this->fix_text_for_javascript($order->delivery_method) . ")'";
                $payment["items"][$index]["description"] = "''";
                $payment["items"][$index]["currency"] = "'RUB'";
                $price = $order->delivery_price * $currency->rate_from / $currency->rate_to;
                if ($cost_increase > 0) $price = $price + $price * $cost_increase;
                $payment["items"][$index]["price"] = @round($price, 2);
                $payment["items"][$index]["quantity"] = 1;
                $payment["items"][$index]["digital"] = 1;
              }
              if ($this->cms->settings->vkontakte_payment_testmode == 1) {
                $payment["testmode"] = 1;
              }
              $order->vkontakte_payment_data = "";
              foreach ($payment as $key => $value) {
                if (($key == "success_url") || ($key == "fail_url")) {
                  $value = "'" . $value . "'";
                } else {
                  if ($key == "items") {
                    $items_data = "";
                    foreach ($value as $item) {
                      if ($items_data != "") $items_data .= "}, {";
                      foreach ($item as $item_key => $item_value) {
                        if (($items_data != "") && (substr($items_data, -1) != "{")) $items_data .= ", ";
                        $items_data .= $item_key . ": " . $item_value;
                      }
                    }
                    $value = "[{" . $items_data . "}]";
                  }
                }
                if ($order->vkontakte_payment_data != "") $order->vkontakte_payment_data .= ", ";
                $order->vkontakte_payment_data .= $key . ": " . $value;
              }
            }
          }
        }
      }
    }

    function get_product_by_subdomain(&$product, $subdomain) {
      $product = null;
      $subdomain = trim($subdomain);
      if ($subdomain != "") {
        $query = "SELECT * "
               . "FROM products "
               . "WHERE subdomain = '" . $this->query_value($subdomain) . "' "
                     . "AND subdomain_enabled = 1 "
                     . "AND enabled = 1 "
               . "LIMIT 1;";
        $result = $this->query($query);
        if (!empty($result)) {
          while ($product = $this->fetch_object($result)) break;
        }

        // освобождаем память от запроса
        $this->free_result($result);
      }
    }

    function delete_products_by_id_filter(&$id_filter, $section = null) {
      $result = TRUE;
      if ($id_filter != "") {
        $this->fix_shop_section_value($section);
        $query = "DELETE FROM products_categories "
               . "WHERE product_id in (" . $id_filter . ");";
        $this->query($query);
        $query = "DELETE FROM products_comments "
               . "WHERE product_id in (" . $id_filter . ");";
        $this->query($query);
        $query = "DELETE FROM related_products "
               . "WHERE product_id in (" . $id_filter . ");";
        $this->query($query);
        $query = "DELETE FROM " . DATABASE_PROPERTIES_VALUES_TABLENAME . " "
               . "WHERE product_id in (" . $id_filter . ");";
        $this->query($query);
        $query = "DELETE FROM products_variants "
               . "WHERE product_id in (" . $id_filter . ");";
        $this->query($query);
        $query = "DELETE FROM products "
               . "WHERE product_id in (" . $id_filter . ") "
                     . ((is_null($section) == FALSE) ? "AND section = '" . $this->query_value($section) . "'" : "") . ";";
        $this->query($query);
        if ($this->res_id === FALSE) $result = FALSE;
      }
      return $result;
    }

    function delete_products_by_ancient_zero_quantity($days_lifetime) {
      $quantity = 0;
      $days_lifetime = @intval($days_lifetime);
      if ($days_lifetime >= 0) {
        $query = "SELECT products.product_id "
               . "FROM products "
               . "LEFT JOIN (SELECT product_id, "
                                 . "SUM(stock) AS total_quantity "
                          . "FROM products_variants "
                          . "WHERE stock >= 0 "
                          . "GROUP BY product_id) AS jpv "
                          . "ON jpv.product_id = products.product_id "
               . "WHERE jpv.total_quantity <= 0 "
                     . "AND TO_DAYS(NOW())-TO_DAYS(products.modified) > " . $days_lifetime . " "
               . "GROUP BY product_id;";
        $result = $this->query($query);
        if (!empty($result)) {
          $count = 0;
          $id_filter = "";
          while ($row = $this->fetch_object($result)) {
            if ($id_filter != "") $id_filter = $id_filter . ",";
            $id_filter = $id_filter . "'" . $this->query_value($row->product_id) . "'";
            $count = $count + 1;
          }
          if ($this->delete_products_by_id_filter($id_filter)) {
            $quantity = $count;
          }
        }

        // освобождаем память от запроса
        $this->free_result($result);
      }
      return $quantity;
    }

    function delete_products_by_ancient_zero_price($days_lifetime) {
      $quantity = 0;
      $days_lifetime = @intval($days_lifetime);
      if ($days_lifetime >= 0) {
        $query = "SELECT products.product_id "
               . "FROM products "
               . "LEFT JOIN (SELECT product_id, "
                                 . "SUM(price) AS total_price "
                          . "FROM products_variants "
                          . "WHERE price >= 0 "
                          . "GROUP BY product_id) AS jpv "
                          . "ON jpv.product_id = products.product_id "
               . "WHERE jpv.total_price <= 0 "
                     . "AND TO_DAYS(NOW())-TO_DAYS(products.modified) > " . $days_lifetime . " "
               . "GROUP BY product_id;";
        $result = $this->query($query);
        if (!empty($result)) {
          $count = 0;
          $id_filter = "";
          while ($row = $this->fetch_object($result)) {
            if ($id_filter != "") $id_filter = $id_filter . ",";
            $id_filter = $id_filter . "'" . $this->query_value($row->product_id) . "'";
            $count = $count + 1;
          }
          if ($this->delete_products_by_id_filter($id_filter)) {
            $quantity = $count;
          }
        }

        // освобождаем память от запроса
        $this->free_result($result);
      }
      return $quantity;
    }



    function insert_variant_into_order ( $order_id, & $variant, $amount ) {
        $model = $this->get_compound_product_model_text($variant);
        $query = 'INSERT INTO ' . DATABASE_ORDERS_PRODUCTS_TABLENAME . ' (order_id, '
                                                                       . "product_id, "
                                                                       . "variant_id, "
                                                                       . "product_name, "
                                                                       . "variant_name, "
                                                                       . "name_properties, "
                                                                       . "price, "
                                                                       . "real_price, "
                                                                       . "quantity) "
               . "VALUES ('" . $this->query_value($order_id) . "', "
                       . "'" . $this->query_value($variant->product_id) . "', "
                       . "'" . $this->query_value($variant->variant_id) . "', "
                       . "'" . $this->query_value($model) . "', "
                       . "'" . $this->query_value($variant->name) . "', "
                       . "'" . $this->query_value($variant->name_properties) . "', "
                       . "'" . $this->query_value($variant->discount_price) . "', "
                       . "'" . $this->query_value(((isset($variant->price) == TRUE) && ($variant->price > 0)) ? $variant->price : $variant->discount_price) . "', "
                       . $this->query_value($amount) . ");";
        $this->query($query);



        if (!$this->cms->settings->orders_non_touch_quantity) {
            $query = 'UPDATE products_variants '
                   . 'SET stock = stock - ' . abs($amount) . ' '
                   . 'WHERE product_id = \'' . $this->query_value($variant->product_id) . '\' '
                         . 'AND variant_id = \'' . $this->query_value($variant->variant_id) . '\' '
                         . 'AND stock >= ' . abs($amount) . ';';
            $this->query($query);
        }
    }




    // =======================================================================
    // Сбросить таблицы базы данных:
    //   $dbtables = список таблиц (через запятую или пробел)
    // =======================================================================

    public function reset_dbtables ($dbtables) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB reset_dbtables");

      // если список таблиц не пустой
      $dbtables = str_replace(",", " ", $dbtables);
      $dbtables = str_replace(";", " ", $dbtables);
      $dbtables = str_replace("`", " ", $dbtables);
      $dbtables = str_replace("'", " ", $dbtables);
      $dbtables = str_replace("\"", " ", $dbtables);
      $dbtables = str_replace("\r", " ", $dbtables);
      $dbtables = str_replace("\n", " ", $dbtables);
      $dbtables = str_replace("\t", " ", $dbtables);
      $dbtables = trim($dbtables);
      if ($dbtables != "") {

        // разбираем список
        $query = "";
        while (strpos($dbtables, "  ") !== FALSE) $dbtables = str_replace("  ", " ", $dbtables);
        $dbtables = explode(" ", $dbtables);
        foreach ($dbtables as &$item) {
          $item = trim($item);
          if ($item != "") {
            $item = "`" . $this->query_value($item) . "`";
            if ($query != "") $query .= ", ";
            $query .= $item . " WRITE";
          }
        }

        // запираем доступ к таблицам
        if ($query != "") {
          $query = "LOCK TABLES " . $query . ";";
          $this->query($query);

          // очищаем таблицы
          foreach ($dbtables as &$item) {
            if ($item != "") {
              $query = "DELETE FROM " . $item . ";";
              $this->query($query);
            }
          }

          // отпираем доступ к таблицам
          $query = "UNLOCK TABLES;";
          $this->query($query);
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }



    // =======================================================================
    // Кешировать результат SELECT-а:
    //   $select = текст запроса (без вступительного слова SELECT, то есть начиная с отбираемых полей)
    //   $dbtables = список использованных в запросе таблиц и их псевдонимов (через запятую или пробел)
    //   $indexes = список объявлений индексов (через запятую)
    //   $cache_dbtable = имя кеш-таблицы
    //   $cache_lifetime = срок жизни контента кеш-таблицы
    //   [$cache_inmemory] = булевой признак "кешировать в памяти"
    //                       недопустим TRUE, если SELECT дает BLOB/TEXT колонки
    //   [$return_result] = булевой признак "возвратить результирующие записи"
    //   [$items] = результирующие записи будут возращены сюда
    // =======================================================================

    public function caching_SELECT ( $select,
                                     $dbtables,
                                     $indexes,
                                     $cache_dbtable,
                                     $cache_lifetime,
                                     $cache_inmemory = FALSE,
                                     $return_result = FALSE,
                                     & $items = null ) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB caching_SELECT');

        $items = null;
        $error = FALSE;

        // если задана кеш-таблица
        $cache_dbtable = preg_replace('/[,;`"\'\r\n\t]/', ' ', $cache_dbtable);
        $cache_dbtable = trim($cache_dbtable);
        $cache_dbtable = explode(' ', $cache_dbtable, 2);
        $cache_dbtable = $cache_dbtable[0];
        if ($cache_dbtable != '') {
            $cache_dbtable = '`' . $this->query_value($cache_dbtable) . '`';

            // если задан текст запроса, получаем его хеш
            $select = trim($select);
            if ($select != '') {
                $hash = $this->query_value(strtolower(md5($select)));

                // запираем доступ к таблицам
                $query = 'LOCK TABLES ' . $cache_dbtable . ' WRITE';
                $dbtables = preg_replace('/[,;`"\'\r\n\t]/', ' ', $dbtables);
                $dbtables = trim($dbtables);
                if ($dbtables != '') {
                    $dbtables = preg_replace('/[ \r\n\t]+/', ' ', $dbtables);
                    $dbtables = explode(' ', $dbtables);
                    foreach ($dbtables as & $item) {
                        $item = trim($item);
                        if ($item != '') {
                            $item = '`' . $this->query_value($item) . '`';
                            $query .= ', ' . $item . ' WRITE';
                        }
                    }
                }
                $query .= ';';
                $this->query($query);



                // проверяем, есть ли такое в кеше
                $query = 'SELECT `cache_time`, '
                              . '`cache_version` '
                       . 'FROM ' . $cache_dbtable . ' '
                       . 'WHERE `cache_hash` = "' . $hash . '" '
                       . 'LIMIT 1;';
                $result = $this->query($query);
                $error = $this->error() != '';
                $item = $this->result();

                // освобождаем память от запроса
                $this->free_result($result);



                // если нет или истекло по времени или не та версия
                $time = time();
                if ($error || empty($item) || $item->cache_time + $cache_lifetime < $time || $item->cache_version != IMPERA_CMS_CURRENT_VERSION) {

                    // резервируем 2 прохода (второй для случая "неверная структура кеш-таблицы")
                    $pass = 2;
                    do {
                        $pass--;

                        // удаляем устаревшее
                        $dropped = $error || isset($item->cache_version) && $item->cache_version != IMPERA_CMS_CURRENT_VERSION;
                        if ($dropped) {
                            $query = 'DROP TABLE IF EXISTS ' . $cache_dbtable . ';';
                        } else {
                            $query = 'DELETE FROM ' . $cache_dbtable . ' '
                                   . 'WHERE `cache_hash` = "' . $hash . '";';
                        }
                        $this->query($query);



                        // добавляем текущее
                        $indexes = str_replace(';', ' ', $indexes);
                        $indexes = trim($indexes);
                        $query = 'SET @cache_order := 0;';
                        $this->query($query);
                        if ($this->cms->request->getServerAsSentence('HTTP_HOST') == 'localhost') {
                            $query = 'UNLOCK TABLES;';
                            $this->query($query);
                        }
                        $query = 'SELECT "' . $hash . '" AS `cache_hash`, '
                                      . '@cache_order := @cache_order + 1 AS `cache_order`, '
                                      . '`cache_query`.*, '
                                      . $time . ' AS `cache_time`, '
                                      . IMPERA_CMS_CURRENT_VERSION . ' AS `cache_version` '
                               . 'FROM (SELECT ' . $select . ') AS `cache_query`;';
                        if ($dropped) {
                            $query = 'CREATE TABLE IF NOT EXISTS ' . $cache_dbtable . ' (INDEX (`cache_hash`), '
                                                                                      . 'INDEX (`cache_order`)'
                                                                                      . ($indexes != '' ? ', ' . $indexes : '') . ') '
                                                                                      . 'ENGINE = ' . ($cache_inmemory ? 'MEMORY' : 'MyISAM') . ' '
                                                                                      . $query;
                        } else {
                            $query = 'INSERT INTO ' . $cache_dbtable . ' ' . $query;
                        }
                        $result = $this->query($query);

                        // проверяем необходимость второго прохода
                        $error = $this->error() != '';
                    } while ($error && $pass > 0);
                }



                // если нет ошибки и требовали возвратить результирующие записи
                if (!$error && $return_result) {
                    $query = 'SELECT * '
                           . 'FROM ' . $cache_dbtable . ' '
                           . 'WHERE `cache_hash` = "' . $hash . '" '
                           . 'ORDER BY `cache_order` ASC;';
                    $result = $this->query($query);
                    $items = $this->results();

                    // освобождаем память от запроса
                    $this->free_result($result);
                }

                // отпираем доступ к таблицам
                $query = 'UNLOCK TABLES;';
                $this->query($query);
            }
        }

        // закрываем трассировку этого метода
        $this->close_tracing_method();

        // возвращаем СДЕЛАНО / ОШИБКА
        return !$error;
    }



    // =======================================================================
    // Получить для элемента поля изображений записи имя файла миниатюры:
    //   $filename = имя файла элемента поля изображений
    // =======================================================================

    public function get_record_images_thumbnail ($filename) {
      $filename = trim($filename);

      // если имя файла не начинается с протокола
      if (!preg_match("'^[a-z]+://'i", $filename)) {
        if (substr($filename, -10) == "_large.jpg") {
          $filename = substr($filename, 0, -10) . "_small.jpg";
        } else {
          $info = pathinfo($filename);
          if (isset($info["extension"])) $filename = substr($filename, 0, -strlen($info["extension"])) . THUMBNAIL_FILENAME_MARKER . $info["extension"];
        }
      }

      // возвращаем имя файла миниатюры
      return $filename;
    }

    // =======================================================================
    // Обработать загруженное изображение, наложить водяной знак и создать миниатюру изображения:
    //   $filename = имя файла загруженного изображения
    //   [$images_width] = предельная ширина обработанного изображения
    //   [$images_height] = предельная высота обработанного изображения
    //   [$thumbnail_width] = предельная ширина обработанной миниатюры
    //   [$thumbnail_height] = предельная высота обработанной миниатюры
    //   [$images_exactly] = признак "подгонять ли размеры изображений, меньших предельных размеров"
    //   [$quality] = качество обработанного изображения (имеет смысл только для jpeg изображений)
    //   [$watermark] = имя файла изображения водяного знака
    //   [$watermark_location] = расположение водяного знака на обработанном изображении
    //   [$watermark_transparency] = видимость (непрозрачность) водяного знака
    // =======================================================================

    public function process_image ($filename,
                                   $images_width = SETTINGS_DEFAULT_IMAGES_WIDTH,
                                   $images_height = SETTINGS_DEFAULT_IMAGES_HEIGHT,
                                   $thumbnail_width = SETTINGS_DEFAULT_THUMBNAIL_WIDTH,
                                   $thumbnail_height = SETTINGS_DEFAULT_THUMBNAIL_HEIGHT,
                                   $images_exactly = TRUE,
                                   $quality = SETTINGS_DEFAULT_IMAGES_QUALITY,
                                   $watermark = "",
                                   $watermark_location = IMAGES_WATERMARK_LOCATION_RIGHTBOTTOM,
                                   $watermark_transparency = SETTINGS_DEFAULT_WATERMARK_TRANSPARENCY) {
      $filename = trim($filename);
      if (@file_exists($filename)) {
        if (function_exists("getimagesize") && function_exists("gd_info") && function_exists("imagedestroy")
        && function_exists("imagecreatefromjpeg") && function_exists("imagecreatefrompng") && function_exists("imagecreatefromgif")
        && function_exists("imagecreatetruecolor") && function_exists("imagecopyresampled") && function_exists("imagecopymerge")
        && function_exists("imagejpeg") && function_exists("imagepng") && function_exists("imagegif")) {
          $info = getimagesize($filename);
          if (($info[PROCESS_IMAGE_FIELD_TYPE] == IMAGETYPE_JPEG) || ($info[PROCESS_IMAGE_FIELD_TYPE] == IMAGETYPE_PNG) || ($info[PROCESS_IMAGE_FIELD_TYPE] == IMAGETYPE_GIF)) {
            $image = gd_info();
            if ((isset($image['JPG Support']) || isset($image['JPEG Support']))
            && isset($image['PNG Support'])
            && isset($image['GIF Read Support']) && isset($image['GIF Create Support'])) {
              switch ($info[PROCESS_IMAGE_FIELD_TYPE]) {
                case IMAGETYPE_PNG:
                  $image = imagecreatefrompng($filename);
                  break;
                case IMAGETYPE_GIF:
                  $image = imagecreatefromgif($filename);
                  break;
                case IMAGETYPE_JPEG:
                default:
                  $image = imagecreatefromjpeg($filename);
              }
              if ($image != FALSE) {
                $images_width = intval($images_width);
                $images_height = intval($images_height);
                if ($images_width < SETTINGS_MINIMAL_IMAGES_WIDTH) $images_width = SETTINGS_MINIMAL_IMAGES_WIDTH;
                if ($images_width > SETTINGS_MAXIMAL_IMAGES_WIDTH) $images_width = SETTINGS_MAXIMAL_IMAGES_WIDTH;
                if ($images_height < SETTINGS_MINIMAL_IMAGES_HEIGHT) $images_height = SETTINGS_MINIMAL_IMAGES_HEIGHT;
                if ($images_height > SETTINGS_MAXIMAL_IMAGES_HEIGHT) $images_height = SETTINGS_MAXIMAL_IMAGES_HEIGHT;
                $width = $info[PROCESS_IMAGE_FIELD_WIDTH];
                $height = $info[PROCESS_IMAGE_FIELD_HEIGHT];
                $pass = 2;
                while ($pass > 0) {
                  if (($width < $images_width) && ($height < $images_height) && $images_exactly) {
                    $height = intval($height * $images_width / $width);
                    $width = $images_width;
                  } else {
                    if ($width > $images_width) {
                      $height = intval($height * $images_width / $width);
                      $width = $images_width;
                    }
                  }
                  if ($height > $images_height) {
                    $width = intval($width * $images_height / $height);
                    $height = $images_height;
                  }
                  if ($width < 1) $width = 1;
                  if ($height < 1) $height = 1;
                  $result = TRUE;
                  if (($info[PROCESS_IMAGE_FIELD_WIDTH] != $width) || ($info[PROCESS_IMAGE_FIELD_HEIGHT] != $height)) {
                    $copy = imagecreatetruecolor($width, $height);
                    if ($result = imagecopyresampled($copy, $image, 0, 0, 0, 0, $width, $height, $info[PROCESS_IMAGE_FIELD_WIDTH], $info[PROCESS_IMAGE_FIELD_HEIGHT])) {
                      imagedestroy($image);
                      $image = $copy;
                      unset($copy);
                    }
                  }
                  if ($result) {
                    $watermark = trim($watermark);
                    if (($pass == 2) && ($watermark != "") && @file_exists($watermark)) {
                      $watermark_transparency = intval($watermark_transparency);
                      if ($watermark_transparency < SETTINGS_MINIMAL_WATERMARK_TRANSPARENCY) $watermark_transparency = SETTINGS_MINIMAL_WATERMARK_TRANSPARENCY;
                      if ($watermark_transparency > SETTINGS_MAXIMAL_WATERMARK_TRANSPARENCY) $watermark_transparency = SETTINGS_MAXIMAL_WATERMARK_TRANSPARENCY;
                      $size = getimagesize($watermark);
                      if (($size[PROCESS_IMAGE_FIELD_TYPE] == IMAGETYPE_JPEG) || ($size[PROCESS_IMAGE_FIELD_TYPE] == IMAGETYPE_PNG) || ($size[PROCESS_IMAGE_FIELD_TYPE] == IMAGETYPE_GIF)) {
                        switch ($size[PROCESS_IMAGE_FIELD_TYPE]) {
                          case IMAGETYPE_PNG:
                            $watermark = imagecreatefrompng($watermark);
                            break;
                          case IMAGETYPE_GIF:
                            $watermark = imagecreatefromgif($watermark);
                            break;
                          case IMAGETYPE_JPEG:
                          default:
                            $watermark = imagecreatefromjpeg($watermark);
                        }
                        if ($watermark != FALSE) {
                          switch ($watermark_location) {
                            case IMAGES_WATERMARK_LOCATION_LEFTTOP:
                              $watermark_x = 0;
                              $watermark_y = 0;
                              break;
                            case IMAGES_WATERMARK_LOCATION_CENTERTOP:
                              $watermark_x = intval(($width - $size[PROCESS_IMAGE_FIELD_WIDTH]) / 2);
                              $watermark_y = 0;
                              break;
                            case IMAGES_WATERMARK_LOCATION_RIGHTTOP:
                              $watermark_x = $width - $size[PROCESS_IMAGE_FIELD_WIDTH];
                              $watermark_y = 0;
                              break;
                            case IMAGES_WATERMARK_LOCATION_LEFTCENTER:
                              $watermark_x = 0;
                              $watermark_y = intval(($height - $size[PROCESS_IMAGE_FIELD_HEIGHT]) / 2);
                              break;
                            case IMAGES_WATERMARK_LOCATION_CENTER:
                              $watermark_x = intval(($width - $size[PROCESS_IMAGE_FIELD_WIDTH]) / 2);
                              $watermark_y = intval(($height - $size[PROCESS_IMAGE_FIELD_HEIGHT]) / 2);
                              break;
                            case IMAGES_WATERMARK_LOCATION_RIGHTCENTER:
                              $watermark_x = $width - $size[PROCESS_IMAGE_FIELD_WIDTH];
                              $watermark_y = intval(($height - $size[PROCESS_IMAGE_FIELD_HEIGHT]) / 2);
                              break;
                            case IMAGES_WATERMARK_LOCATION_LEFTBOTTOM:
                              $watermark_x = 0;
                              $watermark_y = $height - $size[PROCESS_IMAGE_FIELD_HEIGHT];
                              break;
                            case IMAGES_WATERMARK_LOCATION_CENTERBOTTOM:
                              $watermark_x = intval(($width - $size[PROCESS_IMAGE_FIELD_WIDTH]) / 2);
                              $watermark_y = $height - $size[PROCESS_IMAGE_FIELD_HEIGHT];
                              break;
                            case IMAGES_WATERMARK_LOCATION_RIGHTBOTTOM:
                            default:
                              $watermark_x = $width - $size[PROCESS_IMAGE_FIELD_WIDTH];
                              $watermark_y = $height - $size[PROCESS_IMAGE_FIELD_HEIGHT];
                          }
                          imagecopymerge($image, $watermark, $watermark_x, $watermark_y, 0, 0, $size[PROCESS_IMAGE_FIELD_WIDTH], $size[PROCESS_IMAGE_FIELD_HEIGHT], $watermark_transparency);
                          imagedestroy($watermark);
                        }
                      }
                    }
                    switch ($info[PROCESS_IMAGE_FIELD_TYPE]) {
                      case IMAGETYPE_PNG:
                        imagepng($image, $filename, 9, PNG_FILTER_NONE);
                        break;
                      case IMAGETYPE_GIF:
                        imagegif($image, $filename);
                        break;
                      case IMAGETYPE_JPEG:
                      default:
                        $quality = intval($quality);
                        if ($quality < SETTINGS_MINIMAL_IMAGES_QUALITY) $quality = SETTINGS_MINIMAL_IMAGES_QUALITY;
                        if ($quality > SETTINGS_MAXIMAL_IMAGES_QUALITY) $quality = SETTINGS_MAXIMAL_IMAGES_QUALITY;
                        imagejpeg($image, $filename, $quality);
                    }
                  }
                  $info[PROCESS_IMAGE_FIELD_WIDTH] = $width;
                  $info[PROCESS_IMAGE_FIELD_HEIGHT] = $height;
                  if ($pass == 2) {
                    $images_width = intval($thumbnail_width);
                    $images_height = intval($thumbnail_height);
                    if ($images_width < SETTINGS_MINIMAL_THUMBNAIL_WIDTH) $images_width = SETTINGS_MINIMAL_THUMBNAIL_WIDTH;
                    if ($images_width > SETTINGS_MAXIMAL_THUMBNAIL_WIDTH) $images_width = SETTINGS_MAXIMAL_THUMBNAIL_WIDTH;
                    if ($images_height < SETTINGS_MINIMAL_THUMBNAIL_HEIGHT) $images_height = SETTINGS_MINIMAL_THUMBNAIL_HEIGHT;
                    if ($images_height > SETTINGS_MAXIMAL_THUMBNAIL_HEIGHT) $images_height = SETTINGS_MAXIMAL_THUMBNAIL_HEIGHT;
                    $result = pathinfo($filename);
                    $filename = substr($filename, 0, -strlen($result["extension"])) . THUMBNAIL_FILENAME_MARKER . $result["extension"];
                    $watermark = "";
                  }
                  $pass--;
                }
                imagedestroy($image);
              }
            }
          }
        }
      }
    }

    // =======================================================================
    // Поправить значение скидки клиента:
    //   $discount = величина скидки
    // =======================================================================

    public function fix_discount ($discount) {
        $discount = isset($discount) ? $this->cms->number->floatValue($discount) : 0;
        if ($discount < 0) $discount = 0;
        if ($discount > 100) $discount = 100;
        return $discount;
    }

    // =======================================================================
    // Переключить базу данных на указанную кодировку:
    //   $charset = кодировка (по умолчанию будет равна UTF-8)
    // =======================================================================

    public function set_charset ($charset = 'utf8') {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB set_charset');

        $charset = trim($charset);
        if ($charset != '') {
            setlocale(LC_ALL, 'ru_RU.' . $charset);
            $this->query('SET NAMES ' . $charset);
        }

        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }

    // =======================================================================
    // Получить массив с информацией о полях указанной таблицы базы данных:
    //   $dbtable = название таблицы
    // =======================================================================

    public function get_dbtable_fields ($dbtable) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB get_dbtable_fields');

        // запрашиваем структуру таблицы
        $items = array();
        $query = 'SHOW COLUMNS FROM `' . $this->query_value($dbtable) . '`;';
        $result = $this->query($query);
        if (!empty($result)) {

            // перебираем колонки таблицы
            while ($row = $this->fetch_assoc($result)) {
                if (isset($row['Field']) && trim($row['Field']) != '') {
                    $items[trim($row['Field'])] = $row;
                }
            }

            // освобождаем память от запроса
            $this->free_result($result);
        }

        // закрываем трассировку этого метода
        $this->close_tracing_method();

        // возвращаем массив с информацией о полях
        return $items;
    }

    // =======================================================================
    // Проверить безошибочность поля по информации о полях таблицы базы данных:
    //   $columns = массив с информацией о полях таблицы
    //   $name = имя проверяемого поля
    //   [$type] = тип проверяемого поля
    //   выход = необходимая к выполнению команда (ADD, CHANGE или пустая строка)
    // =======================================================================

    public function check_field ( & $columns, $name, $type = '' ) {
        $name = trim($name);
        $name2 = strtolower($name);

        if (isset($columns[$name])) $test = & $columns[$name];
        elseif (isset($columns[$name2])) $test = & $columns[$name2];
        else return 'ADD';

        $type = strtolower(trim($type));
        return $type == '' || !isset($test['Type']) || strtolower(trim($test['Type'])) == $type ? '' : 'CHANGE `' . $name . '`';
    }

    // =======================================================================
    // Проверить первородную индексированность поля по информации о полях таблицы базы данных:
    //   $columns = массив с информацией о полях таблицы
    //   $name = имя проверяемого поля
    //   $exact_index = булевой признак "должен быть именно индексом (не PRIMARY, не UNIQUE)"
    //   выход = ИМЕЕТ ИНДЕКС / НЕ ИМЕЕТ ИНДЕКСА
    // =======================================================================

    public function check_key ( & $columns, $name, $exact_index = FALSE ) {
        $name = trim($name);
        $name2 = strtolower($name);

        if (isset($columns[$name])) $test = & $columns[$name];
        elseif (isset($columns[$name2])) $test = & $columns[$name2];
        else $test = null;

        if ($exact_index) {
            return !is_null($test) && isset($test['Key']) && $test['Key'] != '' && strtolower($test['Key']) != 'pri' && strtolower($test['Key']) != 'uni';
        } else {
            return !is_null($test) && isset($test['Key']) && $test['Key'] != '';
        }
    }

    // =======================================================================
    // Добавить в цепочку запросов команды индексации поля таблицы базы данных:
    //   $query = цепочка запросов
    //   $name = имя индексируемого поля
    //   $no_primary = булевой признак "необходимо удалить первичный ключ"
    // =======================================================================

    public function add_key ( & $query, $name, $no_primary = FALSE ) {
        if ($no_primary) $query[] = 'DROP PRIMARY KEY';
        $query[] = 'DROP INDEX (`' . $name . '`)';
        $query[] = 'ADD INDEX (`' . $name . '`)';
    }



    // =======================================================================
    // Взять из базы данных запись о категории, указанной в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->sync_id] = синхронизационный идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->parent] = идентификатор родительской записи
    //   [$params->name] = название категории
    //   [$params->single_name] = название в единственном числе
    //   [$params->configurator_name] = название в конфигураторе
    //   [$params->menu_id] = идентификатор меню
    //   [$params->user_id] = идентификатор пользователя
    //   [$params->section] = раздел магазина
    //   [$params->url] = адрес страницы записи
    //   [$params->url_special] = с особым url
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->highlighted] = признак "выделена" запись
    //   [$params->hidden] = признак "скрыта от чужих"
    //   [$params->informative] = признак "информативная страница"
    //   [$params->rss_disabled] = признак "не для rss"
    //   [$params->export_disabled] = признак "не для экспорта"
    //   [$params->domained] = признак "имеет субдомен"
    //   [$params->subdomain] = имя субдомена
    //   [$params->subdomain_enabled] = признак "субдомен разрешен"
    // =======================================================================

    public function get_category ( & $item, $params ) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB get_category');

        $item = null;
        $where = '';

        // фильтруем по основным запрошенным параметрам
        if (isset($params->id) && !empty($params->id)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.category_id = \'' . $this->query_value($params->id) . '\' ';
        if (isset($params->sync_id) && !empty($params->sync_id)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.sync_id = \'' . $this->query_value($params->sync_id) . '\' ';
        if (isset($params->name) && isset($params->single_name) && ($params->name == $params->single_name)) {
            $where .= 'AND (' . DATABASE_CATEGORIES_TABLENAME . '.name = \'' . $this->query_value($params->name) . '\' OR ' . DATABASE_CATEGORIES_TABLENAME . '.single_name = \'' . $this->query_value($params->name) . '\') ';
        } else {
            if (isset($params->name)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.name = \'' . $this->query_value($params->name) . '\' ';
            if (isset($params->single_name)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.single_name = \'' . $this->query_value($params->single_name) . '\' ';
        }
        if (isset($params->configurator_name)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.configurator_name = \'' . $this->query_value($params->configurator_name) . '\' ';
        if (isset($params->url)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.url = \'' . $this->query_value($params->url) . '\' ';

        // если были основные параметры, фильтруем и по неосновным
        if ($where != '') {
            if (isset($params->exclude_id)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.category_id != \'' . $this->query_value($params->exclude_id) . '\' ';
            if (isset($params->parent)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.parent = \'' . $this->query_value($params->parent) . '\' ';
            if (isset($params->menu_id)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.menu_id = \'' . $this->query_value($params->menu_id) . '\' ';
            if (isset($params->user_id)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.user_id = \'' . $this->query_value($params->user_id) . '\' ';
            if (isset($params->section)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.section = \'' . $this->query_value($params->section) . '\' ';
            if (isset($params->enabled)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.enabled = \'' . $this->query_value($params->enabled) . '\' ';
            if (isset($params->highlighted)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.highlighted = \'' . $this->query_value($params->highlighted) . '\' ';
            if (isset($params->hidden)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.hidden = \'' . $this->query_value($params->hidden) . '\' ';
            if (isset($params->informative)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.informative = \'' . $this->query_value($params->informative) . '\' ';
            if (isset($params->rss_disabled)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.rss_disabled = \'' . $this->query_value($params->rss_disabled) . '\' ';
            if (isset($params->export_disabled)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.export_disabled = \'' . $this->query_value($params->export_disabled) . '\' ';
            if (isset($params->subdomain)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.subdomain = \'' . $this->query_value($params->subdomain) . '\' ';
            if (isset($params->subdomain_enabled)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.sudbomain_enabled = \'' . $this->query_value($params->subdomain_enabled) . '\' ';
            if (isset($params->domained)) $where .= 'AND TRIM(' . DATABASE_CATEGORIES_TABLENAME . '.subdomain) != \'\' AND ' . DATABASE_CATEGORIES_TABLENAME . '.subdomain_enabled = 1 ';
            if (isset($params->url_special)) $where .= 'AND ' . DATABASE_CATEGORIES_TABLENAME . '.url_special = \'' . $this->query_value($params->url_special) . '\' ';
            $where = 'WHERE 1 ' . $where;

            // кешируем усеченную в размерах таблицу пользователей (Users ShortVersion)
            $this->users->cachingShortVersion();

            // кешируем усеченную в размерах таблицу меню (Menus ShortVersion)
            $this->caching_menus_sv();

            // кешируем усеченную в размерах таблицу товаров (CategoriesBrands Products ShortVersion)
            $this->products->caching_CatsBrandsProducts_short($params);

            // делаем запрос
            $query = 'SELECT ' . DATABASE_CATEGORIES_TABLENAME . '.*, '
                               . DATABASE_CACHE_USERS_SHORTVERSION_TABLENAME . '.name AS user_name, '
                               . DATABASE_CACHE_MENUS_SHORTVERSION_TABLENAME . '.name AS menu, '
                               . 'COUNT(DISTINCT ' . DATABASE_CACHE_CBPRODUCTS_SHORTVERSION_TABLENAME . '.product_id) AS my_products_count '
                   . 'FROM ' . DATABASE_CATEGORIES_TABLENAME . ' '
                   . 'LEFT JOIN ' . DATABASE_CACHE_USERS_SHORTVERSION_TABLENAME . ' '
                             . 'ON ' . DATABASE_CACHE_USERS_SHORTVERSION_TABLENAME . '.user_id = ' . DATABASE_CATEGORIES_TABLENAME . '.user_id '
                   . 'LEFT JOIN ' . DATABASE_CACHE_MENUS_SHORTVERSION_TABLENAME . ' '
                             . 'ON ' . DATABASE_CACHE_MENUS_SHORTVERSION_TABLENAME . '.menu_id = ' . DATABASE_CATEGORIES_TABLENAME . '.menu_id '
                   . 'LEFT JOIN products_categories '
                             . 'ON products_categories.category_id = ' . DATABASE_CATEGORIES_TABLENAME . '.category_id '
                   . 'LEFT JOIN ' . DATABASE_CACHE_CBPRODUCTS_SHORTVERSION_TABLENAME . ' '
                             . 'ON ' . DATABASE_CACHE_CBPRODUCTS_SHORTVERSION_TABLENAME . '.category_id = ' . DATABASE_CATEGORIES_TABLENAME . '.category_id '
                                    . 'OR ' . DATABASE_CACHE_CBPRODUCTS_SHORTVERSION_TABLENAME . '.product_id = products_categories.product_id '
                   . $where
                   . 'GROUP BY ' . DATABASE_CATEGORIES_TABLENAME . '.category_id '
                   . 'LIMIT 1;';
            $result = $this->query($query);
            $item = $this->result();

            // освобождаем память от запроса
            $this->free_result($result);

            // поправляем поля записи
            if (!empty($item)) $this->fix_categories_record($item);
        }

        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }



    // =======================================================================
    // Получить массив идентификаторов категорий из записей о них:
    //   $items = массив записей
    //   $ids = результат будет помещен в эту переменную
    // =======================================================================

    public function get_categories_ids ( & $items, & $ids = null ) {

        if (!is_array($ids)) $ids = array();
        if (!empty($items)) {
            foreach ($items as & $item) {
                $id = intval($item->category_id);
                $ids[$id] = $id;
                if (!empty($item->subcategories)) $this->get_categories_ids($item->subcategories, $ids);
            }
        }
    }



    // =======================================================================
    // Заполнить записи о категориях записями о товарах:
    //   $items = массив записей
    //   $items_list = плоский массив записей о категориях
    //   [$products_list] = результат в виде плоского списка товаров будет помещен в эту переменную
    //   [$params->...] = параметры выбора товаров, аналогичные методу get_products()
    // =======================================================================

    public function productize_categories ( & $items, & $items_list, $params = null, & $products_list = null ) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB productize_categories');



        // получаем в $ids фильтр идентификаторов категорий
        if (!is_array($products_list)) {
            $this->get_categories_ids($items, $ids);
            $ids = implode(',', $ids);

            // удаляем из параметров ненужные здесь
            if (isset($params->category)) unset($params->category);
            if (isset($params->category_id)) unset($params->category_id);
            if (isset($params->category_ids)) unset($params->category_ids);
            if (isset($params->start)) unset($params->start);
            if (isset($params->maxcount)) unset($params->maxcount);
            if (isset($params->randomcount)) unset($params->randomcount);



            // читаем список товаров
            $params->category_ids = $ids;
            $this->products->get($products_list, $params);



            // если это подготовка для прайс-листов, конфигуратора или редактора заказов, заполнить записи вариантами товара
            if (isset($params->completeness)
            && (($params->completeness == GET_PRODUCTS_COMPLETENESS_FOR_PRICES)
            || ($params->completeness == GET_PRODUCTS_COMPLETENESS_FOR_CONFIGURATOR)
            || ($params->completeness == GET_PRODUCTS_COMPLETENESS_FOR_EDITORDER))) {
                $discount = isset($params->discount) ? $this->fix_discount($params->discount) : 0;
                $price_id = isset($params->price_id) ? intval($params->price_id) : 0;
                $this->products->fill_variants($products_list, $price_id, $discount);
            }
        }



        // если получен список товаров, вставляем его элементы в соответствующие записи категорий
        if (!empty($items_list) && !empty($products_list)) {
            foreach ($products_list as & $item) {
                $cid = intval($item->category_id);
                if (isset($items_list[$cid])) {
                    $pid = intval($item->product_id);
                    if (!isset($items_list[$cid]->products)) $items_list[$cid]->products = array();
                    $items_list[$cid]->products[$pid] = & $item;
                }
            }
        }



        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }



    // =======================================================================
    // Освободить записи о категориях от записей о товарах:
    //   $items_list = плоский массив записей о категориях
    // =======================================================================

    public function unproductize_categories ( & $items_list ) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB unproductize_categories');



        // если список категорий не пустой, удаляем из записей элементы списка товаров
        if (!empty($items_list)) {
            foreach ($items_list as & $item) {
                if (isset($item->products)) unset($item->products);
            }
        }



        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }



    // =======================================================================
    // Очистка кеш-таблицы категорий и зависимых кешей:
    //   [$item] = обрабатывавшаяся запись (содержащая меняемые поля)
    // =======================================================================

    public function reset_categories_caches ( & $item = null ) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB reset_categories_caches');



        // если просят очистить безусловно или изменения в самом деле критичны
        if (is_null($item) || !isset($item->indifferent_caches) || !$item->indifferent_caches) {

            // очищаем нужные кеш-таблицы
            $tables = DATABASE_CACHE_CATEGORIES_TABLENAME;
            $this->reset_dbtables($tables);
        }



        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }



    // =======================================================================
    // Добавить в записи о категориях оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_categories ( & $items, $params ) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB operable_categories');



        if (!empty($items) && isset($params->token)) {
            foreach ($items as & $item) {
                if (isset($item->category_id)) {

                    // собираем параметры
                    $options = array(REQUEST_PARAM_NAME_SECTION => 'Categories',
                                     REQUEST_PARAM_NAME_ITEMID => $item->category_id,
                                     REQUEST_PARAM_NAME_TOKEN => $params->token);
                    if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;

                    // создаем ссылку "поднять выше"
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEUP;
                    $item->move_up_get = $this->parent->form_get($options);

                    // создаем ссылку "опустить ниже"
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEDOWN;
                    $item->move_down_get = $this->parent->form_get($options);

                    // создаем ссылку "поставить первым"
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEFIRST;
                    $item->move_first_get = $this->parent->form_get($options);

                    // создаем ссылку "поставить последним"
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVELAST;
                    $item->move_last_get = $this->parent->form_get($options);

                    // создаем ссылку "удалить"
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
                    $item->delete_get = $this->parent->form_get($options);

                    // создаем ссылку "разрешена"
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
                    $item->enable_get = $this->parent->form_get($options);

                    // создаем ссылку "выделена"
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_HIGHLIGHTED;
                    $item->highlight_get = $this->parent->form_get($options);

                    // создаем ссылку "скрыта от чужих"
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_HIDDEN;
                    $item->hidden_get = $this->parent->form_get($options);

                    // создаем ссылку "считать ли информативной"
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_INFORMATIVE;
                    $item->informative_get = $this->parent->form_get($options);

                    // создаем ссылку "имеет ли субдомен"
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DOMAINED;
                    $item->domained_get = $this->parent->form_get($options);

                    // создаем ссылку "экспорт в Яндекс.Маркет"
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_YMARKET;
                    $item->ymarket_get = $this->parent->form_get($options);

                    // создаем ссылку "редактировать"
                    unset($options[REQUEST_PARAM_NAME_ACTION]);
                    $options[REQUEST_PARAM_NAME_SECTION] = 'Category';
                    $item->edit_get = $this->parent->form_get($options);



                    // если есть вложенные элементы
                    if (!empty($item->subcategories)) $this->operable_categories($item->subcategories, $params);
                }
            }
        }



        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }



    // =======================================================================
    // Поправить поля записей о категориях:
    //   $items = массив записей
    // =======================================================================

    public function fix_categories_records ( & $items ) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB fix_categories_records');



        if (!empty($items)) {
            foreach ($items as & $item) {
                $this->fix_categories_record($item);
                if (!empty($item->subcategories)) $this->fix_categories_records($item->subcategories);
            }
        }



        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }



    // =======================================================================
    // Поправить поля записи о категории:
    //   $item = запись
    // =======================================================================

    public function fix_categories_record ( & $item ) {

        // поправляем строковые поля
        if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);
        if (isset($item->single_name)) $this->fix_textfield_as_product_name($item->single_name);
        if (isset($item->configurator_name)) $this->fix_textfield_as_product_name($item->configurator_name);



        // поправляем адресующие поля
        $category_id = null;
        if (isset($item->category_id)) {
            $item->category_id = intval($item->category_id);
            if (isset($item->url) && ($item->url == '')) $item->url = $item->category_id;
            $item->url_path = isset($item->url_special) && $item->url_special ? '' : 'catalog/';
            $category_id = $item->category_id;
        }



        // поправляем поля родительских категорий
        $parent = '';
        if (isset($item->parent)) {
            $item->parent = intval($item->parent);
            $parent = $item->parent;
        }
        if (isset($item->parents)) {
            if ($category_id === $parent) {
                $parent = 0;
                $item->parent = $parent;
            }
            $parents = array();
            if ($parent !== '') $parents[$parent] = $parent;
            $item->parents = explode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->parents);
            foreach ($item->parents as $parent) {
                if (trim($parent) != '') {
                    $parent = intval($parent);
                    if ($category_id !== $parent) $parents[$parent] = $parent;
                }
            }
            $item->parents = $parents;
        }



        // поправляем поле имени администрирующего пользователя
        if (isset($item->user_name) && ($item->user_name != '')) {
            $user = new stdClass;
            $user->name = $item->user_name;
            $this->cms->db->users->unpackUserName($user);
            $item->user_name = $user->compound_name;
        }



        // поправляем поля изображений
        $this->fix_categories_record_images($item);
    }



    // =======================================================================
    // Превратить строки полей изображений записи о категории в массивы:
    //   $item = запись (при отсутствии полей images, images_alts, images_texts, images_view они станут пустыми массивами)
    // =======================================================================

    public function fix_categories_record_images ( & $item ) {

        $this->fix_articles_record_images($item);
    }



    // =======================================================================
    // Превратить массивы, находящиеся в полях изображений записи о категории,
    // в строки, готовые для передачи в базу данных:
    //   $item = запись (при отсутствии полей images, images_alts, images_texts, images_view они появятся пустыми)
    // =======================================================================

    public function unfix_categories_record_images ( & $item ) {

        $this->unfix_articles_record_images($item);
    }



    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу категорий в базе данных.
    // =======================================================================

    private function check_database_categories () {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB check_database_categories');



        // проверяем наличие таблицы, при отсутствии создаем
        $dbtable = DATABASE_CATEGORIES_TABLENAME;
        $dbtable_field = 'category_id';
        $columns = $this->get_dbtable_fields($dbtable);
        if (empty($columns)) $this->query('CREATE TABLE IF NOT EXISTS ' . $dbtable . ' (' . $dbtable_field . ' BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;');



        // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
        $query = array();
        $subquery = array();
        if (!isset($columns[$dbtable_field])) {
            $query[] = 'ADD ' . $dbtable_field . ' BIGINT(20) NOT NULL';
            $query[] = 'DROP PRIMARY KEY';
            $query[] = '>SET @a := 0';
            $query[] = '>UPDATE ' . $dbtable . ' SET ' . $dbtable_field . ' = @a := @a + 1';
            $query[] = 'ADD PRIMARY KEY (' . $dbtable_field . ')';
            $query[] = 'CHANGE ' . $dbtable_field . ' ' . $dbtable_field . ' BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT \'Идентификатор категории\'';
        } else {

            // категория
            $name = $dbtable_field;
            $type = 'BIGINT(20)';
            if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' NOT NULL AUTO_INCREMENT COMMENT \'Идентификатор категории\'';
        }



        // синхронизационный ИД
        $name = 'sync_id';
        $type = 'VARCHAR(40)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Синхронизационный идентификатор\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // родитель
        $name = 'parent';
        $type = 'BIGINT(20)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'0\' NOT NULL COMMENT \'Идентификатор родительской категории\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // дополнительные родители
        $name = 'parents';
        $type = 'TEXT';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Идентификаторы дополнительных родительских категорий\'';

        // меню
        $name = 'menu_id';
        $type = 'BIGINT(20)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'0\' NOT NULL COMMENT \'Идентификатор меню\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // подключаемые модули
        $name = 'objects';
        $type = 'VARCHAR(512)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Перечень модулей, подключаемых на страницу категории\'';

        // администрирующий
        $name = 'user_id';
        $type = 'BIGINT(' . DATABASE_USERS_FIELDSIZE_ID . ')';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'0\' NOT NULL COMMENT \'Идентификатор администрирующего пользователя\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // Яндекс.Маркет
        $name = 'ymarket';
        $type = 'INT(11)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'1\' NOT NULL COMMENT \'Признак Экспорт в Яндекс.Маркет\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // ВКонтакте
        $name = 'vkontakte';
        $type = 'TINYINT(1)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'1\' NOT NULL COMMENT \'Признак Экспорт в ВКонтакте\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // разрешена
        $name = 'enabled';
        $type = 'TINYINT(1)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'1\' NOT NULL COMMENT \'Разрешена ли запись к использованию\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // выделена
        $name = 'highlighted';
        $type = 'TINYINT(1)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'0\' NOT NULL COMMENT \'Выделена ли запись визуально\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // свой блок
        $name = 'own_block';
        $type = 'TINYINT(1)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'0\' NOT NULL COMMENT \'Имеет ли категория свой блок на основной странице каталога\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // информативная
        $name = 'informative';
        $type = 'TINYINT(1)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'0\' NOT NULL COMMENT \'Признак Информационная страница (без списка товаров)\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // скрыта от чужих
        $name = 'hidden';
        $type = 'TINYINT(1)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'0\' NOT NULL COMMENT \'Признак Скрыта от незарегистрированных пользователей\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // не для rss
        $name = 'rss_disabled';
        $type = 'TINYINT(1)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'0\' NOT NULL COMMENT \'Признак Не публиковать в RSS\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // не для информеров
        $name = 'export_disabled';
        $type = 'TINYINT(1)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'0\' NOT NULL COMMENT \'Признак Не публиковать во внешних информерах\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // url
        $name = 'url';
        $type = 'VARCHAR(256)';
        if (($command = $this->check_field($columns, $name, $type)) != '') {
            $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Окончание URL страницы\'';
            $subquery[] = 'UPDATE ' . $dbtable . ' '
                        . 'SET ' . $name . ' = ' . $dbtable_field . ' '
                        . 'WHERE TRIM(' . $name . ') = \'\' OR ' . $name . ' IS NULL;';
        }
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // особый url
        $name = 'url_special';
        $type = 'TINYINT(1)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'0\' NOT NULL COMMENT \'Признак Имеет особый URL\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // мета заголовок
        $name = 'meta_title';
        $type = 'VARCHAR(256)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Мета заголовок страницы\'';

        // мета ключевые слова
        $name = 'meta_keywords';
        $type = 'VARCHAR(512)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Мета ключевые слова страницы\'';

        // мета описание
        $name = 'meta_description';
        $type = 'VARCHAR(512)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Мета описание страницы\'';

        // название
        $name = 'name';
        $type = 'VARCHAR(256)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Название категории\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // название в единственном числе
        $name = 'single_name';
        $type = 'VARCHAR(256)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Название в единственном числе\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // название в конфигураторе
        $name = 'configurator_name';
        $type = 'VARCHAR(256)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Название категории в конфигураторе\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // вступительный текст
        $name = 'description';
        $type = 'TEXT';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Вступительный текст страницы\'';

        // seo текст
        $name = 'seo_description';
        $type = 'TEXT';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'SEO текст страницы\'';

        // в каких прайсах видна
        $name = 'in_prices';
        $type = 'TINYINT(1) UNSIGNED';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'255\' NOT NULL COMMENT \'Битовый признаки В какие из 8 прайсов выводится категория\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // имя субдомена
        $name = 'subdomain';
        $type = 'VARCHAR(256)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Левая часть имени собственного субдомена\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // разрешение субдомена
        $name = 'subdomain_enabled';
        $type = 'TINYINT(1)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'1\' NOT NULL COMMENT \'Признак Имеет собственный субдомен\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // приоритетный контент субдомена
        $name = 'subdomain_html';
        $type = 'TEXT';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Приоритетный контент страницы собственного субдомена\'';

        // имя шаблона
        $name = 'template';
        $type = 'VARCHAR(256)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Шаблон, используемый для отображения страницы\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // основное фото
        $name = 'image';
        $type = 'VARCHAR(256)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Основное фото категории\'';

        // все фото
        $name = 'images';
        $type = 'TEXT';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Перечень всех фото категории\'';

        // надписи фото
        $name = 'images_alts';
        $type = 'TEXT';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Перечень надписей всех фото категории\'';

        // описания фото
        $name = 'images_texts';
        $type = 'LONGTEXT';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Перечень описаний всех фото категории\'';

        // слайдинг-признаки
        $name = 'images_view';
        $type = 'TEXT';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Перечень слайдинг-признаков всех фото категории\'';

        // теги
        $name = 'tags';
        $type = 'VARCHAR(256)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Теги записи\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // счетчик просмотров
        $name = 'browsed';
        $type = 'INT(11) UNSIGNED';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'0\' NOT NULL COMMENT \'Количество просмотров страницы\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // вес в ветке
        $name = 'order_num';
        $type = 'INT(11)';
        if (($command = $this->check_field($columns, $name, $type)) != '') {
            $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'0\' NOT NULL COMMENT \'Вес записи среди прочих в ветке\'';
            $subquery[] = 'UPDATE ' . $dbtable . ' '
                        . 'SET ' . $name . ' = ' . $dbtable_field . ' '
                        . 'WHERE ' . $name . ' = 0 OR ' . $name . ' IS NULL;';
        }
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // раздел магазина
        $name = 'section';
        $type = 'INT(11)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'1\' NOT NULL COMMENT \'Идентификатор раздела магазина\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);



        // выполняем сформированные запросы
        foreach ($query as & $command) {
            if (trim($command) != '') {
                if (substr($command, 0, 1) == '>') {
                    $command = trim(substr($command, 1));
                    if ($command != '') $command .= ';';
                } else {
                    $command = 'ALTER TABLE ' . $dbtable . ' ' . $command . ';';
                }
                if ($command != '') $this->query($command);
            }
        }

        foreach ($subquery as & $command) {
            if (trim($command) != '') $this->query($command);
        }



        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }


    // =======================================================================
    // Взять из базы данных запись о бренде, указанной в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->sync_id] = синхронизационный идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->parent] = идентификатор родительской записи
    //   [$params->name] = название бренда
    //   [$params->menu_id] = идентификатор меню
    //   [$params->user_id] = идентификатор пользователя
    //   [$params->section] = раздел магазина
    //   [$params->url] = адрес страницы записи
    //   [$params->url_special] = с особым url
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->highlighted] = признак "выделена" запись
    //   [$params->hidden] = признак "скрыта от чужих"
    //   [$params->informative] = признак "информативная страница"
    //   [$params->rss_disabled] = признак "не для rss"
    //   [$params->export_disabled] = признак "не для экспорта"
    //   [$params->domained] = признак "имеет субдомен"
    //   [$params->subdomain] = имя субдомена
    //   [$params->subdomain_enabled] = признак "субдомен разрешен"
    // =======================================================================

    public function get_brand (&$item, $params) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB get_brand');



        $item = null;
        $where = '';



        // фильтруем по запрошенным параметрам
        if (isset($params->id) && !empty($params->id)) $where .= 'AND ' . DATABASE_BRANDS_TABLENAME . '.brand_id = \'' . $this->query_value($params->id) . '\' ';
        if (isset($params->sync_id) && !empty($params->sync_id)) $where .= 'AND ' . DATABASE_BRANDS_TABLENAME . '.sync_id = \'' . $this->query_value($params->sync_id) . '\' ';
      if (isset($params->name)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".name = '" . $this->query_value($params->name) . "' ";
      if (isset($params->url)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".url = '" . $this->query_value($params->url) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".brand_id != '" . $this->query_value($params->exclude_id) . "' ";
        if (isset($params->parent)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".parent = '" . $this->query_value($params->parent) . "' ";
        if (isset($params->menu_id)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".menu_id = '" . $this->query_value($params->menu_id) . "' ";
        if (isset($params->user_id)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".user_id = '" . $this->query_value($params->user_id) . "' ";
        if (isset($params->section)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".section = '" . $this->query_value($params->section) . "' ";
        if (isset($params->enabled)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".enabled = '" . $this->query_value($params->enabled) . "' ";
        if (isset($params->highlighted)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".highlighted = '" . $this->query_value($params->highlighted) . "' ";
        if (isset($params->hidden)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".hidden = '" . $this->query_value($params->hidden) . "' ";
        if (isset($params->informative)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".informative = '" . $this->query_value($params->informative) . "' ";
        if (isset($params->rss_disabled)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".rss_disabled = '" . $this->query_value($params->rss_disabled) . "' ";
        if (isset($params->export_disabled)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".export_disabled = '" . $this->query_value($params->export_disabled) . "' ";
        if (isset($params->subdomain)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".subdomain = '" . $this->query_value($params->subdomain) . "' ";
        if (isset($params->subdomain_enabled)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".subdomain_enabled = '" . $this->query_value($params->subdomain_enabled) . "' ";
        if (isset($params->domained)) $where .= "AND TRIM(" . DATABASE_BRANDS_TABLENAME . ".subdomain) != '' AND " . DATABASE_BRANDS_TABLENAME . ".subdomain_enabled = 1 ";
        if (isset($params->url_special)) $where .= "AND " . DATABASE_BRANDS_TABLENAME . ".url_special = '" . $this->query_value($params->url_special) . "' ";
        $where = "WHERE 1 " . $where;

        // кешируем усеченную в размерах таблицу пользователей (Users ShortVersion)
        $this->users->cachingShortVersion();

        // кешируем усеченную в размерах таблицу меню (Menus ShortVersion)
        $this->caching_menus_sv();

        // кешируем усеченную в размерах таблицу товаров (CategoriesBrands Products ShortVersion)
        $this->products->caching_CatsBrandsProducts_short($params);

        // делаем запрос
        $query = "SELECT " . DATABASE_BRANDS_TABLENAME . ".*, "
                      . DATABASE_CACHE_USERS_SHORTVERSION_TABLENAME . ".name AS user_name, "
                      . DATABASE_CACHE_MENUS_SHORTVERSION_TABLENAME . ".name AS menu, "
                      . "COUNT(DISTINCT " . DATABASE_CACHE_CBPRODUCTS_SHORTVERSION_TABLENAME . ".product_id) AS my_products_count "
               . "FROM " . DATABASE_BRANDS_TABLENAME . " "
               . "LEFT JOIN " . DATABASE_CACHE_USERS_SHORTVERSION_TABLENAME . " "
                         . "ON " . DATABASE_CACHE_USERS_SHORTVERSION_TABLENAME . ".user_id = " . DATABASE_BRANDS_TABLENAME . ".user_id "
               . "LEFT JOIN " . DATABASE_CACHE_MENUS_SHORTVERSION_TABLENAME . " "
                         . "ON " . DATABASE_CACHE_MENUS_SHORTVERSION_TABLENAME . ".menu_id = " . DATABASE_BRANDS_TABLENAME . ".menu_id "
               . "LEFT JOIN " . DATABASE_CACHE_CBPRODUCTS_SHORTVERSION_TABLENAME . " "
                         . "ON " . DATABASE_CACHE_CBPRODUCTS_SHORTVERSION_TABLENAME . ".brand_id = " . DATABASE_BRANDS_TABLENAME . ".brand_id "
               . $where
               . "GROUP BY " . DATABASE_BRANDS_TABLENAME . ".brand_id "
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_brands_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Очистка кеш-таблицы брендов и зависимых кешей:
    //   [$item] = обрабатывавшаяся запись (содержащая меняемые поля)
    // =======================================================================

    public function reset_brands_caches (&$item = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB reset_brands_caches");

      // если просят очистить безусловно или изменения в самом деле критичны
      if (is_null($item) || !isset($item->indifferent_caches) || !$item->indifferent_caches) {

        // очищаем нужные кеш-таблицы
        $tables = DATABASE_CACHE_BRANDS_TABLENAME;
        $this->reset_dbtables($tables);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Добавить в записи о брендах оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_brands (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_brands");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->brand_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "Brands",
                             REQUEST_PARAM_NAME_ITEMID => $item->brand_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "поднять выше"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEUP;
            $item->move_up_get = $this->parent->form_get($options);
            // создаем ссылку "опустить ниже"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEDOWN;
            $item->move_down_get = $this->parent->form_get($options);
            // создаем ссылку "поставить первым"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEFIRST;
            $item->move_first_get = $this->parent->form_get($options);
            // создаем ссылку "поставить последним"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVELAST;
            $item->move_last_get = $this->parent->form_get($options);
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "выделена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_HIGHLIGHTED;
            $item->highlight_get = $this->parent->form_get($options);
            // создаем ссылку "скрыта от чужих"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_HIDDEN;
            $item->hidden_get = $this->parent->form_get($options);
            // создаем ссылку "считать ли информативной"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_INFORMATIVE;
            $item->informative_get = $this->parent->form_get($options);
            // создаем ссылку "имеет ли субдомен"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DOMAINED;
            $item->domained_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "Brand";
            $item->edit_get = $this->parent->form_get($options);
            if (!empty($item->subbrands)) $this->operable_brands($item->subbrands, $params);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }


    // =======================================================================
    // Поправить поля записей о брендах:
    //   $items = массив записей
    // =======================================================================

    public function fix_brands_records (&$items) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB fix_brands_records");

      if (!empty($items)) {
        foreach ($items as &$item) {
          $this->fix_brands_record($item);
          if (!empty($item->subbrands)) $this->fix_brands_records($item->subbrands);
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Поправить поля записи о бренде:
    //   $item = запись
    // =======================================================================

    public function fix_brands_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);

      // поправляем адресующие поля
      $brand_id = null;
      if (isset($item->brand_id)) {
        $item->brand_id = intval($item->brand_id);
        if (isset($item->url) && empty($item->url)) $item->url = $item->brand_id;
        $item->url_path = (isset($item->url_special) && ($item->url_special == 1)) ? "" : "brands/";
        $brand_id = $item->brand_id;
      }

      // попрравляем поля родительских брендов
      $parent = "";
      if (isset($item->parent)) {
        $item->parent = intval($item->parent);
        $parent = $item->parent;
      }
      if (isset($item->parents)) {
        if ($brand_id === $parent) {
          $parent = 0;
          $item->parent = $parent;
        }
        $parents = array();
        if ($parent !== "") $parents[$parent] = $parent;
        $item->parents = explode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->parents);
        foreach ($item->parents as $parent) {
          if (trim($parent) != "") {
            $parent = intval($parent);
            if ($brand_id !== $parent) $parents[$parent] = $parent;
          }
        }
        $item->parents = $parents;
      }

      // поправляем поле имени администрирующего пользователя
      if (isset($item->user_name) && !empty($item->user_name)) {
        $user = new stdClass;
        $user->name = $item->user_name;
        $this->cms->db->users->unpackUserName($user);
        $item->user_name = $user->compound_name;
      }

      // поправляем поля изображений
      $this->fix_brands_record_images($item);
    }

    // =======================================================================
    // Превратить строки полей изображений записи о бренде в массивы:
    //   $item = запись (при отсутствии полей images, images_alts, images_texts, images_view они станут пустыми массивами)
    // =======================================================================

    public function fix_brands_record_images (&$item) {
      $this->fix_categories_record_images($item);
    }

    // =======================================================================
    // Превратить массивы, находящиеся в полях изображений записи о бренде,
    // в строки, готовые для передачи в базу данных:
    //   $item = запись (при отсутствии полей images, images_alts, images_texts, images_view они появятся пустыми)
    // =======================================================================

    public function unfix_brands_record_images (&$item) {
      $this->unfix_categories_record_images($item);
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу брендов в базе данных.
    // =======================================================================

    private function check_database_brands () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_brands");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = DATABASE_BRANDS_TABLENAME;
      $dbtable_field = "brand_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(20) NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор бренда'";
      } else {

        // бренд
        $name = $dbtable_field;
        $type = "BIGINT(20)";
        if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор бренда'";
      }



        // синхронизационный ИД
        $name = 'sync_id';
        $type = 'VARCHAR(40)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' ' . $name . ' ' . $type . ' DEFAULT \'\' NOT NULL COMMENT \'Синхронизационный идентификатор\'';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // родитель
      $name = "parent";
      $type = "BIGINT(20)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Идентификатор родительского бренда'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // дополнительные родители
      $name = "parents";
      $type = "TEXT";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Идентификаторы дополнительных родительских брендов'";

      // меню
      $name = "menu_id";
      $type = "BIGINT(20)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Идентификатор меню'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // подключаемые модули
      $name = "objects";
      $type = "VARCHAR(512)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Перечень модулей, подключаемых на страницу бренда'";

      // администрирующий
      $name = "user_id";
      $type = "BIGINT(" . DATABASE_USERS_FIELDSIZE_ID . ")";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Идентификатор администрирующего пользователя'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // разрешен
      $name = "enabled";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '1' NOT NULL COMMENT 'Разрешена ли запись к использованию'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // выделен
      $name = "highlighted";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Выделена ли запись визуально'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // информативная
      $name = "informative";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Признак Информационная страница (без списка товаров)'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // скрыт от чужих
      $name = "hidden";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Признак Скрыт от незарегистрированных пользователей'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // не для rss
      $name = "rss_disabled";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Признак Не публиковать в RSS'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // не для информеров
      $name = "export_disabled";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Признак Не публиковать во внешних информерах'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // url
      $name = "url";
      $type = "VARCHAR(256)";
      if (($command = $this->check_field($columns, $name, $type)) != "") {
        $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Окончание URL страницы'";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET " . $name . " = " . $dbtable_field . " "
                    . "WHERE TRIM(" . $name . ") = '' OR " . $name . " IS NULL;";
      }
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // особый url
      $name = "url_special";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Признак Имеет особый URL'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // мета заголовок
      $name = "meta_title";
      $type = "VARCHAR(256)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Мета заголовок страницы'";

      // мета ключевые слова
      $name = "meta_keywords";
      $type = "VARCHAR(512)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Мета ключевые слова страницы'";

      // мета описание
      $name = "meta_description";
      $type = "VARCHAR(512)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Мета описание страницы'";

      // название
      $name = "name";
      $type = "VARCHAR(256)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Название бренда'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // вступительный текст
      $name = "description";
      $type = "TEXT";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Вступительный текст страницы'";

      // seo текст
      $name = "seo_description";
      $type = "TEXT";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'SEO текст страницы'";

      // имя субдомена
      $name = "subdomain";
      $type = "VARCHAR(256)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Левая часть имени собственного субдомена'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // разрешение субдомена
      $name = "subdomain_enabled";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '1' NOT NULL COMMENT 'Признак Имеет собственный субдомен'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // приоритетный контент субдомена
      $name = "subdomain_html";
      $type = "TEXT";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Приоритетный контент страницы собственного субдомена'";

      // имя шаблона
      $name = "template";
      $type = "VARCHAR(256)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Шаблон, используемый для отображения страницы'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // основное фото
      $name = "image";
      $type = "VARCHAR(256)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Основное фото бренда'";

      // все фото
      $name = "images";
      $type = "TEXT";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Перечень всех фото бренда'";

      // надписи фото
      $name = "images_alts";
      $type = "TEXT";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Перечень надписей всех фото бренда'";

      // описания фото
      $name = "images_texts";
      $type = "LONGTEXT";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Перечень описаний всех фото бренда'";

      // слайдинг-признаки
      $name = "images_view";
      $type = "TEXT";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Перечень слайдинг-признаков всех фото бренда'";

      // теги
      $name = "tags";
      $type = "VARCHAR(256)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Теги записи'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // счетчик просмотров
      $name = "browsed";
      $type = "INT(11) UNSIGNED";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Количество просмотров страницы'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // вес в ветке
      $name = "order_num";
      $type = "INT(11)";
      if (($command = $this->check_field($columns, $name, $type)) != "") {
        $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Вес записи среди прочих в ветке'";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET " . $name . " = " . $dbtable_field . " "
                    . "WHERE " . $name . " = 0 OR " . $name . " IS NULL;";
      }
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // раздел магазина
      $name = "section";
      $type = "INT(11)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '1' NOT NULL COMMENT 'Идентификатор раздела магазина'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }







    // =======================================================================
    // Выбрать из базы данных записи о подписках на уведомление согласно параметрам (опциональные взяты в квадратные скобки):
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->sort_direction] = направление сортировки
    //   [$params->sort_laconical] = признак лаконичного режима сортировки
    //   [$params->ids] = идентификаторы подписок (перечисленные через запятую)
    //   [$params->type] = тип уведомления
    //   [$params->user_id] = идентификатор пользователя
    //   [$params->email] = емейл получателя
    //   [$params->phone] = телефон получателя
    //   [$params->icq] = ICQ номер получателя
    //   [$params->skype] = Skype имя получателя
    //   [$params->object_id] = идентификатор отслеживаемого объекта
    //   [$params->variant_id] = идентификатор варианта отслеживаемого объекта
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->done] = признак "выполнена" запись
    //   [$params->remote_token] = аутентификатор удаленного действия
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_notifies (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_notifies");

      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // запоминаем направление сортировки и режим лаконичности
      $direction = (isset($params->sort_direction) && ($params->sort_direction == SORT_DIRECTION_DESCENDING)) ? "DESC " : "ASC ";
      $laconical = !empty($params->sort_laconical);

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_NOTIFIES_MODE_BY_TYPE:
            $order = DATABASE_NOTIFIES_TABLENAME . ".type " . $direction . ", "
                   . DATABASE_NOTIFIES_TABLENAME . ".created DESC ";
            if ($laconical) $where .= "AND TRIM(" . DATABASE_NOTIFIES_TABLENAME . ".type) != '' ";
            break;
          case SORT_NOTIFIES_MODE_BY_USER:
            $order = DATABASE_NOTIFIES_TABLENAME . ".user_id " . $direction . ", "
                   . DATABASE_NOTIFIES_TABLENAME . ".created DESC ";
            if ($laconical) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".user_id != 0 ";
            break;
          case SORT_NOTIFIES_MODE_BY_PHONE:
            $order = DATABASE_NOTIFIES_TABLENAME . ".phone " . $direction . ", "
                   . DATABASE_NOTIFIES_TABLENAME . ".created DESC ";
            if ($laconical) $where .= "AND TRIM(" . DATABASE_NOTIFIES_TABLENAME . ".phone) != '' ";
            break;
          case SORT_NOTIFIES_MODE_BY_EMAIL:
            $order = DATABASE_NOTIFIES_TABLENAME . ".email " . $direction . ", "
                   . DATABASE_NOTIFIES_TABLENAME . ".created DESC ";
            if ($laconical) $where .= "AND TRIM(" . DATABASE_NOTIFIES_TABLENAME . ".email) != '' ";
            break;
          case SORT_NOTIFIES_MODE_BY_ICQ:
            $order = DATABASE_NOTIFIES_TABLENAME . ".icq " . $direction . ", "
                   . DATABASE_NOTIFIES_TABLENAME . ".created DESC ";
            if ($laconical) $where .= "AND TRIM(" . DATABASE_NOTIFIES_TABLENAME . ".icq) != '' ";
            break;
          case SORT_NOTIFIES_MODE_BY_SKYPE:
            $order = DATABASE_NOTIFIES_TABLENAME . ".skype " . $direction . ", "
                   . DATABASE_NOTIFIES_TABLENAME . ".created DESC ";
            if ($laconical) $where .= "AND TRIM(" . DATABASE_NOTIFIES_TABLENAME . ".skype) != '' ";
            break;
          case SORT_NOTIFIES_MODE_BY_OBJECT:
            $order = DATABASE_NOTIFIES_TABLENAME . ".object_id " . $direction . ", "
                   . DATABASE_NOTIFIES_TABLENAME . ".variant_id DESC, "
                   . DATABASE_NOTIFIES_TABLENAME . ".created DESC ";
            if ($laconical) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".object_id != 0 ";
            break;
          case SORT_NOTIFIES_MODE_BY_IP:
            $order = DATABASE_NOTIFIES_TABLENAME . ".ip " . $direction . ", "
                   . DATABASE_NOTIFIES_TABLENAME . ".created DESC ";
            if ($laconical) $where .= "AND TRIM(" . DATABASE_NOTIFIES_TABLENAME . ".ip) != '' ";
            break;
          case SORT_NOTIFIES_MODE_BY_MODIFIED:
            $order = DATABASE_NOTIFIES_TABLENAME . ".modified " . $direction . ", "
                   . DATABASE_NOTIFIES_TABLENAME . ".created DESC ";
            if ($laconical) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".modified IS NOT NULL "
                                    . "AND " . DATABASE_NOTIFIES_TABLENAME . ".modified != '0000-00-00 00:00:00' "
                                    . "AND " . DATABASE_NOTIFIES_TABLENAME . ".modified != " . DATABASE_NOTIFIES_TABLENAME . ".created ";
            break;
          case SORT_NOTIFIES_MODE_BY_CREATED:
          case SORT_NOTIFIES_MODE_AS_IS:
          default:
            $order = DATABASE_NOTIFIES_TABLENAME . ".created " . $direction . " ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".notify_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if (isset($params->type)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".type = '" . $this->query_value($params->type) . "' ";
      if (isset($params->user_id)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".user_id = '" . $this->query_value($params->user_id) . "' ";
      if (isset($params->email)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".email = '" . $this->query_value($params->email) . "' ";
      if (isset($params->phone)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".phone = '" . $this->query_value($params->phone) . "' ";
      if (isset($params->icq)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".icq = '" . $this->query_value($params->icq) . "' ";
      if (isset($params->skype)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".skype = '" . $this->query_value($params->skype) . "' ";
      if (isset($params->object_id)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".object_id = '" . $this->query_value($params->object_id) . "' ";
      if (isset($params->variant_id)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".variant_id = '" . $this->query_value($params->variant_id) . "' ";
      if (isset($params->enabled)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".enabled = '" . $this->query_value($params->enabled) . "' ";
      if (isset($params->done)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".done = '" . $this->query_value($params->done) . "' ";
      if (isset($params->remote_token)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".remote_token = '" . $this->query_value($params->remote_token) . "' ";
      if ($where != "") $where = "WHERE 1 " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS " . DATABASE_NOTIFIES_TABLENAME . ".* "
             . "FROM " . DATABASE_NOTIFIES_TABLENAME . " "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о подписке на уведомление, указанной в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->type] = тип уведомления
    //   [$params->user_id] = идентификатор пользователя
    //   [$params->email] = емейл получателя
    //   [$params->phone] = телефон получателя
    //   [$params->icq] = ICQ номер получателя
    //   [$params->skype] = Skype имя получателя
    //   [$params->object_id] = идентификатор отслеживаемого объекта
    //   [$params->variant_id] = идентификатор варианта отслеживаемого объекта
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->done] = признак "выполнена" запись
    //   [$params->remote_token] = аутентификатор удаленного действия
    // =======================================================================

    public function get_notify (&$item, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_notify");

      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".notify_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->type) && (isset($params->user_id) || isset($params->email) || isset($params->phone) || isset($params->icq) || isset($params->skype))) {
        $type = strtolower(trim($params->type));
        switch ($type) {
          case NOTIFY_TYPE_REQUEST_PARAM_VALUE_EXIST:
          case NOTIFY_TYPE_REQUEST_PARAM_VALUE_PRODUCT:
            if (!isset($params->variant_id)) break;
          case NOTIFY_TYPE_REQUEST_PARAM_VALUE_ARTICLE:
          case NOTIFY_TYPE_REQUEST_PARAM_VALUE_NEWSITEM:
          case NOTIFY_TYPE_REQUEST_PARAM_VALUE_USER:
            if (!isset($params->object_id)) break;
          case NOTIFY_TYPE_REQUEST_PARAM_VALUE_ALL:
          default:
            if ($type != "*") $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".type = '" . $this->query_value($type) . "' ";
            if (isset($params->user_id)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".user_id = '" . $this->query_value($params->user_id) . "' ";
            if (isset($params->email)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".email = '" . $this->query_value($params->email) . "' ";
            if (isset($params->phone)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".phone = '" . $this->query_value($params->phone) . "' ";
            if (isset($params->icq)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".icq = '" . $this->query_value($params->icq) . "' ";
            if (isset($params->skype)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".skype = '" . $this->query_value($params->skype) . "' ";
            if (isset($params->object_id)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".object_id = '" . $this->query_value($params->object_id) . "' ";
            if (isset($params->variant_id)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".variant_id = '" . $this->query_value($params->variant_id) . "' ";
        }
      }
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".notify_id != '" . $this->query_value($params->exclude_id) . "' ";
        if (isset($params->enabled)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".enabled = '" . $this->query_value($params->enabled) . "' ";
        if (isset($params->done)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".done = '" . $this->query_value($params->done) . "' ";
        if (isset($params->remote_token)) $where .= "AND " . DATABASE_NOTIFIES_TABLENAME . ".remote_token = '" . $this->query_value($params->remote_token) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT " . DATABASE_NOTIFIES_TABLENAME . ".* "
               . "FROM " . DATABASE_NOTIFIES_TABLENAME . " "
               . $where
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_notifies_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о подписке на уведомление в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_notify (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_notify");

      $id = "";
      if (!empty($item)) {

        // готовим изменившиеся поля
        $fields = array(); $values = array();
        if (isset($item->notify_id))    {$fields[] = "notify_id";    $values[] = "'" . $this->query_value($this->value_as_integer($item->notify_id)) . "'";}
        if (isset($item->type))         {$fields[] = "type";         $values[] = "'" . $this->query_value($this->value_as_string($item->type)) . "'";}
        if (isset($item->user_id))      {$fields[] = "user_id";      $values[] = "'" . $this->query_value($this->value_as_integer($item->user_id)) . "'";}
        if (isset($item->email))        {$fields[] = "email";        $values[] = "'" . $this->query_value($this->value_as_string($item->email)) . "'";}
        if (isset($item->phone))        {$fields[] = "phone";        $values[] = "'" . $this->query_value($this->value_as_string($item->phone)) . "'";}
        if (isset($item->icq))          {$fields[] = "icq";          $values[] = "'" . $this->query_value($this->value_as_string($item->icq)) . "'";}
        if (isset($item->skype))        {$fields[] = "skype";        $values[] = "'" . $this->query_value($this->value_as_string($item->skype)) . "'";}
        if (isset($item->object_id))    {$fields[] = "object_id";    $values[] = "'" . $this->query_value($this->value_as_integer($item->object_id)) . "'";}
        if (isset($item->variant_id))   {$fields[] = "variant_id";   $values[] = "'" . $this->query_value($this->value_as_integer($item->variant_id)) . "'";}
        if (isset($item->done))         {$fields[] = "done";         $values[] = "'" . $this->query_value($this->value_as_boolean($item->done)) . "'";}
        if (isset($item->enabled))      {$fields[] = "enabled";      $values[] = "'" . $this->query_value($this->value_as_boolean($item->enabled)) . "'";}
        if (isset($item->ip))           {$fields[] = "ip";           $values[] = "'" . $this->query_value($this->value_as_string($this->unfixed_notifies_record_ip($item))) . "'";}
        if (isset($item->created))      {$fields[] = "created";      $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified))     {$fields[] = "modified";     $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        if (isset($item->remote_token)) {$fields[] = "remote_token"; $values[] = "'" . $this->query_value($this->value_as_string($item->remote_token)) . "'";}

        // обновляем / добавляем запись
        $id = $this->update_record($item, DATABASE_NOTIFIES_TABLENAME, "notify_id", $fields, $values);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем идентификатор обновленной / добавленной записи
      return $id;
    }

    // =======================================================================
    // Поправить поля записи о подписке на уведомление:
    //   $item = запись
    // =======================================================================

    public function fix_notifies_record (&$item) {

      // поправляем адресующие поля
      if (isset($item->notify_id)) $item->notify_id = intval($item->notify_id);

      // поправляем поле ip-адреса (разделяем на поля ip и host)
      if (isset($item->ip)) {
        $item->ip = explode(" ", trim($item->ip), 2);
        $item->host = isset($item->ip[1]) ? trim($item->ip[1]) : "";
        $item->ip = trim($item->ip[0]);
      }
    }

    // =======================================================================
    // Возвратить в виде строки набор полей ip-адреса записи о подписке на уведомление:
    //   $item = запись
    // =======================================================================

    public function unfixed_notifies_record_ip (&$item) {
      $result = trim((isset($item->ip) ? $item->ip : "") . " "
                   . (isset($item->host) ? $item->host : ""));
      while (strpos($result, "  ") !== FALSE) $result = str_replace("  ", " ", $result);
      return $result;
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу подписки на уведомления в базе данных.
    // =======================================================================

    private function check_database_notifies () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_notifies");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = DATABASE_NOTIFIES_TABLENAME;
      $dbtable_field = "notify_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(20) NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор подписки'";
      } else {

        // подписка
        $name = $dbtable_field;
        $type = "BIGINT(20)";
        if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор подписки'";
      }

      // тип
      $name = "type";
      $type = "VARCHAR(16)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Тип уведомления'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // пользователь
      $name = "user_id";
      $type = "BIGINT(" . DATABASE_NOTIFIES_FIELDSIZE_USERID . ")";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Идентификатор пользователя'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // емейл
      $name = "email";
      $type = "VARCHAR(" . DATABASE_NOTIFIES_FIELDSIZE_EMAIL . ")";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Емейл получателя'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // телефон
      $name = "phone";
      $type = "VARCHAR(" . DATABASE_NOTIFIES_FIELDSIZE_PHONE . ")";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Телефон получателя'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // icq
      $name = "icq";
      $type = "VARCHAR(" . DATABASE_NOTIFIES_FIELDSIZE_ICQ . ")";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'ICQ номер получателя'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // skype
      $name = "skype";
      $type = "VARCHAR(" . DATABASE_NOTIFIES_FIELDSIZE_SKYPE . ")";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Skype имя получателя'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // отслеживаемый объект
      $name = "object_id";
      $type = "BIGINT(20)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Идентификатор отслеживаемого объекта'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // вариант отслеживаемого объекта
      $name = "variant_id";
      $type = "BIGINT(20)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Идентификатор варианта отслеживаемого объекта'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // выполнено
      $name = "done";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Признак Выполнено ли уведомление'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // разрешено
      $name = "enabled";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '1' NOT NULL COMMENT 'Разрешена ли запись к использованию'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // ip
      $name = "ip";
      $type = "VARCHAR(" . DATABASE_NOTIFIES_FIELDSIZE_IP . ")";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'IP-адрес получателя во время заявки'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // создано
      $name = "created";
      $type = "DATETIME";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата создания записи'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // исправлено
      $name = "modified";
      $type = "DATETIME";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата изменения записи'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // аутентификатор
      $name = "remote_token";
      $type = "VARCHAR(" . DATABASE_NOTIFIES_FIELDSIZE_TOKEN . ")";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Аутентификатор удаленного действия'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Выбрать из базы данных записи об отзывах на товары согласно параметрам (опциональные взяты в квадратные скобки):
    //   $items = результат будет помещен в эту переменную
    //   [$params->flatlist] = признак возврата результата в виде плоского списка
    //   [$params->find] = строка поиска
    //   [$params->product_id] = идентификатор товара
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->reverse] = нужно ли перевернуть порядок записей результата
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_comments (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_comments");

      $items = array();
      $count = 0;
      $pass = 0;
      $find = isset($params->find) ? $this->reduce_space($params->find) : "";
      do {
        $key = trim($find);
        $selector = "";
        $filter = "";
        if (isset($params->product_id)) $selector .= "AND products_comments.product_id = '" . $this->query_value($params->product_id) . "' ";
        if (isset($params->enabled)) $selector .= "AND products_comments.enabled = '" . $this->query_value($params->enabled) . "' ";
        if ($key != "") {
          if ($pass > 0) {
            $words = explode(" ", $key);
          } else {
            $words = array($key);
            if (strpos($key, " ") === FALSE) $pass++;
          }
          foreach ($words as $key) {
            $key = $this->query_value($key);
            $command = substr($key, 0, 4);
            switch (strtolower($command)) {
              case "cid:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND products_comments.comment_id = '" . $key . "' ";
                break;
              case "oid:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND products_comments.parent_id = '" . $key . "' ";
                break;
              case "pid:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND products.product_id = '" . $key . "' ";
                break;
              case "uip:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND products_comments.ip = '" . $key . "' ";
                break;
              case "dat:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND date LIKE '" . $key . "%' ";
                break;
              case "nam:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND products_comments.name LIKE '%" . $key . "%' ";
                break;
              default:
                $filter .= "AND (products_comments.comment LIKE '%" . $key . "%' "
                              . "OR products.model LIKE '%" . $key . "%' "
                              . "OR " . DATABASE_CATEGORIES_TABLENAME . ".name LIKE '%" . $key . "%' "
                              . "OR " . DATABASE_BRANDS_TABLENAME . ".name LIKE '%" . $key . "%' "
                              . "OR " . DATABASE_CATEGORIES_TABLENAME . ".single_name LIKE '%" . $key . "%') ";
            }
          }
        }

        // запоминаем направление сортировки
        $direction = isset($params->reverse) && $params->reverse && isset($params->flatlist) && $params->flatlist ? "DESC " : "ASC ";

        // если просят вернуть плоский список
        $limit = "";
        $calculator = "";
        if (isset($params->flatlist) && $params->flatlist) {

          // формируем параметр LIMIT запроса
          if (isset($params->start) || isset($params->maxcount)) {
            $limit = "LIMIT ";
            if (isset($params->start)) {
              $params->start = intval($params->start);
              if ($params->start >= 0) $limit .= $params->start . ", ";
            }
            if (isset($params->maxcount)) {
              $params->maxcount = intval($params->maxcount);
              if ($params->maxcount >= 0) $limit .= $params->maxcount;
            }
          }

          // указываем команду калькуляции полного количества записей
          $calculator = "SQL_CALC_FOUND_ROWS ";
        }

        // выполняем запрос
        $query = "SELECT " . $calculator
                      . "products_comments.*, "
                      . "DATE_FORMAT(products_comments.date, '%Y.%m.%d %H:%i') AS date, "
                      . DATABASE_BRANDS_TABLENAME . ".name AS brand, "
                      . DATABASE_BRANDS_TABLENAME . ".url AS brand_url, "
                      . DATABASE_BRANDS_TABLENAME . ".url_special AS brand_url_special, "
                      . "CASE WHEN TRIM(" . DATABASE_CATEGORIES_TABLENAME . ".single_name) != '' "
                           . "THEN TRIM(" . DATABASE_CATEGORIES_TABLENAME . ".single_name) "
                           . "ELSE TRIM(" . DATABASE_CATEGORIES_TABLENAME . ".name) "
                           . "END AS category, "
                      . DATABASE_CATEGORIES_TABLENAME . ".url AS category_url, "
                      . DATABASE_CATEGORIES_TABLENAME . ".url_special AS category_url_special, "
                      . "products.model AS model, "
                      . "products.url AS product_url, "
                      . "products.url_special AS product_url_special "
               . "FROM products_comments "
               . "LEFT JOIN products "
                         . "ON products.product_id = products_comments.product_id "
               . "LEFT JOIN " . DATABASE_CATEGORIES_TABLENAME . " "
                         . "ON products.category_id = " . DATABASE_CATEGORIES_TABLENAME . ".category_id "
               . "LEFT JOIN " . DATABASE_BRANDS_TABLENAME . " "
                         . "ON products.brand_id = " . DATABASE_BRANDS_TABLENAME . ".brand_id "
               . (empty($filter) && empty($selector) ? "" : "WHERE 1 " . $selector . $filter)
               . "ORDER BY date " . $direction . ", "
                        . "comment_id " . $direction
               . $limit . ";";
        $result = $this->query($query);

        // если просят вернуть плоский список
        if (isset($params->flatlist) && $params->flatlist) {
          $items = $this->results();

          // вычисляем полное количество подобных записей
          $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
          $count = $this->result();
          $count = isset($count->count) ? $count->count : 0;

          // освобождаем память от запроса
          $this->free_result($result);
          $this->free_result($result2);

        } else {
          if (!empty($result)) {
            $temp = array();
            while ($item = $this->fetch_object($result)) {
              $item->discussion = array();
              $temp[$item->comment_id] = $item;
            }

            // освобождаем память от запроса
            $this->free_result($result);

            foreach ($temp as $key => $item) {
              if (empty($item->parent_id) || !isset($temp[$item->parent_id])) {
                $items[] = &$temp[$key];
                $count++;
              } else {
                $temp[$item->parent_id]->discussion[$key] = &$temp[$key];
              }
            }
            if (isset($params->reverse) && $params->reverse) $items = array_reverse($items);
            $this->compute_comments_numbers($items);
            $start = isset($params->start) ? $params->start : 0;
            $maxcount = isset($params->maxcount) ? $params->maxcount : 0;
            if (!empty($maxcount)) $items = array_slice($items, $start, $maxcount);
          }
        }

        $pass++;
      } while (empty($count) && ($pass < 2) && !empty($filter));

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем полное количество подобных записей
      return $count;
    }

    // =======================================================================
    // Добавить в записи об отзывах на товары оперативные ссылки админпанели:
    //   $items = массив записей об отзывах
    //   $params->token = аутентификатор операции
    // =======================================================================

    public function operable_comments (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_comments");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->comment_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "Comments",
                             REQUEST_PARAM_NAME_ITEMID => $item->comment_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $item->edit_get = $this->parent->form_get($options);
            // если есть вложенные элементы, добавляем ссылки в них
            if (!empty($item->discussion)) $this->operable_comments($item->discussion, $params);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Вычислить в записях об отзывах на товары порядковые номера отзывов:
    // =======================================================================

    public function compute_comments_numbers (&$items, $startnum = 0) {
      $number = 0;
      if (!empty($items)) {
        foreach ($items as &$item) {
          $number++;
          $item->number = $number + $startnum;
          if (!empty($item->discussion)) $number += $this->compute_comments_numbers($item->discussion, $number);
        }
      }
      return $number;
    }

    // =======================================================================
    // Обновить/добавить запись об отзыве на товар в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля) об отзыве на товар,
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_comment (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_comment");

      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->comment_id)) {$fields[] = "comment_id"; $values[] = "'" . $this->query_value($this->value_as_integer($item->comment_id)) . "'";}
        if (isset($item->parent_id))  {$fields[] = "parent_id";  $values[] = "'" . $this->query_value($this->value_as_integer($item->parent_id)) . "'";}
        if (isset($item->product_id)) {$fields[] = "product_id"; $values[] = "'" . $this->query_value($this->value_as_integer($item->product_id)) . "'";}
        if (isset($item->ip))         {$fields[] = "ip";         $values[] = "'" . $this->query_value($this->value_as_string($item->ip)) . "'";}
        if (isset($item->date))       {$fields[] = "date";       $values[] = "'" . $this->query_value($this->value_as_date($item->date)) . "'";}
        if (isset($item->name))       {$fields[] = "name";       $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->comment))    {$fields[] = "comment";    $values[] = "'" . $this->query_value($this->value_as_string($item->comment)) . "'";}
        if (isset($item->email))      {$fields[] = "email";      $values[] = "'" . $this->query_value($this->value_as_string($item->email)) . "'";}
        if (isset($item->from_user))  {$fields[] = "from_user";  $values[] = "'" . $this->query_value($this->value_as_integer($item->from_user)) . "'";}
        if (isset($item->enabled))    {$fields[] = "enabled";    $values[] = "'" . $this->query_value($this->value_as_boolean($item->enabled)) . "'";}
        $id = $this->update_record($item, "products_comments", "comment_id", $fields, $values);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      return $id;
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу отзывов на товары в базе данных.
    // =======================================================================

    private function check_database_products_comments () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_products_comments");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "products_comments";
      $dbtable_field = "comment_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "DROP PRIMARY KEY";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT";
      }
      if (!isset($columns["parent_id"])) {
        $query[] = "ADD parent_id BIGINT(20) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (parent_id)";
      }
      if (!isset($columns["product_id"])) {
        $query[] = "ADD product_id BIGINT(20) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (product_id)";
      }
      if (!isset($columns["ip"])) {
        $query[] = "ADD ip VARCHAR(256) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["date"])) {
        $query[] = "ADD date DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(" . DATABASE_PRODUCTSCOMMENTS_FIELDSIZE_NAME . ") DEFAULT '' NOT NULL";
      }
      if (!isset($columns["comment"])) {
        $query[] = "ADD comment VARCHAR(" . DATABASE_PRODUCTSCOMMENTS_FIELDSIZE_COMMENT . ") DEFAULT '' NOT NULL";
      }
      if (!isset($columns["email"])) {
        $query[] = "ADD email VARCHAR(" . DATABASE_PRODUCTSCOMMENTS_FIELDSIZE_EMAIL . ") DEFAULT '' NOT NULL";
      }
      if (!isset($columns["from_user"])) {
        $query[] = "ADD from_user BIGINT(" . DATABASE_USERS_FIELDSIZE_ID . ") DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (from_user)";
      }
      if (!isset($columns["enabled"])) {
        $query[] = "ADD enabled TINYINT(1) DEFAULT '1' NOT NULL";
        $query[] = "ADD INDEX (enabled)";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Выбрать из базы данных записи о комментариях к статьям согласно параметрам (опциональные взяты в квадратные скобки):
    //   $items = результат будет помещен в эту переменную
    //   [$params->flatlist] = признак возврата результата в виде плоского списка
    //   [$params->find] = строка поиска
    //   [$params->article_id] = идентификатор статьи
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->reverse] = нужно ли перевернуть порядок записей результата
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    //   $full_count = общее количество комментариев будет помещено в эту переменную
    // =======================================================================

    public function get_acomments (&$items, $params = null, &$full_count = 0) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_acomments");

      $items = array();
      $count = 0;
      $full_count = 0;
      $pass = 0;
      $find = isset($params->find) ? $this->reduce_space($params->find) : "";
      do {
        $key = trim($find);
        $selector = "";
        $filter = "";
        if (isset($params->article_id)) $selector .= "AND articles_comments.article_id = '" . $this->query_value($params->article_id) . "' ";
        if (isset($params->enabled)) $selector .= "AND articles_comments.enabled = '" . $this->query_value($params->enabled) . "' ";
        if ($key != "") {
          if ($pass > 0) {
            $words = explode(" ", $key);
          } else {
            $words = array($key);
            if (strpos($key, " ") === FALSE) $pass++;
          }
          foreach ($words as $key) {
            $key = $this->query_value($key);
            $command = substr($key, 0, 4);
            switch (strtolower($command)) {
              case "cid:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND articles_comments.comment_id = '" . $key . "' ";
                break;
              case "oid:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND articles_comments.parent_id = '" . $key . "' ";
                break;
              case "pid:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND articles.article_id = '" . $key . "' ";
                break;
              case "uip:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND articles_comments.ip = '" . $key . "' ";
                break;
              case "dat:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND date LIKE '" . $key . "%' ";
                break;
              case "nam:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND articles_comments.name LIKE '%" . $key . "%' ";
                break;
              default:
                $filter .= "AND (articles_comments.comment LIKE '%" . $key . "%' "
                              . "OR articles.header LIKE '%" . $key . "%') ";
            }
          }
        }

        // запоминаем направление сортировки
        $direction = isset($params->reverse) && $params->reverse && isset($params->flatlist) && $params->flatlist ? "DESC " : "ASC ";

        // если просят вернуть плоский список
        $limit = "";
        $calculator = "";
        if (isset($params->flatlist) && $params->flatlist) {

          // формируем параметр LIMIT запроса
          if (isset($params->start) || isset($params->maxcount)) {
            $limit = "LIMIT ";
            if (isset($params->start)) {
              $params->start = intval($params->start);
              if ($params->start >= 0) $limit .= $params->start . ", ";
            }
            if (isset($params->maxcount)) {
              $params->maxcount = intval($params->maxcount);
              if ($params->maxcount >= 0) $limit .= $params->maxcount;
            }
          }

          // указываем команду калькуляции полного количества записей
          $calculator = "SQL_CALC_FOUND_ROWS ";
        }

        // выполняем запрос
        $query = "SELECT " . $calculator
                      . "articles_comments.*, "
                      . "DATE_FORMAT(articles_comments.date, '%Y.%m.%d %H:%i') AS date, "
                      . "articles.header AS header, "
                      . "articles.url AS article_url, "
                      . "articles.url_special AS article_url_special "
               . "FROM articles_comments "
               . "LEFT JOIN articles "
                         . "ON articles.article_id = articles_comments.article_id "
               . (empty($filter) && empty($selector) ? "" : "WHERE 1 " . $selector . $filter)
               . "ORDER BY date " . $direction . ", "
                        . "comment_id " . $direction
               . $limit . ";";
        $result = $this->query($query);

        // если просят вернуть плоский список
        if (isset($params->flatlist) && $params->flatlist) {
          $items = $this->results();

          // вычисляем полное количество подобных записей
          $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
          $count = $this->result();
          $count = isset($count->count) ? $count->count : 0;
          $full_count = $count;

          // освобождаем память от запроса
          $this->free_result($result);
          $this->free_result($result2);

        } else {
          if (!empty($result)) {
            $temp = array();
            while ($item = $this->fetch_object($result)) {
              $item->discussion = array();
              $temp[$item->comment_id] = $item;
            }

            // освобождаем память от запроса
            $this->free_result($result);

            foreach ($temp as $key => $item) {
              if (empty($item->parent_id) || !isset($temp[$item->parent_id])) {
                $items[] = &$temp[$key];
                $count++;
              } else {
                $temp[$item->parent_id]->discussion[$key] = &$temp[$key];
              }
              $full_count++;
            }
            if (isset($params->reverse) && $params->reverse) $items = array_reverse($items);
            $this->compute_comments_numbers($items);
            $start = isset($params->start) ? $params->start : 0;
            $maxcount = isset($params->maxcount) ? $params->maxcount : 0;
            if (!empty($maxcount)) $items = array_slice($items, $start, $maxcount);
          }
        }

        $pass++;
      } while (empty($count) && ($pass < 2) && !empty($filter));

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем полное количество подобных записей
      return $count;
    }

    // =======================================================================
    // Добавить в записи о комментариях к статьям оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    // =======================================================================

    public function operable_acomments (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_acomments");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->comment_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "AComments",
                             REQUEST_PARAM_NAME_ITEMID => $item->comment_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $item->edit_get = $this->parent->form_get($options);
            // если есть вложенные элементы, добавляем ссылки в них
            if (!empty($item->discussion)) $this->operable_acomments($item->discussion, $params);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о комментарии к статье в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_acomment (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_acomment");

      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->comment_id)) {$fields[] = "comment_id"; $values[] = "'" . $this->query_value($this->value_as_integer($item->comment_id)) . "'";}
        if (isset($item->parent_id))  {$fields[] = "parent_id";  $values[] = "'" . $this->query_value($this->value_as_integer($item->parent_id)) . "'";}
        if (isset($item->article_id)) {$fields[] = "article_id"; $values[] = "'" . $this->query_value($this->value_as_integer($item->article_id)) . "'";}
        if (isset($item->ip))         {$fields[] = "ip";         $values[] = "'" . $this->query_value($this->value_as_string($item->ip)) . "'";}
        if (isset($item->date))       {$fields[] = "date";       $values[] = "'" . $this->query_value($this->value_as_date($item->date)) . "'";}
        if (isset($item->name))       {$fields[] = "name";       $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->comment))    {$fields[] = "comment";    $values[] = "'" . $this->query_value($this->value_as_string($item->comment)) . "'";}
        if (isset($item->email))      {$fields[] = "email";      $values[] = "'" . $this->query_value($this->value_as_string($item->email)) . "'";}
        if (isset($item->from_user))  {$fields[] = "from_user";  $values[] = "'" . $this->query_value($this->value_as_integer($item->from_user)) . "'";}
        if (isset($item->enabled))    {$fields[] = "enabled";    $values[] = "'" . $this->query_value($this->value_as_boolean($item->enabled)) . "'";}
        $id = $this->update_record($item, "articles_comments", "comment_id", $fields, $values);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      return $id;
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу комментариев к статьям в базе данных.
    // =======================================================================

    private function check_database_articles_comments () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_articles_comments");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "articles_comments";
      $dbtable_field = "comment_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "DROP PRIMARY KEY";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT";
      }
      if (!isset($columns["parent_id"])) {
        $query[] = "ADD parent_id BIGINT(20) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (parent_id)";
      }
      if (!isset($columns["article_id"])) {
        $query[] = "ADD article_id BIGINT(20) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (article_id)";
      }
      if (!isset($columns["ip"])) {
        $query[] = "ADD ip VARCHAR(256) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["date"])) {
        $query[] = "ADD date DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(" . DATABASE_ARTICLESCOMMENTS_FIELDSIZE_NAME . ") DEFAULT '' NOT NULL";
      }
      if (!isset($columns["comment"])) {
        $query[] = "ADD comment VARCHAR(" . DATABASE_ARTICLESCOMMENTS_FIELDSIZE_COMMENT . ") DEFAULT '' NOT NULL";
      }
      if (!isset($columns["email"])) {
        $query[] = "ADD email VARCHAR(" . DATABASE_ARTICLESCOMMENTS_FIELDSIZE_EMAIL . ") DEFAULT '' NOT NULL";
      }
      if (!isset($columns["from_user"])) {
        $query[] = "ADD from_user BIGINT(" . DATABASE_USERS_FIELDSIZE_ID . ") DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (from_user)";
      }
      if (!isset($columns["enabled"])) {
        $query[] = "ADD enabled TINYINT(1) DEFAULT '1' NOT NULL";
        $query[] = "ADD INDEX (enabled)";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Выбрать из базы данных записи о комментариях к новостям согласно параметрам (опциональные взяты в квадратные скобки):
    //   $items = результат будет помещен в эту переменную
    //   [$params->flatlist] = признак возврата результата в виде плоского списка
    //   [$params->find] = строка поиска
    //   [$params->news_id] = идентификатор новости
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->reverse] = нужно ли перевернуть порядок записей результата
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    //   $full_count = общее количество комментариев будет помещено в эту переменную
    // =======================================================================

    public function get_ncomments (&$items, $params = null, &$full_count = 0) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_ncomments");

      $items = array();
      $count = 0;
      $full_count = 0;
      $pass = 0;
      $find = isset($params->find) ? $this->reduce_space($params->find) : "";
      do {
        $key = trim($find);
        $selector = "";
        $filter = "";
        if (isset($params->news_id)) $selector .= "AND news_comments.news_id = '" . $this->query_value($params->news_id) . "' ";
        if (isset($params->enabled)) $selector .= "AND news_comments.enabled = '" . $this->query_value($params->enabled) . "' ";
        if ($key != "") {
          if ($pass > 0) {
            $words = explode(" ", $key);
          } else {
            $words = array($key);
            if (strpos($key, " ") === FALSE) $pass++;
          }
          foreach ($words as $key) {
            $key = $this->query_value($key);
            $command = substr($key, 0, 4);
            switch (strtolower($command)) {
              case "cid:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND news_comments.comment_id = '" . $key . "' ";
                break;
              case "oid:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND news_comments.parent_id = '" . $key . "' ";
                break;
              case "pid:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND news.news_id = '" . $key . "' ";
                break;
              case "uip:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND news_comments.ip = '" . $key . "' ";
                break;
              case "dat:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND date LIKE '" . $key . "%' ";
                break;
              case "nam:":
                $key = trim(substr($key, 4));
                if ($key != "") $filter .= "AND news_comments.name LIKE '%" . $key . "%' ";
                break;
              default:
                $filter .= "AND (news_comments.comment LIKE '%" . $key . "%' "
                              . "OR news.header LIKE '%" . $key . "%') ";
            }
          }
        }

        // запоминаем направление сортировки
        $direction = isset($params->reverse) && $params->reverse && isset($params->flatlist) && $params->flatlist ? "DESC " : "ASC ";

        // если просят вернуть плоский список
        $limit = "";
        $calculator = "";
        if (isset($params->flatlist) && $params->flatlist) {

          // формируем параметр LIMIT запроса
          if (isset($params->start) || isset($params->maxcount)) {
            $limit = "LIMIT ";
            if (isset($params->start)) {
              $params->start = intval($params->start);
              if ($params->start >= 0) $limit .= $params->start . ", ";
            }
            if (isset($params->maxcount)) {
              $params->maxcount = intval($params->maxcount);
              if ($params->maxcount >= 0) $limit .= $params->maxcount;
            }
          }

          // указываем команду калькуляции полного количества записей
          $calculator = "SQL_CALC_FOUND_ROWS ";
        }

        // выполняем запрос
        $query = "SELECT " . $calculator
                      . "news_comments.*, "
                      . "DATE_FORMAT(news_comments.date, '%Y.%m.%d %H:%i') AS date, "
                      . "news.header AS header, "
                      . "news.url AS news_url, "
                      . "news.url_special AS news_url_special "
               . "FROM news_comments "
               . "LEFT JOIN news "
                         . "ON news.news_id = news_comments.news_id "
               . (empty($filter) && empty($selector) ? "" : "WHERE 1 " . $selector . $filter)
               . "ORDER BY date " . $direction . ", "
                        . "comment_id " . $direction
               . $limit . ";";
        $result = $this->query($query);

        // если просят вернуть плоский список
        if (isset($params->flatlist) && $params->flatlist) {
          $items = $this->results();

          // вычисляем полное количество подобных записей
          $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
          $count = $this->result();
          $count = isset($count->count) ? $count->count : 0;
          $full_count = $count;

          // освобождаем память от запроса
          $this->free_result($result);
          $this->free_result($result2);

        } else {
          if (!empty($result)) {
            $temp = array();
            while ($item = $this->fetch_object($result)) {
              $item->discussion = array();
              $temp[$item->comment_id] = $item;
            }

            // освобождаем память от запроса
            $this->free_result($result);

            foreach ($temp as $key => $item) {
              if (empty($item->parent_id) || !isset($temp[$item->parent_id])) {
                $items[] = &$temp[$key];
                $count++;
              } else {
                $temp[$item->parent_id]->discussion[$key] = &$temp[$key];
              }
              $full_count++;
            }
            if (isset($params->reverse) && $params->reverse) $items = array_reverse($items);
            $this->compute_comments_numbers($items);
            $start = isset($params->start) ? $params->start : 0;
            $maxcount = isset($params->maxcount) ? $params->maxcount : 0;
            if (!empty($maxcount)) $items = array_slice($items, $start, $maxcount);
          }
        }

        $pass++;
      } while (empty($count) && ($pass < 2) && !empty($filter));

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем полное количество подобных записей
      return $count;
    }

    // =======================================================================
    // Добавить в записи о комментариях к новостям оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    // =======================================================================

    public function operable_ncomments (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_ncomments");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->comment_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "NComments",
                             REQUEST_PARAM_NAME_ITEMID => $item->comment_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $item->edit_get = $this->parent->form_get($options);
            // если есть вложенные элементы, добавляем ссылки в них
            if (!empty($item->discussion)) $this->operable_ncomments($item->discussion, $params);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о комментарии к новости в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_ncomment (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_ncomment");

      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->comment_id)) {$fields[] = "comment_id"; $values[] = "'" . $this->query_value($this->value_as_integer($item->comment_id)) . "'";}
        if (isset($item->parent_id))  {$fields[] = "parent_id";  $values[] = "'" . $this->query_value($this->value_as_integer($item->parent_id)) . "'";}
        if (isset($item->news_id))    {$fields[] = "news_id";    $values[] = "'" . $this->query_value($this->value_as_integer($item->news_id)) . "'";}
        if (isset($item->ip))         {$fields[] = "ip";         $values[] = "'" . $this->query_value($this->value_as_string($item->ip)) . "'";}
        if (isset($item->date))       {$fields[] = "date";       $values[] = "'" . $this->query_value($this->value_as_date($item->date)) . "'";}
        if (isset($item->name))       {$fields[] = "name";       $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->comment))    {$fields[] = "comment";    $values[] = "'" . $this->query_value($this->value_as_string($item->comment)) . "'";}
        if (isset($item->email))      {$fields[] = "email";      $values[] = "'" . $this->query_value($this->value_as_string($item->email)) . "'";}
        if (isset($item->from_user))  {$fields[] = "from_user";  $values[] = "'" . $this->query_value($this->value_as_integer($item->from_user)) . "'";}
        if (isset($item->enabled))    {$fields[] = "enabled";    $values[] = "'" . $this->query_value($this->value_as_boolean($item->enabled)) . "'";}
        $id = $this->update_record($item, "news_comments", "comment_id", $fields, $values);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      return $id;
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу комментариев к новостям в базе данных.
    // =======================================================================

    private function check_database_news_comments () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_news_comments");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "news_comments";
      $dbtable_field = "comment_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "DROP PRIMARY KEY";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT";
      }
      if (!isset($columns["parent_id"])) {
        $query[] = "ADD parent_id BIGINT(20) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (parent_id)";
      }
      if (!isset($columns["news_id"])) {
        $query[] = "ADD news_id BIGINT(20) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (news_id)";
      }
      if (!isset($columns["ip"])) {
        $query[] = "ADD ip VARCHAR(256) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["date"])) {
        $query[] = "ADD date DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(" . DATABASE_NEWSCOMMENTS_FIELDSIZE_NAME . ") DEFAULT '' NOT NULL";
      }
      if (!isset($columns["comment"])) {
        $query[] = "ADD comment VARCHAR(" . DATABASE_NEWSCOMMENTS_FIELDSIZE_COMMENT . ") DEFAULT '' NOT NULL";
      }
      if (!isset($columns["email"])) {
        $query[] = "ADD email VARCHAR(" . DATABASE_NEWSCOMMENTS_FIELDSIZE_EMAIL . ") DEFAULT '' NOT NULL";
      }
      if (!isset($columns["from_user"])) {
        $query[] = "ADD from_user BIGINT(" . DATABASE_USERS_FIELDSIZE_ID . ") DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (from_user)";
      }
      if (!isset($columns["enabled"])) {
        $query[] = "ADD enabled TINYINT(1) DEFAULT '1' NOT NULL";
        $query[] = "ADD INDEX (enabled)";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Выбрать из базы данных записи о статьях согласно параметрам (опциональные взяты в квадратные скобки):
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->ids] = идентификаторы статей (перечисленные через запятую)
    //   [$params->category_id] = идентификатор категории
    //   [$params->brand_id] = идентификатор бренда
    //   [$params->user_id] = идентификатор пользователя
    //   [$params->section] = раздел магазина
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->highlighted] = признак "выделена" запись
    //   [$params->hidden] = признак "скрыта от чужих"
    //   [$params->rss_disabled] = признак "не для rss"
    //   [$params->export_disabled] = признак "не для экспорта"
    //   [$params->listed] = признак "в анонсовых списках"
    //   [$params->commented] = признак "разрешено обсуждение"
    //   [$params->imaged] = с загруженными изображениями
    //   [$params->menu_id] = идентификатор меню
    //   [$params->objected] = с подгружаемыми модулями
    //   [$params->browsed] = просмотренные
    //   [$params->voted] = с выставленными оценками
    //   [$params->SEOed] = с SEO текстом
    //   [$params->url_special] = с особым url
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    //   [$params->minimum_info] = признак режима минимума информации
    // =======================================================================

    public function get_articles (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_articles");

      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // определяем минимальный набор полей
      $fields = "articles.article_id, "
              . "articles.header, "
              . "articles.url, "
              . "articles.url_special";

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_ARTICLES_MODE_BY_HEADER:
            $order = "articles.header ASC, "
                   . "category ASC, "
                   . "articles.order_num DESC ";
            $fields .= ", articles.order_num, "
                       . DATABASE_CATEGORIES_TABLENAME . ".name AS category";
            break;
          case SORT_ARTICLES_MODE_BY_CREATED:
            $order = "articles.created DESC, "
                   . "category ASC, "
                   . "articles.order_num DESC ";
            $fields .= ", articles.created, "
                       . "articles.order_num, "
                       . DATABASE_CATEGORIES_TABLENAME . ".name AS category";
            break;
          case SORT_ARTICLES_MODE_BY_MODIFIED:
            $order = "articles.modified DESC, "
                   . "category ASC, "
                   . "articles.order_num DESC ";
            $fields .= ", articles.modified, "
                       . "articles.order_num, "
                       . DATABASE_CATEGORIES_TABLENAME . ".name AS category";
            break;
          case SORT_ARTICLES_MODE_BY_DATE:
            $order = "articles.date DESC, "
                   . "category ASC, "
                   . "articles.order_num DESC ";
            $fields .= ", articles.date, "
                       . "articles.order_num, "
                       . DATABASE_CATEGORIES_TABLENAME . ".name AS category";
            break;
          case SORT_ARTICLES_MODE_BY_BROWSED:
            $order = "browsed DESC, "
                   . "category ASC, "
                   . "articles.order_num DESC ";
            $fields .= ", ABS(articles.browsed) AS browsed, "
                       . "articles.order_num, "
                       . DATABASE_CATEGORIES_TABLENAME . ".name AS category";
            break;
          case SORT_ARTICLES_MODE_BY_URL:
            $order = "articles.url ASC, "
                   . "category ASC, "
                   . "articles.order_num DESC ";
            $fields .= ", articles.order_num, "
                       . DATABASE_CATEGORIES_TABLENAME . ".name AS category";
            break;
          case SORT_ARTICLES_MODE_BY_MENU:
            $order = "menu DESC, "
                   . "category ASC, "
                   . "articles.order_num DESC ";
            $fields .= ", " . DATABASE_MENUS_TABLENAME . ".name AS menu, "
                       . "articles.order_num, "
                       . DATABASE_CATEGORIES_TABLENAME . ".name AS category";
            break;
          case SORT_ARTICLES_MODE_BY_OBJECTS:
            $order = "articles.objects DESC, "
                   . "category ASC, "
                   . "articles.order_num DESC ";
            $fields .= ", articles.objects, "
                       . "articles.order_num, "
                       . DATABASE_CATEGORIES_TABLENAME . ".name AS category";
            break;
          case SORT_ARTICLES_MODE_BY_VOTES:
            $order = "votes DESC, "
                   . "category ASC, "
                   . "articles.order_num DESC ";
            $fields .= ", ABS(articles.votes) AS votes, "
                       . "articles.order_num, "
                       . DATABASE_CATEGORIES_TABLENAME . ".name AS category";
            break;
          case SORT_ARTICLES_MODE_BY_RATING:
            $order = "rating / (votes + 1) DESC, "
                   . "category ASC, "
                   . "articles.order_num DESC ";
            $fields .= ", ABS(articles.rating) AS rating, "
                       . "ABS(articles.votes) AS votes, "
                       . "articles.order_num, "
                       . DATABASE_CATEGORIES_TABLENAME . ".name AS category";
            break;
          case SORT_ARTICLES_MODE_AS_IS:
          default:
            $order = "category ASC, "
                   . "articles.order_num DESC ";
            $fields .= ", articles.order_num, "
                       . DATABASE_CATEGORIES_TABLENAME . ".name AS category";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND articles.article_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if (isset($params->category_id)) $where .= "AND articles.category_id = '" . $this->query_value($params->category_id) . "' ";
      if (isset($params->brand_id)) $where .= "AND articles.brand_id = '" . $this->query_value($params->brand_id) . "' ";
      if (isset($params->user_id)) $where .= "AND articles.user_id = '" . $this->query_value($params->user_id) . "' ";
      if (isset($params->section)) $where .= "AND articles.section = '" . $this->query_value($params->section) . "' ";
      if (isset($params->enabled)) $where .= "AND articles.enabled = '" . $this->query_value($params->enabled) . "' ";
      if (isset($params->highlighted)) $where .= "AND articles.highlighted = '" . $this->query_value($params->highlighted) . "' ";
      if (isset($params->hidden)) $where .= "AND articles.hidden = '" . $this->query_value($params->hidden) . "' ";
      if (isset($params->rss_disabled)) $where .= "AND articles.rss_disabled = '" . $this->query_value($params->rss_disabled) . "' ";
      if (isset($params->export_disabled)) $where .= "AND articles.export_disabled = '" . $this->query_value($params->export_disabled) . "' ";
      if (isset($params->listed)) $where .= "AND articles.listed = '" . $this->query_value($params->listed) . "' ";
      if (isset($params->commented)) $where .= "AND articles.commented = '" . $this->query_value($params->commented) . "' ";
      if (isset($params->imaged)) $where .= "AND TRIM(REPLACE(articles.images, '" . $this->query_value(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER) . "', '')) != '' ";
      if (isset($params->menu_id)) $where .= "AND articles.menu_id = '" . $this->query_value($params->menu_id) . "' ";
      if (isset($params->objected)) $where .= "AND TRIM(articles.objects) != '' ";
      if (isset($params->browsed)) $where .= "AND ABS(articles.browsed) != 0 ";
      if (isset($params->voted)) $where .= "AND ABS(articles.votes) != 0 ";
      if (isset($params->SEOed)) $where .= "AND TRIM(articles.seo_description) != '' ";
      if (isset($params->url_special)) $where .= "AND articles.url_special = '" . $this->query_value($params->url_special) . "' ";
      if ($where != "") $where = "WHERE 1 " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // если нет признака режима минимума информации, берем все поля
      if (!isset($params->minimum_info)) {
        $fields = "articles.*, "
                . "ABS(articles.browsed) AS browsed, "
                . "ABS(articles.rating) AS rating, "
                . "ABS(articles.votes) AS votes, "
                . DATABASE_CATEGORIES_TABLENAME . ".name AS category, "
                . DATABASE_CATEGORIES_TABLENAME . ".url AS category_url, "
                . DATABASE_CATEGORIES_TABLENAME . ".url_special AS category_url_special, "
                . DATABASE_BRANDS_TABLENAME . ".name AS brand, "
                . DATABASE_BRANDS_TABLENAME . ".url AS brand_url, "
                . DATABASE_BRANDS_TABLENAME . ".url_special AS brand_url_special, "
                . DATABASE_USERS_TABLENAME . ".name AS user_name, "
                . DATABASE_MENUS_TABLENAME . ".name AS menu, "
                . "DATE_FORMAT(articles.date, '%Y-%m-%d %H:%i') AS date, "
                . "DATE_FORMAT(articles.date, '%Y-%m-%d') AS date_date, "
                . "DATE_FORMAT(articles.date, '%H:%i') AS date_time";
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS " . $fields . " "
             . "FROM articles "
             . "LEFT JOIN " . DATABASE_CATEGORIES_TABLENAME . " "
                       . "ON " . DATABASE_CATEGORIES_TABLENAME . ".category_id = articles.category_id "
             . "LEFT JOIN " . DATABASE_BRANDS_TABLENAME . " "
                       . "ON " . DATABASE_BRANDS_TABLENAME . ".brand_id = articles.brand_id "
             . "LEFT JOIN " . DATABASE_USERS_TABLENAME . " "
                       . "ON " . DATABASE_USERS_TABLENAME . ".user_id = articles.user_id "
             . "LEFT JOIN " . DATABASE_MENUS_TABLENAME . " "
                       . "ON " . DATABASE_MENUS_TABLENAME . ".menu_id = articles.menu_id "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о статье, указанной в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->header] = заголовок статьи
    //   [$params->menu_id] = идентификатор меню
    //   [$params->user_id] = идентификатор пользователя
    //   [$params->section] = раздел магазина
    //   [$params->url] = адрес страницы записи
    //   [$params->url_special] = с особым url
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->highlighted] = признак "выделена" запись
    //   [$params->hidden] = признак "скрыта от чужих"
    //   [$params->rss_disabled] = признак "не для rss"
    //   [$params->export_disabled] = признак "не для экспорта"
    // =======================================================================

    public function get_article (&$item, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_article");

      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND articles.article_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->header)) $where .= "AND articles.header = '" . $this->query_value($params->header) . "' ";
      if (isset($params->url)) $where .= "AND articles.url = '" . $this->query_value($params->url) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND articles.article_id != '" . $this->query_value($params->exclude_id) . "' ";
        if (isset($params->menu_id)) $where .= "AND articles.menu_id = '" . $this->query_value($params->menu_id) . "' ";
        if (isset($params->user_id)) $where .= "AND articles.user_id = '" . $this->query_value($params->user_id) . "' ";
        if (isset($params->section)) $where .= "AND articles.section = '" . $this->query_value($params->section) . "' ";
        if (isset($params->enabled)) $where .= "AND articles.enabled = '" . $this->query_value($params->enabled) . "' ";
        if (isset($params->highlighted)) $where .= "AND articles.highlighted = '" . $this->query_value($params->highlighted) . "' ";
        if (isset($params->hidden)) $where .= "AND articles.hidden = '" . $this->query_value($params->hidden) . "' ";
        if (isset($params->rss_disabled)) $where .= "AND articles.rss_disabled = '" . $this->query_value($params->rss_disabled) . "' ";
        if (isset($params->export_disabled)) $where .= "AND articles.export_disabled = '" . $this->query_value($params->export_disabled) . "' ";
        if (isset($params->url_special)) $where .= "AND articles.url_special = '" . $this->query_value($params->url_special) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT articles.*, "
                      . "ABS(articles.browsed) AS browsed, "
                      . "ABS(articles.rating) AS rating, "
                      . "ABS(articles.votes) AS votes, "
                      . DATABASE_CATEGORIES_TABLENAME . ".name AS category, "
                      . DATABASE_CATEGORIES_TABLENAME . ".url AS category_url, "
                      . DATABASE_CATEGORIES_TABLENAME . ".url_special AS category_url_special, "
                      . DATABASE_BRANDS_TABLENAME . ".name AS brand, "
                      . DATABASE_BRANDS_TABLENAME . ".url AS brand_url, "
                      . DATABASE_BRANDS_TABLENAME . ".url_special AS brand_url_special, "
                      . DATABASE_USERS_TABLENAME . ".name AS user_name, "
                      . "DATE_FORMAT(articles.date, '%Y-%m-%d %H:%i') AS date, "
                      . "DATE_FORMAT(articles.date, '%Y-%m-%d') AS date_date, "
                      . "DATE_FORMAT(articles.date, '%H:%i') AS date_time "
               . "FROM articles "
               . "LEFT JOIN " . DATABASE_CATEGORIES_TABLENAME . " "
                         . "ON " . DATABASE_CATEGORIES_TABLENAME . ".category_id = articles.category_id "
               . "LEFT JOIN " . DATABASE_BRANDS_TABLENAME . " "
                         . "ON " . DATABASE_BRANDS_TABLENAME . ".brand_id = articles.brand_id "
               . "LEFT JOIN " . DATABASE_USERS_TABLENAME . " "
                         . "ON " . DATABASE_USERS_TABLENAME . ".user_id = articles.user_id "
               . $where
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_articles_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Добавить в записи о статьях оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_articles (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_articles");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->article_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "Articles",
                             REQUEST_PARAM_NAME_ITEMID => $item->article_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "поднять выше"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEUP;
            $item->move_up_get = $this->parent->form_get($options);
            // создаем ссылку "опустить ниже"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEDOWN;
            $item->move_down_get = $this->parent->form_get($options);
            // создаем ссылку "поставить первым"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEFIRST;
            $item->move_first_get = $this->parent->form_get($options);
            // создаем ссылку "поставить последним"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVELAST;
            $item->move_last_get = $this->parent->form_get($options);
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "выделена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_HIGHLIGHTED;
            $item->highlight_get = $this->parent->form_get($options);
            // создаем ссылку "скрыта от чужих"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_HIDDEN;
            $item->hidden_get = $this->parent->form_get($options);
            // создаем ссылку "в анонсовых списках"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_LISTED;
            $item->listed_get = $this->parent->form_get($options);
            // создаем ссылку "обсуждаема"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_COMMENTED;
            $item->commented_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "Article";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о статье в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_article (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_article");

      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->menu_id))          {$fields[] = "menu_id";          $values[] = "'" . $this->query_value($this->value_as_integer($item->menu_id)) . "'";}
        if (isset($item->objects))          {$fields[] = "objects";          $values[] = "'" . $this->query_value($this->value_as_string($item->objects)) . "'";}
        if (isset($item->category_id))      {$fields[] = "category_id";      $values[] = "'" . $this->query_value($this->value_as_integer($item->category_id)) . "'";}
        if (isset($item->brand_id))         {$fields[] = "brand_id";         $values[] = "'" . $this->query_value($this->value_as_integer($item->brand_id)) . "'";}
        if (isset($item->user_id))          {$fields[] = "user_id";          $values[] = "'" . $this->query_value($this->value_as_integer($item->user_id)) . "'";}
        if (isset($item->enabled))          {$fields[] = "enabled";          $values[] = "'" . $this->query_value($this->value_as_boolean($item->enabled)) . "'";}
        if (isset($item->highlighted))      {$fields[] = "highlighted";      $values[] = "'" . $this->query_value($this->value_as_boolean($item->highlighted)) . "'";}
        if (isset($item->listed))           {$fields[] = "listed";           $values[] = "'" . $this->query_value($this->value_as_boolean($item->listed)) . "'";}
        if (isset($item->commented))        {$fields[] = "commented";        $values[] = "'" . $this->query_value($this->value_as_boolean($item->commented)) . "'";}
        if (isset($item->hidden))           {$fields[] = "hidden";           $values[] = "'" . $this->query_value($this->value_as_boolean($item->hidden)) . "'";}
        if (isset($item->rss_disabled))     {$fields[] = "rss_disabled";     $values[] = "'" . $this->query_value($this->value_as_boolean($item->rss_disabled)) . "'";}
        if (isset($item->export_disabled))  {$fields[] = "export_disabled";  $values[] = "'" . $this->query_value($this->value_as_boolean($item->export_disabled)) . "'";}
        if (isset($item->url))              {$fields[] = "url";              $values[] = "'" . $this->query_value($this->value_as_string($item->url)) . "'";}
        if (isset($item->url_special))      {$fields[] = "url_special";      $values[] = "'" . $this->query_value($this->value_as_boolean($item->url_special)) . "'";}
        if (isset($item->meta_title))       {$fields[] = "meta_title";       $values[] = "'" . $this->query_value($this->value_as_string($item->meta_title)) . "'";}
        if (isset($item->meta_keywords))    {$fields[] = "meta_keywords";    $values[] = "'" . $this->query_value($this->value_as_string($item->meta_keywords)) . "'";}
        if (isset($item->meta_description)) {$fields[] = "meta_description"; $values[] = "'" . $this->query_value($this->value_as_string($item->meta_description)) . "'";}
        if (isset($item->header))           {$fields[] = "header";           $values[] = "'" . $this->query_value($this->value_as_string($item->header)) . "'";}
        if (isset($item->annotation))       {$fields[] = "annotation";       $values[] = "'" . $this->query_value($this->value_as_string($item->annotation)) . "'";}
        if (isset($item->body))             {$fields[] = "body";             $values[] = "'" . $this->query_value($this->value_as_string($item->body)) . "'";}
        if (isset($item->seo_description))  {$fields[] = "seo_description";  $values[] = "'" . $this->query_value($this->value_as_string($item->seo_description)) . "'";}
        if (isset($item->images))           {$fields[] = "images";           $values[] = "'" . $this->query_value($this->value_as_string($item->images)) . "'";}
        if (isset($item->images_alts))      {$fields[] = "images_alts";      $values[] = "'" . $this->query_value($this->value_as_string($item->images_alts)) . "'";}
        if (isset($item->images_texts))     {$fields[] = "images_texts";     $values[] = "'" . $this->query_value($this->value_as_string($item->images_texts)) . "'";}
        if (isset($item->images_view))      {$fields[] = "images_view";      $values[] = "'" . $this->query_value($this->value_as_string($item->images_view)) . "'";}
        if (isset($item->date))             {$fields[] = "date";             $values[] = "'" . $this->query_value($this->value_as_date($item->date)) . "'";}
        if (isset($item->tags))             {$fields[] = "tags";             $values[] = "'" . $this->query_value($this->value_as_string($item->tags)) . "'";}
        if (isset($item->created))          {$fields[] = "created";          $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified))         {$fields[] = "modified";         $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        if (isset($item->browsed))          {$fields[] = "browsed";          $values[] = "'" . $this->query_value($this->value_as_natural($item->browsed)) . "'";}
        if (isset($item->rating))           {$fields[] = "rating";           $values[] = "'" . $this->query_value($this->value_as_positive($item->rating)) . "'";}
        if (isset($item->votes))            {$fields[] = "votes";            $values[] = "'" . $this->query_value($this->value_as_natural($item->votes)) . "'";}
        if (isset($item->order_num))        {$fields[] = "order_num";        $values[] = "'" . $this->query_value($this->value_as_integer($item->order_num)) . "'";}
        if (isset($item->section))          {$fields[] = "section";          $values[] = "'" . $this->query_value($this->value_as_integer($item->section)) . "'";}
        $id = $this->update_record($item, "articles", "article_id", $fields, $values);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      return $id;
    }

    // =======================================================================
    // Поправить поля записей о статьях:
    //   $items = массив записей
    // =======================================================================

    public function fix_articles_records (&$items) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB fix_articles_records");

      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_articles_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Поправить поля записи о статье:
    //   $item = запись
    // =======================================================================

    public function fix_articles_record (&$item) {

      // поправляем строковые поля
      if (isset($item->header)) $this->fix_textfield_as_product_name($item->header);

      // поправляем адресующие поля
      if (isset($item->article_id)) {
        $item->article_id = intval($item->article_id);
        if (isset($item->url) && empty($item->url)) $item->url = $item->article_id;
        $item->url_path = (isset($item->url_special) && ($item->url_special == 1)) ? "" : "articles/";
        $item->category_url_path = (isset($item->category_url_special) && ($item->category_url_special == 1)) ? "" : "catalog/";
        $item->brand_url_path = (isset($item->brand_url_special) && ($item->brand_url_special == 1)) ? "" : "brands/";

        // поправляем поле имени администрирующего пользователя
        if (isset($item->user_name) && !empty($item->user_name)) {
          $user = new stdClass;
          $user->name = $item->user_name;
          $this->cms->db->users->unpackUserName($user);
          $item->user_name = $user->compound_name;
        }
      }

      // поправляем поля изображений
      $this->fix_articles_record_images($item);
    }

    // =======================================================================
    // Превратить строки полей изображений записи о статье в массивы:
    //   $item = запись (при отсутствии полей images, images_alts, images_texts, images_view они станут пустыми массивами)
    // =======================================================================

    public function fix_articles_record_images (&$item) {
      $images = array();
      $images_alts = array();
      $images_texts = array();
      $images_view = array();

      // превращаем строки в массивы
      if (isset($item->images) && !empty($item->images)) $images = explode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->images);
      if (isset($item->images_alts) && !empty($item->images_alts)) $images_alts = explode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->images_alts);
      if (isset($item->images_texts) && !empty($item->images_texts)) $images_texts = explode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->images_texts);
      if (isset($item->images_view) && !empty($item->images_view)) $images_view = explode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->images_view);

      // если запись усовершенствована из однокартиночной
      if (isset($item->image)) {
        if (!empty($item->image) && !in_array($item->image, $images)) {
          array_unshift($images, $item->image);
          array_unshift($images_alts, "");
          array_unshift($images_texts, "");
          array_unshift($images_view, 1);
        }
      }

      // если в записи есть поле "главное изображение"
      if (isset($item->large_image)) {
        if (!empty($item->large_image) && !in_array($item->large_image, $images)) {
          array_unshift($images, $item->large_image);
          array_unshift($images_alts, "");
          array_unshift($images_texts, "");
          array_unshift($images_view, 0);
        }
      }

      // перебираем массив имен файлов изображений
      $count = 0;
      $item->images = array();
      $item->images_thumbs = array();
      foreach ($images as &$image) {
        $image = trim($image);
        if (!empty($image)) {
          $item->images[] = $image;
          $item->images_thumbs[] = $this->get_record_images_thumbnail($image);
          $count++;
        }
      }

      // перебираем массив alt-ов изображений
      $count2 = 0;
      $item->images_alts = array();
      foreach ($images_alts as &$image_alt) {
        if ($count2 >= $count) break;
        $image_alt = trim($image_alt);
        $item->images_alts[] = $image_alt;
        $count2++;
      }
      // если не хватает элементов, заполняем недостающие пустыми
      while ($count2 < $count) {
        $item->images_alts[] = "";
        $count2++;
      }

      // перебираем массив описаний изображений
      $count2 = 0;
      $item->images_texts = array();
      foreach ($images_texts as &$image_text) {
        if ($count2 >= $count) break;
        $image_text = trim($image_text);
        $item->images_texts[] = $image_text;
        $count2++;
      }
      // если не хватает элементов, заполняем недостающие пустыми
      while ($count2 < $count) {
        $item->images_texts[] = "";
        $count2++;
      }

      // перебираем массив признаков изображений
      $count2 = 0;
      $item->images_view = array();
      foreach ($images_view as &$image_view) {
        if ($count2 >= $count) break;
        $image_view = ($image_view == 1) ? 1 : 0;
        $item->images_view[] = $image_view;
        $count2++;
      }
      // если не хватает элементов, заполняем недостающие пустыми
      while ($count2 < $count) {
        $item->images_view[] = 1;
        $count2++;
      }
    }

    // =======================================================================
    // Превратить массивы, находящиеся в полях изображений записи о статье,
    // в строки, готовые для передачи в базу данных:
    //   $item = запись (при отсутствии полей images, images_alts, images_texts, images_view они появятся пустыми)
    // =======================================================================

    public function unfix_articles_record_images (&$item) {

      // если не существуют поля изображений, создаем их
      if (!isset($item->images)) $item->images = array();
      if (!isset($item->images_alts)) $item->images_alts = array();
      if (!isset($item->images_texts)) $item->images_texts = array();
      if (!isset($item->images_view)) $item->images_view = array();

      // подсчитываем количество изображений
      $item->images = array_values($item->images);
      $count = count($item->images);

      // возможно эта запись усовершенствована из однокартиночной
      if (!isset($item->image)) {
        $item->image = ($count > 0) ? $item->images[0] : "";
      } elseif (!empty($item->image) && !in_array($item->image, $item->images)) {
        $item->image = "";
      }

      // возможно эта запись имеет поле "главное изображение"
      if (!isset($item->large_image)) {
        $item->large_image = ($count > 0) ? $item->images[0] : "";
      } elseif (!empty($item->large_image) && !in_array($item->large_image, $item->images)) {
        $item->large_image = "";
      }
      $item->small_image = $this->get_record_images_thumbnail($item->large_image);

      // уравниваем размер массива alt-ов изображений по размеру массива имен файлов изображений
      $item->images_alts = array_values($item->images_alts);
      $count2 = count($item->images_alts);
      if ($count2 > $count) $item->images_alts = array_slice($item->images_alts, 0, $count);
      // если не хватает элементов, заполняем недостающие пустыми
      while ($count2 < $count) {
        $item->images_alts[] = "";
        $count2++;
      }

      // уравниваем размер массива описаний изображений по размеру массива имен файлов изображений
      $item->images_texts = array_values($item->images_texts);
      $count2 = count($item->images_texts);
      if ($count2 > $count) $item->images_texts = array_slice($item->images_texts, 0, $count);
      // если не хватает элементов, заполняем недостающие пустыми
      while ($count2 < $count) {
        $item->images_texts[] = "";
        $count2++;
      }

      // уравниваем размер массива признаков изображений по размеру массива имен файлов изображений
      $item->images_view = array_values($item->images_view);
      $count2 = count($item->images_view);
      if ($count2 > $count) $item->images_view = array_slice($item->images_view, 0, $count);
      // если не хватает элементов, заполняем недостающие пустыми
      while ($count2 < $count) {
        $item->images_view[] = 1;
        $count2++;
      }

      // превращаем массивы в строки
      if (is_array($item->images)) $item->images = implode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->images);
      if (is_array($item->images_alts)) $item->images_alts = implode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->images_alts);
      if (is_array($item->images_texts)) $item->images_texts = implode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->images_texts);
      if (is_array($item->images_view)) $item->images_view = implode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->images_view);
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу статей в базе данных.
    // =======================================================================

    private function check_database_articles () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_articles");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "articles";
      $dbtable_field = "article_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "DROP PRIMARY KEY";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT";
      }
      if (!isset($columns["menu_id"])) {
        $query[] = "ADD menu_id BIGINT(20) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (menu_id)";
      }
      if (!isset($columns["objects"])) {
        $query[] = "ADD objects VARCHAR(512) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["category_id"])) {
        $query[] = "ADD category_id BIGINT(20) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (category_id)";
      }
      if (!isset($columns["brand_id"])) {
        $query[] = "ADD brand_id BIGINT(20) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (brand_id)";
      }
      if (!isset($columns["user_id"])) {
        $query[] = "ADD user_id BIGINT(" . DATABASE_USERS_FIELDSIZE_ID . ") DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (user_id)";
      }
      if (!isset($columns["enabled"])) {
        $query[] = "ADD enabled TINYINT(1) DEFAULT '1' NOT NULL";
        $query[] = "ADD INDEX (enabled)";
      }
      if (!isset($columns["highlighted"])) {
        $query[] = "ADD highlighted TINYINT(1) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (highlighted)";
      }
      if (!isset($columns["listed"])) {
        $query[] = "ADD listed TINYINT(1) DEFAULT '1' NOT NULL";
      }
      if (!isset($columns["commented"])) {
        $query[] = "ADD commented TINYINT(1) DEFAULT '1' NOT NULL";
      }
      if (!isset($columns["hidden"])) {
        $query[] = "ADD hidden TINYINT(1) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (hidden)";
      }
      if (!isset($columns["rss_disabled"])) {
        $query[] = "ADD rss_disabled TINYINT(1) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (rss_disabled)";
      }
      if (!isset($columns["export_disabled"])) {
        $query[] = "ADD export_disabled TINYINT(1) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (export_disabled)";
      }
      if (!isset($columns["url"])) {
        $query[] = "ADD url VARCHAR(256) DEFAULT '' NOT NULL";
        $query[] = "ADD INDEX (url)";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET url = " . $dbtable_field . " "
                    . "WHERE url = '' OR url IS NULL;";
      }
      if (!isset($columns["url_special"])) {
        $query[] = "ADD url_special TINYINT(1) DEFAULT '0' NOT NULL";
      }
      if (!isset($columns["meta_title"])) {
        $query[] = "ADD meta_title VARCHAR(256) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["meta_keywords"])) {
        $query[] = "ADD meta_keywords VARCHAR(512) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["meta_description"])) {
        $query[] = "ADD meta_description VARCHAR(512) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["header"])) {
        $query[] = "ADD header VARCHAR(512) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["annotation"])) {
        $query[] = "ADD annotation TEXT DEFAULT '' NOT NULL";
      }
      if (!isset($columns["body"])) {
        $query[] = "ADD body LONGTEXT DEFAULT '' NOT NULL";
      }
      if (!isset($columns["seo_description"])) {
        $query[] = "ADD seo_description TEXT DEFAULT '' NOT NULL";
      }
      if (!isset($columns["images"])) {
        $query[] = "ADD images TEXT DEFAULT '' NOT NULL";
      }
      if (!isset($columns["images_alts"])) {
        $query[] = "ADD images_alts TEXT DEFAULT '' NOT NULL";
      }
      if (!isset($columns["images_texts"])) {
        $query[] = "ADD images_texts LONGTEXT DEFAULT '' NOT NULL";
      }
      if (!isset($columns["images_view"])) {
        $query[] = "ADD images_view TEXT DEFAULT '' NOT NULL";
      }
      if (!isset($columns["date"])) {
        $query[] = "ADD date DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL";
      }
      if (!isset($columns["tags"])) {
        $query[] = "ADD tags VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Теги записи'";
        $query[] = "ADD INDEX (tags)";
      }
      if (!isset($columns["created"])) {
        $query[] = "ADD created DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL";
      }
      if (!isset($columns["modified"])) {
        $query[] = "ADD modified DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL";
      }
      if (!isset($columns["browsed"])) {
        $query[] = "ADD browsed INT(11) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (browsed)";
      }
      if (!isset($columns["rating"])) {
        $query[] = "ADD rating FLOAT(12,2) DEFAULT '0.00' NOT NULL";
      }
      if (!isset($columns["votes"])) {
        $query[] = "ADD votes INT(11) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (votes)";
      }
      if (!isset($columns["order_num"])) {
        $query[] = "ADD order_num INT(11) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (order_num)";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET order_num = " . $dbtable_field . " "
                    . "WHERE order_num <= 0 OR order_num IS NULL;";
      }
      if (!isset($columns["section"])) {
        $query[] = "ADD section INT(11) DEFAULT '1' NOT NULL";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }










    // =======================================================================
    // Выбрать из базы данных записи о медиафайлах согласно параметрам (опциональные взяты в квадратные скобки):
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->ids] = идентификаторы медиафайлов (перечисленные через запятую)
    //   [$params->section] = раздел магазина
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->hidden] = признак "скрыта от чужих"
    //   [$params->filed] = с загруженными файлами
    //   [$params->menu_id] = идентификатор меню
    //   [$params->browsed] = просмотренные
    //   [$params->SEOed] = с SEO текстом
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_files (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_files");

      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_FILES_MODE_BY_HEADER:
            $order = "files.header ASC, "
                   . "menu ASC, "
                   . "files.order_num DESC ";
            break;
          case SORT_FILES_MODE_BY_CREATED:
            $order = "files.created DESC, "
                   . "menu ASC, "
                   . "files.order_num DESC ";
            break;
          case SORT_FILES_MODE_BY_MODIFIED:
            $order = "files.modified DESC, "
                   . "menu ASC, "
                   . "files.order_num DESC ";
            break;
          case SORT_FILES_MODE_BY_BROWSED:
            $order = "browsed DESC, "
                   . "menu ASC, "
                   . "files.order_num DESC ";
            break;
          case SORT_FILES_MODE_BY_URL:
            $order = "files.url ASC, "
                   . "menu ASC, "
                   . "files.order_num DESC ";
          case SORT_FILES_MODE_BY_MENU:
          case SORT_FILES_MODE_AS_IS:
          default:
            $order = "menu ASC, "
                   . "files.order_num DESC ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND files.file_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if (isset($params->section)) $where .= "AND files.section = '" . $this->query_value($params->section) . "' ";
      if (isset($params->enabled)) $where .= "AND files.enabled = '" . $this->query_value($params->enabled) . "' ";
      if (isset($params->hidden)) $where .= "AND files.hidden = '" . $this->query_value($params->hidden) . "' ";
      if (isset($params->filed)) $where .= "AND TRIM(REPLACE(files.files, '" . $this->query_value(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER) . "', '')) != '' ";
      if (isset($params->menu_id)) $where .= "AND files.menu_id = '" . $this->query_value($params->menu_id) . "' ";
      if (isset($params->browsed)) $where .= "AND ABS(files.browsed) != 0 ";
      if (isset($params->SEOed)) $where .= "AND TRIM(files.seo_description) != '' ";
      if ($where != "") $where = "WHERE 1 " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS files.*, "
                                        . "ABS(files.browsed) AS browsed, "
                                        . DATABASE_MENUS_TABLENAME . ".name AS menu, "
                                        . "DATE_FORMAT(files.modified, '%Y-%m-%d %H:%i') AS date, "
                                        . "DATE_FORMAT(files.modified, '%Y-%m-%d') AS date_date, "
                                        . "DATE_FORMAT(files.modified, '%H:%i') AS date_time "
             . "FROM files "
             . "LEFT JOIN " . DATABASE_MENUS_TABLENAME . " "
                       . "ON " . DATABASE_MENUS_TABLENAME . ".menu_id = files.menu_id "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о медиафайле, указанном в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->name] = название медиафайла в меню
    //   [$params->header] = заголовок страницы медиафайла
    //   [$params->menu_id] = идентификатор меню
    //   [$params->section] = раздел магазина
    //   [$params->url] = адрес страницы записи
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->hidden] = признак "скрыта от чужих"
    // =======================================================================

    public function get_file (&$item, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_file");

      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND files.file_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND files.name = '" . $this->query_value($params->name) . "' ";
      if (isset($params->header)) $where .= "AND files.header = '" . $this->query_value($params->header) . "' ";
      if (isset($params->url)) $where .= "AND files.url = '" . $this->query_value($params->url) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND files.section_id != '" . $this->query_value($params->exclude_id) . "' ";
        if (isset($params->menu_id)) $where .= "AND files.menu_id = '" . $this->query_value($params->menu_id) . "' ";
        if (isset($params->section)) $where .= "AND files.section = '" . $this->query_value($params->section) . "' ";
        if (isset($params->enabled)) $where .= "AND files.enabled = '" . $this->query_value($params->enabled) . "' ";
        if (isset($params->hidden)) $where .= "AND files.hidden = '" . $this->query_value($params->hidden) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT files.*, "
                      . "ABS(files.browsed) AS browsed, "
                      . "DATE_FORMAT(files.modified, '%Y-%m-%d %H:%i') AS date, "
                      . "DATE_FORMAT(files.modified, '%Y-%m-%d') AS date_date, "
                      . "DATE_FORMAT(files.modified, '%H:%i') AS date_time "
               . "FROM files "
               . $where
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_files_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Добавить в записи о медиафайлах оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_files (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_files");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->file_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "Files",
                             REQUEST_PARAM_NAME_ITEMID => $item->file_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "поднять выше"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEUP;
            $item->move_up_get = $this->parent->form_get($options);
            // создаем ссылку "опустить ниже"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEDOWN;
            $item->move_down_get = $this->parent->form_get($options);
            // создаем ссылку "поставить первым"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEFIRST;
            $item->move_first_get = $this->parent->form_get($options);
            // создаем ссылку "поставить последним"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVELAST;
            $item->move_last_get = $this->parent->form_get($options);
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "скрыта от чужих"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_HIDDEN;
            $item->hidden_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "File";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о медиафайле в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_file (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_file");

      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->menu_id))          {$fields[] = "menu_id";          $values[] = "'" . $this->query_value($this->value_as_integer($item->menu_id)) . "'";}
        if (isset($item->enabled))          {$fields[] = "enabled";          $values[] = "'" . $this->query_value($this->value_as_boolean($item->enabled)) . "'";}
        if (isset($item->hidden))           {$fields[] = "hidden";           $values[] = "'" . $this->query_value($this->value_as_boolean($item->hidden)) . "'";}
        if (isset($item->url))              {$fields[] = "url";              $values[] = "'" . $this->query_value($this->value_as_string($item->url)) . "'";}
        if (isset($item->meta_title))       {$fields[] = "meta_title";       $values[] = "'" . $this->query_value($this->value_as_string($item->meta_title)) . "'";}
        if (isset($item->meta_keywords))    {$fields[] = "meta_keywords";    $values[] = "'" . $this->query_value($this->value_as_string($item->meta_keywords)) . "'";}
        if (isset($item->meta_description)) {$fields[] = "meta_description"; $values[] = "'" . $this->query_value($this->value_as_string($item->meta_description)) . "'";}
        if (isset($item->name))             {$fields[] = "name";             $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->header))           {$fields[] = "header";           $values[] = "'" . $this->query_value($this->value_as_string($item->header)) . "'";}
        if (isset($item->description))      {$fields[] = "description";      $values[] = "'" . $this->query_value($this->value_as_string($item->description)) . "'";}
        if (isset($item->seo_description))  {$fields[] = "seo_description";  $values[] = "'" . $this->query_value($this->value_as_string($item->seo_description)) . "'";}
        if (isset($item->files))            {$fields[] = "files";            $values[] = "'" . $this->query_value($this->value_as_string($item->files)) . "'";}
        if (isset($item->files_alts))       {$fields[] = "files_alts";       $values[] = "'" . $this->query_value($this->value_as_string($item->files_alts)) . "'";}
        if (isset($item->files_texts))      {$fields[] = "files_texts";      $values[] = "'" . $this->query_value($this->value_as_string($item->files_texts)) . "'";}
        if (isset($item->tags))             {$fields[] = "tags";             $values[] = "'" . $this->query_value($this->value_as_string($item->tags)) . "'";}
        if (isset($item->created))          {$fields[] = "created";          $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified))         {$fields[] = "modified";         $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        if (isset($item->browsed))          {$fields[] = "browsed";          $values[] = "'" . $this->query_value($this->value_as_natural($item->browsed)) . "'";}
        if (isset($item->order_num))        {$fields[] = "order_num";        $values[] = "'" . $this->query_value($this->value_as_integer($item->order_num)) . "'";}
        if (isset($item->section))          {$fields[] = "section";          $values[] = "'" . $this->query_value($this->value_as_integer($item->section)) . "'";}
        $id = $this->update_record($item, "files", "file_id", $fields, $values);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      return $id;
    }

    // =======================================================================
    // Поправить поля записей о медиафайлах:
    //   $items = массив записей
    // =======================================================================

    public function fix_files_records (&$items) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB fix_files_records");

      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_files_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Поправить поля записи о медиафайле:
    //   $item = запись
    // =======================================================================

    public function fix_files_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);
      if (isset($item->header)) $this->fix_textfield_as_product_name($item->header);

      // поправляем адресующие поля
      if (isset($item->file_id)) {
        $item->file_id = intval($item->file_id);
        if (isset($item->url) && empty($item->url)) $item->url = $item->file_id;
      }

      // поправляем поля файлов
      $this->fix_files_record_files($item);
    }

    // =======================================================================
    // Превратить строки полей файлов записи о медиафайле в массивы:
    //   $item = запись (при отсутствии полей files, files_alts, files_texts они станут пустыми массивами)
    // =======================================================================

    public function fix_files_record_files (&$item) {
      $files = array();
      $files_alts = array();
      $files_texts = array();

      // превращаем строки в массивы
      if (isset($item->files) && !empty($item->files)) $files = explode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->files);
      if (isset($item->files_alts) && !empty($item->files_alts)) $files_alts = explode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->files_alts);
      if (isset($item->files_texts) && !empty($item->files_texts)) $files_texts = explode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->files_texts);

      // перебираем массив имен файлов
      $count = 0;
      $item->files = array();
      foreach ($files as &$file) {
        $file = trim($file);
        if (!empty($file)) {
          $item->files[] = $file;
          $count++;
        }
      }

      // перебираем массив alt-ов файлов
      $count2 = 0;
      $item->files_alts = array();
      foreach ($files_alts as &$file_alt) {
        if ($count2 >= $count) break;
        $file_alt = trim($file_alt);
        $item->files_alts[] = $file_alt;
        $count2++;
      }
      // если не хватает элементов, заполняем недостающие пустыми
      while ($count2 < $count) {
        $item->files_alts[] = "";
        $count2++;
      }

      // перебираем массив описаний файлов
      $count2 = 0;
      $item->files_texts = array();
      foreach ($files_texts as &$file_text) {
        if ($count2 >= $count) break;
        $image_text = trim($file_text);
        $item->files_texts[] = $file_text;
        $count2++;
      }
      // если не хватает элементов, заполняем недостающие пустыми
      while ($count2 < $count) {
        $item->files_texts[] = "";
        $count2++;
      }
    }

    // =======================================================================
    // Превратить массивы, находящиеся в полях файлов записи о медиафайле,
    // в строки, готовые для передачи в базу данных:
    //   $item = запись (при отсутствии полей files, files_alts, files_texts они появятся пустыми)
    // =======================================================================

    public function unfix_files_record_files (&$item) {

      // если не существуют поля файлов, создаем их
      if (!isset($item->files)) $item->files = array();
      if (!isset($item->files_alts)) $item->files_alts = array();
      if (!isset($item->files_texts)) $item->files_texts = array();

      // подсчитываем количество файлов
      $item->files = array_values($item->files);
      $count = count($item->files);

      // уравниваем размер массива alt-ов файлов по размеру массива имен файлов
      $item->files_alts = array_values($item->files_alts);
      $count2 = count($item->files_alts);
      if ($count2 > $count) $item->files_alts = array_slice($item->files_alts, 0, $count);
      // если не хватает элементов, заполняем недостающие пустыми
      while ($count2 < $count) {
        $item->files_alts[] = "";
        $count2++;
      }

      // уравниваем размер массива описаний файлов по размеру массива имен файлов
      $item->files_texts = array_values($item->files_texts);
      $count2 = count($item->files_texts);
      if ($count2 > $count) $item->files_texts = array_slice($item->files_texts, 0, $count);
      // если не хватает элементов, заполняем недостающие пустыми
      while ($count2 < $count) {
        $item->files_texts[] = "";
        $count2++;
      }

      // превращаем массивы в строки
      if (is_array($item->files)) $item->files = implode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->files);
      if (is_array($item->files_alts)) $item->files_alts = implode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->files_alts);
      if (is_array($item->files_texts)) $item->files_texts = implode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->files_texts);
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу медиафайлов в базе данных.
    // =======================================================================

    private function check_database_files () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_files");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "files";
      $dbtable_field = "file_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "DROP PRIMARY KEY";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT";
      }
      if (!isset($columns["menu_id"])) {
        $query[] = "ADD menu_id BIGINT(20) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (menu_id)";
      }
      if (!isset($columns["enabled"])) {
        $query[] = "ADD enabled TINYINT(1) DEFAULT '1' NOT NULL";
        $query[] = "ADD INDEX (enabled)";
      }
      if (!isset($columns["hidden"])) {
        $query[] = "ADD hidden TINYINT(1) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (hidden)";
      }
      if (!isset($columns["url"])) {
        $query[] = "ADD url VARCHAR(256) DEFAULT '' NOT NULL";
        $query[] = "ADD INDEX (url)";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET url = " . $dbtable_field . " "
                    . "WHERE url = '' OR url IS NULL;";
      }
      if (!isset($columns["meta_title"])) {
        $query[] = "ADD meta_title VARCHAR(256) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["meta_keywords"])) {
        $query[] = "ADD meta_keywords VARCHAR(512) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["meta_description"])) {
        $query[] = "ADD meta_description VARCHAR(512) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(256) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["header"])) {
        $query[] = "ADD header VARCHAR(512) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["description"])) {
        $query[] = "ADD description TEXT DEFAULT '' NOT NULL";
      }
      if (!isset($columns["seo_description"])) {
        $query[] = "ADD seo_description TEXT DEFAULT '' NOT NULL";
      }
      if (!isset($columns["files"])) {
        $query[] = "ADD files TEXT DEFAULT '' NOT NULL";
      }
      if (!isset($columns["files_alts"])) {
        $query[] = "ADD files_alts TEXT DEFAULT '' NOT NULL";
      }
      if (!isset($columns["files_texts"])) {
        $query[] = "ADD files_texts LONGTEXT DEFAULT '' NOT NULL";
      }
      if (!isset($columns["tags"])) {
        $query[] = "ADD tags VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Теги записи'";
        $query[] = "ADD INDEX (tags)";
      }
      if (!isset($columns["created"])) {
        $query[] = "ADD created DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL";
      }
      if (!isset($columns["modified"])) {
        $query[] = "ADD modified DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL";
      }
      if (!isset($columns["browsed"])) {
        $query[] = "ADD browsed INT(11) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (browsed)";
      }
      if (!isset($columns["order_num"])) {
        $query[] = "ADD order_num INT(11) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (order_num)";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET order_num = " . $dbtable_field . " "
                    . "WHERE order_num <= 0 OR order_num IS NULL;";
      }
      if (!isset($columns["section"])) {
        $query[] = "ADD section INT(11) DEFAULT '1' NOT NULL";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Выбрать из базы данных записи о меню согласно параметрам (опциональные взяты в квадратные скобки):
    //   $items = результат будет помещен в эту переменную
    //   [$params->mode] = режим возврата результата
    //   [$params->sort] = способ сортировки записей
    //   [$params->ids] = идентификаторы меню (перечисленные через запятую)
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->hidden] = признак "скрыта от чужих"
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_menus (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_menus");

      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_MENUS_MODE_BY_NAME:
            $order = DATABASE_MENUS_TABLENAME . ".name ASC ";
            break;
          case SORT_MENUS_MODE_AS_IS:
          default:
            $order = DATABASE_MENUS_TABLENAME . ".menu_id DESC ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND " . DATABASE_MENUS_TABLENAME . ".menu_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if (isset($params->enabled)) $where .= "AND " . DATABASE_MENUS_TABLENAME . ".enabled = '" . $this->query_value($params->enabled) . "' ";
      if (isset($params->hidden)) $where .= "AND " . DATABASE_MENUS_TABLENAME . ".hidden = '" . $this->query_value($params->hidden) . "' ";
      if ($where != "") $where = "WHERE 1 " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS " . DATABASE_MENUS_TABLENAME . ".* "
             . "FROM " . DATABASE_MENUS_TABLENAME . " "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      if (!empty($result)) {
        while ($row = $this->fetch_object($result)) {
          if (!empty($row)) {
            if (isset($params->mode) && ($params->mode === GET_MENUS_MODE_INDEXED_BY_NAME)) {
              if (isset($row->name)) {
                $name = strtolower(trim($row->name));
                if (!empty($name)) $items[$name] = $row;
              }
            } else {
              if (isset($row->menu_id)) $items[$row->menu_id] = $row;
            }
          }
        }
      }

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о меню, указанном в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->name] = название меню
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->hidden] = признак "скрыта от чужих"
    // =======================================================================

    public function get_menu (&$item, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_menu");

      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND " . DATABASE_MENUS_TABLENAME . ".menu_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND " . DATABASE_MENUS_TABLENAME . ".name = '" . $this->query_value($params->name) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND " . DATABASE_MENUS_TABLENAME . ".menu_id != '" . $this->query_value($params->exclude_id) . "' ";
        if (isset($params->enabled)) $where .= "AND " . DATABASE_MENUS_TABLENAME . ".enabled = '" . $this->query_value($params->enabled) . "' ";
        if (isset($params->hidden)) $where .= "AND " . DATABASE_MENUS_TABLENAME . ".hidden = '" . $this->query_value($params->hidden) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT " . DATABASE_MENUS_TABLENAME . ".* "
               . "FROM " . DATABASE_MENUS_TABLENAME . " "
               . $where
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_menus_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }



    // =======================================================================
    // Кешировать усеченную в размерах таблицу меню (Menus ShortVersion)
    // =======================================================================

    public function caching_menus_sv () {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB caching_menus_sv');

        // формируем SELECT (без вступительного слова SELECT и закрывающего ;)
        $select = '`menu_id`, '
                . '`name` '
        . 'FROM `' . DATABASE_MENUS_TABLENAME . '`';

        // формируем список объявлений индексов
        $indexes = 'INDEX (`menu_id`), '
                 . 'INDEX (`name`)';

        // кешируем результаты запроса (разрешаем в памяти, так как таблица небольшая и не содержит BLOB/TEXT колонок)
        $this->caching_SELECT($select,
                              DATABASE_MENUS_TABLENAME,
                              $indexes,
                              DATABASE_CACHE_MENUS_SHORTVERSION_TABLENAME,
                              DATABASE_CACHE_MENUS_SHORTVERSION_LIFETIME,
                              TRUE);

        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }



    // =======================================================================
    // Очистка кеш-таблицы меню и зависимых кешей:
    //   [$item] = обрабатывавшаяся запись (содержащая меняемые поля)
    // =======================================================================

    public function reset_menus_caches (&$item = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB reset_menus_caches");

      // если просят очистить безусловно или изменения в самом деле критичны
      if (is_null($item) || ((!isset($item->indifferent_caches) || !$item->indifferent_caches)
                             && (!isset($item->menu_id) || isset($item->name)))) {

        // очищаем нужные кеш-таблицы
        $tables = DATABASE_CACHE_MENUS_SHORTVERSION_TABLENAME . ", "
                . DATABASE_CACHE_CATEGORIES_TABLENAME . ", "
                . DATABASE_CACHE_BRANDS_TABLENAME;
        $this->reset_dbtables($tables);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Добавить в записи о меню оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_menus (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_menus");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->menu_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "Menus",
                             REQUEST_PARAM_NAME_ITEMID => $item->menu_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "скрыта от чужих"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_HIDDEN;
            $item->hidden_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "Menu";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о меню в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_menu (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_menu");

      $id = "";
      if (!empty($item)) {

        // готовим изменившиеся поля
        $fields = array(); $values = array();
        if (isset($item->menu_id)) {$fields[] = "menu_id"; $values[] = "'" . $this->query_value($this->value_as_integer($item->menu_id)) . "'";}
        if (isset($item->name))    {$fields[] = "name";    $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->enabled)) {$fields[] = "enabled"; $values[] = "'" . $this->query_value($this->value_as_boolean($item->enabled)) . "'";}
        if (isset($item->hidden))  {$fields[] = "hidden";  $values[] = "'" . $this->query_value($this->value_as_boolean($item->hidden)) . "'";}

        // обновляем / добавляем запись
        $id = $this->update_record($item, DATABASE_MENUS_TABLENAME, "menu_id", $fields, $values);

        // если выполнено
        if (!empty($id)) {

          // проверяем необходимость очистить кеш-таблицы меню
          $this->reset_menus_caches($item);
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем идентификатор обновленной / добавленной записи
      return $id;
    }

    // =======================================================================
    // Поправить поля записей о меню:
    //   $items = массив записей
    // =======================================================================

    public function fix_menus_records (&$items) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB fix_menus_records");

      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_menus_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Поправить поля записи о меню:
    //   $item = запись
    // =======================================================================

    public function fix_menus_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);
    }



    // ===================================================================
    /**
    *  Заполнение таблицы минимально необходимыми записями
    *
    *  @access  private
    *  @return  void
    */
    // ===================================================================

    private function setup_menus () {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB setup_menus');



        // создаем перечень минимально необходимых записей
        $records = array();
        $records[] = array('id' => 2, 'name' => 'Верхнее меню');



        // читаем список имеющихся записей
        $query = 'SELECT menu_id '
               . 'FROM ' . DATABASE_MENUS_TABLENAME . ';';
        $result = $this->query($query);
        $items = $this->results();



        // освобождаем память от запроса
        $this->free_result($result);



        // готовим результат для циклического перебора
        if (!empty($items)) {
            foreach ($items as & $item) $item = intval($item->menu_id);
        } else {
            $items = array();
        }



        // просматриваем перечень необходимых записей
        foreach ($records as & $record) {
            $value = $record['id'];



            // перебираем имеющиеся записи и сравниваем с необходимой
            foreach ($items as & $item) {
                if ($item == $value) continue 2;
            }



            // необходимая запись не найдена, добавляем ее
            $value = new stdClass;
            $value->menu_id = $record['id'];
            $value->name = $record['name'];
            $value->enabled = 1;
                // приказываем вставить запись (не искать и пытаться обновить запись с таким ИД, а именно вставить)
                $value->do_insert_operation = TRUE;
            $this->update_menu($value);
        }



        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }



    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу меню в базе данных.
    // =======================================================================

    private function check_database_menu () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_menu");

      // предполагаем, что потребуется перепроверка таблиц базы данных
      $result = FALSE;

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = DATABASE_MENUS_TABLENAME;
      $dbtable_field = "menu_id";
      $columns = $this->get_dbtable_fields($dbtable);
      $query = array();
      $subquery = array();

      // проверяем наличие столбца Рестартер
      $name = "restarter";
      $type = "INT(11)";
      $lifetime = (DATABASE_RECHECKING_LIFETIME > SECONDS_IN_DAY) ? SECONDS_IN_DAY : ((DATABASE_RECHECKING_LIFETIME < 0) ? 0 : DATABASE_RECHECKING_LIFETIME);
      $time = time();
      $params = " " . $name . " " . $type . " DEFAULT '" . intval($time + $lifetime) . "' NOT NULL COMMENT 'Рестартер контроля таблиц'";
      if ((($command = $this->check_field($columns, $name, $type)) != "") || !isset($columns[$name]["Default"])) {
        $query[] = $command . $params;

      // иначе уточняем нужна ли перепроверка таблиц
      } else {
        $nexttime = intval($columns[$name]["Default"]);
        $result = ($nexttime >= $time) && ($nexttime <= ($time + $lifetime));
        if (!$result) $query[] = "CHANGE " . $name . $params;
      }

      // проверяем наличие столбца Версификатор
      $name = "versifier";
      $type = "INT(11)";
      $version = intval(IMPERA_CMS_CURRENT_VERSION);
      $params = " " . $name . " " . $type . " DEFAULT '" . $version . "' NOT NULL COMMENT 'Версификатор контроля таблиц'";
      if ((($command = $this->check_field($columns, $name, $type)) != "") || !isset($columns[$name]["Default"])) {
        $result = FALSE;
        $query[] = $command . $params;

      // иначе уточняем нужна ли перепроверка таблиц
      } else {
        $result2 = intval($columns[$name]["Default"]) == $version;
        if (!$result2) $query[] = "CHANGE " . $name . $params;
        $result = $result && $result2;
      }

      // если таблица не существовала, создаем
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(" . DATABASE_MENUS_FIELDSIZE_ID . ") NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(" . DATABASE_MENUS_FIELDSIZE_ID . ") NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(" . DATABASE_MENUS_FIELDSIZE_ID . ") NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор меню'";
      } else {

        // идентификатор меню
        $name = $dbtable_field;
        $type = "BIGINT(" . DATABASE_MENUS_FIELDSIZE_ID . ")";
        if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор меню'";
      }

      // название
      $name = "name";
      $type = "VARCHAR(" . DATABASE_MENUS_FIELDSIZE_NAME . ")";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Название меню'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // разрешено
      $name = "enabled";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '1' NOT NULL COMMENT 'Разрешена ли запись к использованию'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // скрыто от чужих
      $name = "hidden";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Признак Скрыто от незарегистрированных пользователей'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // если таблица не существовала, проверяем наличие минимально необходимых записей
      if (empty($columns)) $this->setup_menus();

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем ПРОПУСТИТЬ / НЕ ПРОПУСКАТЬ перепроверку таблиц
      return $result;
    }

    // =======================================================================
    // Выбрать из базы данных записи о зарегистрированных модулях:
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->ids] = идентификаторы модулей (перечисленные через запятую)
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->valuable] = признак "разрешен для специальных страниц"
    //   [$params->plugin] = признак "это плагин"
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_modules (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_modules");

      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_MODULES_MODE_BY_NAME:
            $order = "ORDER BY modules.name ASC ";
            break;
          case SORT_MODULES_MODE_BY_CLASS:
            $order = "ORDER BY modules.class ASC ";
            break;
          case SORT_MODULES_MODE_BY_FILENAME:
            $order = "ORDER BY modules.filename ASC, "
                            . "modules.class ASC ";
            break;
          case SORT_MODULES_MODE_AS_IS:
          default:
            $order = "ORDER BY modules.module_id DESC ";
        }
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND modules.module_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if (isset($params->enabled)) $where .= "AND modules.enabled = '" . $this->query_value($params->enabled) . "' ";
      if (isset($params->valuable)) $where .= "AND modules.valuable = '" . $this->query_value($params->valuable) . "' ";
      if (isset($params->plugin)) $where .= "AND modules.plugin = '" . $this->query_value($params->plugin) . "' ";
      if ($where != "") $where = "WHERE 1 " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS modules.* "
             . "FROM modules "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о зарегистрированном модуле, указанном в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->name] = название модуля
    //   [$params->class] = класс модуля
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->valuable] = признак "разрешен для специальных страниц"
    //   [$params->plugin] = признак "это плагин"
    // =======================================================================

    public function get_module (&$item, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_module");

      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND modules.module_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND modules.name = '" . $this->query_value($params->name) . "' ";
      if (isset($params->class)) $where .= "AND modules.class = '" . $this->query_value($params->class) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND modules.module_id != '" . $this->query_value($params->exclude_id) . "' ";
        if (isset($params->enabled)) $where .= "AND modules.enabled = '" . $this->query_value($params->enabled) . "' ";
        if (isset($params->valuable)) $where .= "AND modules.valuable = '" . $this->query_value($params->valuable) . "' ";
        if (isset($params->plugin)) $where .= "AND modules.plugin = '" . $this->query_value($params->plugin) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT modules.* "
               . "FROM modules "
               . $where
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_modules_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Добавить в записи о зарегистрированных модулях оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_modules (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_modules");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->module_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "Modules",
                             REQUEST_PARAM_NAME_ITEMID => $item->module_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "разрешен для специальных страниц"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_VALUABLE;
            $item->valuable_get = $this->parent->form_get($options);
            // создаем ссылку "это плагин"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_PLUGIN;
            $item->plugin_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "Module";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о зарегистрированном модуле в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_module (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_module");

      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->name))        {$fields[] = "name";        $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->class))       {$fields[] = "class";       $values[] = "'" . $this->query_value($this->value_as_string($item->class)) . "'";}
        if (isset($item->filename))    {$fields[] = "filename";    $values[] = "'" . $this->query_value($this->value_as_string($item->filename)) . "'";}
        if (isset($item->description)) {$fields[] = "description"; $values[] = "'" . $this->query_value($this->value_as_string($item->description)) . "'";}
        if (isset($item->enabled))     {$fields[] = "enabled";     $values[] = "'" . $this->query_value($this->value_as_boolean($item->enabled)) . "'";}
        if (isset($item->valuable))    {$fields[] = "valuable";    $values[] = "'" . $this->query_value($this->value_as_boolean($item->valuable)) . "'";}
        if (isset($item->plugin))      {$fields[] = "plugin";      $values[] = "'" . $this->query_value($this->value_as_boolean($item->plugin)) . "'";}
        $id = $this->update_record($item, "modules", "module_id", $fields, $values);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      return $id;
    }

    // =======================================================================
    // Поправить поля записей о зарегистрированных модулях:
    //   $items = массив записей
    // =======================================================================

    public function fix_modules_records (&$items) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB fix_modules_records");

      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_modules_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Поправить поля записи о зарегистрированном модуле:
    //   $item = запись
    // =======================================================================

    public function fix_modules_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);
    }

    // =======================================================================
    // Заполнить таблицу зарегистрированных модулей минимально необходимыми записями.
    // =======================================================================

    private function setup_modules () {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB setup_modules');

        // создаем перечень минимально необходимых записей
        $records = array();
        $records[] = array('class' => 'StaticPage',     'name' => 'Статическая страница',         'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль формирует статические (информационные) и некоторые специальные страницы.');
        $records[] = array('class' => 'Account',        'name' => 'Аккаунт пользователя',         'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль формирует страницу личного кабинета (аккаунта) зарегистрированного пользователя сайта.');
        $records[] = array('class' => 'Login',          'name' => 'Авторизация пользователя',     'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль предоставляет механизм авторизации пользователей сайта.');
        $records[] = array('class' => 'Logout',         'name' => 'Выход пользователя',           'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль выхода пользователя из состояния авторизации.');
        $records[] = array('class' => 'LoginRemind',    'name' => 'Забыли пароль?',               'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль восстановления пароля входа на сайт.');
        $records[] = array('class' => 'Registration',   'name' => 'Регистрация пользователя',     'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль предоставляет механизм регистрации пользователей на сайте.');
        $records[] = array('class' => 'Feedback',       'name' => 'Обратная связь',               'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль обеспечивает прием сообщений от пользователей сайта и функции переписки в личном кабинете (аккаунте) зарегистрированного пользователя.');
        $records[] = array('class' => 'CallMe',         'name' => 'Позвоните мне',                'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль обеспечивает прием запросов связи от пользователей сайта.');
        $records[] = array('class' => 'NotifyMe',       'name' => 'Уведомите меня',               'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль обеспечивает подключение пользователей сайта к системе уведомлений о новинках сайта, появлении товара в наличии, слежении за товаром.');
        $records[] = array('class' => 'Search',         'name' => 'Поиск',                        'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль предоставляет функцию поиска на сайте.');
        $records[] = array('class' => 'Catalog',        'name' => 'Каталог товаров',              'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль формирует страницу каталога товаров.');
        $records[] = array('class' => 'Products',       'name' => 'Список товаров',               'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль формирует страницу списка товаров.');
        $records[] = array('class' => 'Product',        'name' => 'Страница товара',              'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль формирует страницу товара.');
        $records[] = array('class' => 'ProductsKits',   'name' => 'Список комплектов товаров',    'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль формирует страницу списка комплектов товаров.');
        $records[] = array('class' => 'ProductsKit',    'name' => 'Страница комплекта товаров',   'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль формирует страницу комплекта товаров.');
        $records[] = array('class' => 'Countries',      'name' => 'Список стран',                 'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль формирует страницу списка стран.');
        $records[] = array('class' => 'Country',        'name' => 'Страница страны',              'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль формирует страницу страны.');
        $records[] = array('class' => 'Regions',        'name' => 'Список областей',              'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль формирует страницу списка областей.');
        $records[] = array('class' => 'Region',         'name' => 'Страница области',             'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль формирует страницу области.');
        $records[] = array('class' => 'Towns',          'name' => 'Список городов',               'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль формирует страницу списка городов.');
        $records[] = array('class' => 'Town',           'name' => 'Страница города',              'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль формирует страницу города.');
        $records[] = array('class' => 'Articles',       'name' => 'Список статей',                'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль формирует страницы статей и их списков.');
        $records[] = array('class' => 'News',           'name' => 'Список новостей',              'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль формирует страницу списка новостей.');
        $records[] = array('class' => 'NewsItem',       'name' => 'Страница новости',             'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль формирует страницу новости.');
        $records[] = array('class' => 'Stocks',         'name' => 'Список складов',               'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль формирует страницу списка складов.');
        $records[] = array('class' => 'Stock',          'name' => 'Страница склада',              'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль формирует страницу склада.');
        $records[] = array('class' => 'Files',          'name' => 'Список медиа файлов',          'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль формирует страницы медиа файлов и страницу их списка. Под медиа файлом подразумевается некий набор файлов, предназначенных для свободного скачивания пользователем сайта.');
        $records[] = array('class' => 'Cart',           'name' => 'Корзина',                      'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль обеспечивает работу покупательской корзины.');
        $records[] = array('class' => 'Order',          'name' => 'Оформление заказа',            'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль предоставляет механизм формирования заказа пользователем сайта.');
        $records[] = array('class' => 'FulminantOrder', 'name' => 'Мгновенный заказ',             'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль обеспечивает прием от пользователя мгновенного заказа (покупка единственного товара без укладывания в корзину).');
        $records[] = array('class' => 'Configurator',   'name' => 'Конфигуратор, Быстрый заказ',  'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль предоставляет механизм заказа с одной страницы сайта, где перечислены все товары (быстрый заказ) или определенный их набор (конфигуратор).');
        $records[] = array('class' => 'Pricelist',      'name' => 'Прайс-лист',                   'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль формирует прайс-листы и генерирует виртуальный YML-файл для поисковой системы Яндекс.');
        $records[] = array('class' => 'Compare',        'name' => 'Сравнение товаров',            'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль обеспечивает работу страницы сравнения товаров.');
        $records[] = array('class' => 'Import',         'name' => 'Импорт данных',                'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль обслуживает прием данных от внешних источников через обозначенные точки (адреса) доступа к сайту.');
        $records[] = array('class' => 'Sitemap',        'name' => 'Карта сайта',                  'valuable' => 1, 'plugin' => 0, 'description' => 'Модуль обеспечивает работу внутренней карты сайта и генерацию виртуального файла карты для поисковых систем.');
        $records[] = array('class' => 'Rss',            'name' => 'RSS лента новинок, Информеры', 'valuable' => 0, 'plugin' => 0, 'description' => 'Модуль обеспечивает работу RSS (лента новинок) на сайте и генерацию информеров для внешних сайтов.');

        // читаем список имеющихся записей
        $query = 'SELECT `class` '
               . 'FROM `modules`;';
        $result = $this->query($query);
        $items = $this->results();

        // освобождаем память от запроса
        $this->free_result($result);

        // готовим результат для циклического перебора
        if (!empty($items)) {
            foreach ($items as & $item) $item = strtolower(trim($item->class));
        } else {
            $items = array();
        }

        // просматриваем перечень необходимых записей
        foreach ($records as & $record) {
            $value = strtolower($record['class']);

            // перебираем имеющиеся записи и сравниваем с необходимой
            foreach ($items as & $item) {
                if ($item == $value) continue 2;
            }

            // необходимая запись не найдена, добавляем ее
            $value = new stdClass;
            $value->name = $record['name'];
            $value->class = $record['class'];
            $value->filename = '';
            $value->description = $record['description'];
            $value->enabled = 1;
            $value->valuable = $record['valuable'];
            $value->plugin = $record['plugin'];
            $this->update_module($value);
        }

        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу зарегистрированных модулей в базе данных.
    // =======================================================================

    private function check_database_modules () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_modules");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "modules";
      $dbtable_field = "module_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "DROP PRIMARY KEY";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(256) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["class"])) {
        $query[] = "ADD class VARCHAR(256) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["filename"])) {
        $query[] = "ADD filename VARCHAR(256) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["description"])) {
        $query[] = "ADD description VARCHAR(8192) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["enabled"])) {
        $query[] = "ADD enabled TINYINT(1) DEFAULT '1' NOT NULL";
        $query[] = "ADD INDEX (enabled)";
      }
      if (!isset($columns["valuable"])) {
        $query[] = "ADD valuable TINYINT(1) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (valuable)";
      }
      if (!isset($columns["plugin"])) {
        $query[] = "ADD plugin TINYINT(1) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (plugin)";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // проверяем наличие минимально необходимых записей
      $this->setup_modules();

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }



















    // =======================================================================
    // Выбрать из базы данных записи о запретах доступа согласно параметрам (опциональные взяты в квадратные скобки):
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->ids] = идентификаторы запретов доступа (перечисленные через запятую)
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->no_access] = признак "блокировать доступ к клиентской стороне"
    //   [$params->no_register] = признак "блокировать регистрации"
    //   [$params->no_comment] = признак "блокировать комментарии"
    //   [$params->no_callme] = признак "блокировать запросы связи"
    //   [$params->no_admin] = признак "блокировать доступ к админпанели"
    //   [$params->attempted] = с попытками доступа
    //   [$params->date] = признак проверки вхождения текущей даты во время действия запрета
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_banneds (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_banneds");

      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_BANNEDS_MODE_BY_IP:
            $order = "banneds.ip ASC ";
            break;
          case SORT_BANNEDS_MODE_BY_MODIFIED:
            $order = "banneds.modified DESC ";
            break;
          case SORT_BANNEDS_MODE_BY_ATTEMPTS:
            $order = "attempts DESC, "
                   . "banneds.attempts_date DESC ";
            break;
          case SORT_BANNEDS_MODE_BY_CREATED:
          case SORT_BANNEDS_MODE_AS_IS:
          default:
            $order = "banneds.created DESC ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND banneds.ban_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if (isset($params->enabled)) $where .= "AND banneds.enabled = '" . $this->query_value($params->enabled) . "' ";
      if (isset($params->no_access)) $where .= "AND banneds.no_access = '" . $this->query_value($params->no_access) . "' ";
      if (isset($params->no_register)) $where .= "AND banneds.no_register = '" . $this->query_value($params->no_register) . "' ";
      if (isset($params->no_comment)) $where .= "AND banneds.no_comment = '" . $this->query_value($params->no_comment) . "' ";
      if (isset($params->no_callme)) $where .= "AND banneds.no_callme = '" . $this->query_value($params->no_callme) . "' ";
      if (isset($params->no_admin)) $where .= "AND banneds.no_admin = '" . $this->query_value($params->no_admin) . "' ";
      if (isset($params->attempted)) $where .= "AND ABS(banneds.attempts) != 0 ";
      if (isset($params->date)) {
        $time = date("Y-m-d H:i:s", time());
        $where .= "AND (banneds.begin_date = '0000-00-00 00:00:00' OR STR_TO_DATE('" . $time . "', '%Y-%m-%d %H:%i:%s') >= banneds.begin_date) "
                . "AND (banneds.end_date = '0000-00-00 00:00:00' OR STR_TO_DATE('" . $time . "', '%Y-%m-%d %H:%i:%s') <= banneds.end_date) ";
      }
      if ($where != "") $where = "WHERE 1 " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS banneds.*, "
                                        . "ABS(banneds.attempts) AS attempts "
             . "FROM banneds "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о запрете доступа, указанном в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->ip] = IP-адрес
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->no_access] = признак "блокировать доступ к клиентской стороне"
    //   [$params->no_register] = признак "блокировать регистрации"
    //   [$params->no_comment] = признак "блокировать комментарии"
    //   [$params->no_callme] = признак "блокировать запросы связи"
    //   [$params->no_admin] = признак "блокировать доступ к админпанели"
    //   [$params->date] = признак проверки вхождения текущей даты во время действия запрета
    // =======================================================================

    public function get_banned (&$item, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_banned");

      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND banneds.ban_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->ip)) $where .= "AND banneds.ip = '" . $this->query_value($params->ip) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND banneds.ban_id != '" . $this->query_value($params->exclude_id) . "' ";
        if (isset($params->enabled)) $where .= "AND banneds.enabled = '" . $this->query_value($params->enabled) . "' ";
        if (isset($params->no_access)) $where .= "AND banneds.no_access = '" . $this->query_value($params->no_access) . "' ";
        if (isset($params->no_register)) $where .= "AND banneds.no_register = '" . $this->query_value($params->no_register) . "' ";
        if (isset($params->no_comment)) $where .= "AND banneds.no_comment = '" . $this->query_value($params->no_comment) . "' ";
        if (isset($params->no_callme)) $where .= "AND banneds.no_callme = '" . $this->query_value($params->no_callme) . "' ";
        if (isset($params->no_admin)) $where .= "AND banneds.no_admin = '" . $this->query_value($params->no_admin) . "' ";
        if (isset($params->date)) {
          $time = @ date('Y-m-d H:i:s', time());
          $where .= "AND (banneds.begin_date = '0000-00-00 00:00:00' OR STR_TO_DATE('" . $time . "', '%Y-%m-%d %H:%i:%s') >= banneds.begin_date) "
                  . "AND (banneds.end_date = '0000-00-00 00:00:00' OR STR_TO_DATE('" . $time . "', '%Y-%m-%d %H:%i:%s') <= banneds.end_date) ";
        }
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT banneds.*, "
                      . "ABS(banneds.attempts) AS attempts "
               . "FROM banneds "
               . $where
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_banneds_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Добавить в записи о запретах доступа оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_banneds (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_banneds");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->ban_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "Banneds",
                             REQUEST_PARAM_NAME_ITEMID => $item->ban_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "блокировать доступ к клиентской стороне"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_NOACCESS;
            $item->no_access_get = $this->parent->form_get($options);
            // создаем ссылку "блокировать регистрации"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_NOREGISTER;
            $item->no_register_get = $this->parent->form_get($options);
            // создаем ссылку "блокировать комментарии"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_NOCOMMENT;
            $item->no_comment_get = $this->parent->form_get($options);
            // создаем ссылку "блокировать запросы связи"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_NOCALLME;
            $item->no_callme_get = $this->parent->form_get($options);
            // создаем ссылку "блокировать доступ к админпанели"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_NOADMIN;
            $item->no_admin_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "Banned";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о запрете доступа в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_banned (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_banned");

      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->ip))            {$fields[] = "ip";            $values[] = "'" . $this->query_value($this->value_as_string($item->ip)) . "'";}
        if (isset($item->begin_date))    {$fields[] = "begin_date";    $values[] = "'" . $this->query_value($this->value_as_date($item->begin_date)) . "'";}
        if (isset($item->end_date))      {$fields[] = "end_date";      $values[] = "'" . $this->query_value($this->value_as_date($item->end_date)) . "'";}
        if (isset($item->no_access))     {$fields[] = "no_access";     $values[] = "'" . $this->query_value($this->value_as_boolean($item->no_access)) . "'";}
        if (isset($item->no_register))   {$fields[] = "no_register";   $values[] = "'" . $this->query_value($this->value_as_boolean($item->no_register)) . "'";}
        if (isset($item->no_comment))    {$fields[] = "no_comment";    $values[] = "'" . $this->query_value($this->value_as_boolean($item->no_comment)) . "'";}
        if (isset($item->no_callme))     {$fields[] = "no_callme";     $values[] = "'" . $this->query_value($this->value_as_boolean($item->no_callme)) . "'";}
        if (isset($item->no_admin))      {$fields[] = "no_admin";      $values[] = "'" . $this->query_value($this->value_as_boolean($item->no_admin)) . "'";}
        if (isset($item->remark))        {$fields[] = "remark";        $values[] = "'" . $this->query_value($this->value_as_string($item->remark)) . "'";}
        if (isset($item->enabled))       {$fields[] = "enabled";       $values[] = "'" . $this->query_value($this->value_as_boolean($item->enabled)) . "'";}
        if (isset($item->created))       {$fields[] = "created";       $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified))      {$fields[] = "modified";      $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        if (isset($item->attempts))      {$fields[] = "attempts";      $values[] = "'" . $this->query_value($this->value_as_natural($item->attempts)) . "'";}
        if (isset($item->attempts_date)) {$fields[] = "attempts_date"; $values[] = "'" . $this->query_value($this->value_as_date($item->attempts_date)) . "'";}
        $id = $this->update_record($item, "banneds", "ban_id", $fields, $values);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      return $id;
    }

    // =======================================================================
    // Поправить поля записей о запретах доступа:
    //   $items = массив записей
    // =======================================================================

    public function fix_banneds_records (&$items) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB fix_banneds_records");

      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_banneds_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Поправить поля записи о запрете доступа:
    //   $item = запись
    // =======================================================================

    public function fix_banneds_record (&$item) {

      // поправляем адресующие поля
      if (isset($item->ban_id)) $item->ban_id = intval($item->ban_id);
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу запретов доступа в базе данных.
    // =======================================================================

    private function check_database_banneds () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_banneds");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "banneds";
      $dbtable_field = "ban_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "DROP PRIMARY KEY";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT";
      }
      if (!isset($columns["ip"])) {
        $query[] = "ADD ip VARCHAR(256) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["begin_date"])) {
        $query[] = "ADD begin_date DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL";
      }
      if (!isset($columns["end_date"])) {
        $query[] = "ADD end_date DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL";
      }
      if (!isset($columns["no_access"])) {
        $query[] = "ADD no_access TINYINT(1) DEFAULT '1' NOT NULL";
        $query[] = "ADD INDEX (no_access)";
      }
      if (!isset($columns["no_register"])) {
        $query[] = "ADD no_register TINYINT(1) DEFAULT '1' NOT NULL";
        $query[] = "ADD INDEX (no_register)";
      }
      if (!isset($columns["no_comment"])) {
        $query[] = "ADD no_comment TINYINT(1) DEFAULT '1' NOT NULL";
        $query[] = "ADD INDEX (no_comment)";
      }
      if (!isset($columns["no_callme"])) {
        $query[] = "ADD no_callme TINYINT(1) DEFAULT '1' NOT NULL";
        $query[] = "ADD INDEX (no_callme)";
      }
      if (!isset($columns["no_admin"])) {
        $query[] = "ADD no_admin TINYINT(1) DEFAULT '1' NOT NULL";
        $query[] = "ADD INDEX (no_admin)";
      }
      if (!isset($columns["remark"])) {
        $query[] = "ADD remark TEXT DEFAULT '' NOT NULL";
      }
      if (!isset($columns["enabled"])) {
        $query[] = "ADD enabled TINYINT(1) DEFAULT '1' NOT NULL";
        $query[] = "ADD INDEX (enabled)";
      }
      if (!isset($columns["created"])) {
        $query[] = "ADD created DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL";
      }
      if (!isset($columns["modified"])) {
        $query[] = "ADD modified DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL";
      }
      if (!isset($columns["attempts"])) {
        $query[] = "ADD attempts INT(11) DEFAULT '0' NOT NULL";
        $query[] = "ADD INDEX (attempts)";
      }
      if (!isset($columns["attempts_date"])) {
        $query[] = "ADD attempts_date DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }














    // =======================================================================
    // Выбрать из базы данных записи о стадиях заказа:
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->sort_direction] = направление сортировки
    //   [$params->sort_laconical] = признак лаконичного режима сортировки
    //   [$params->ids] = идентификаторы стадий (перечисленные через запятую)
    //   [$params->deleted] = признак "удалена" запись
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_orders_phases (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_orders_phases");

      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // запоминаем направление сортировки и режим лаконичности
      $direction = (isset($params->sort_direction) && ($params->sort_direction == SORT_DIRECTION_DESCENDING)) ? "DESC " : "ASC ";
      $laconical = !empty($params->sort_laconical);

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_ORDERSPHASES_MODE_BY_NAME:
            $order = DATABASE_ORDERS_PHASES_TABLENAME . ".name " . $direction . ", "
                   . DATABASE_ORDERS_PHASES_TABLENAME . ".created DESC ";
            if ($laconical) $where .= "AND TRIM(" . DATABASE_ORDERS_PHASES_TABLENAME . ".name) != '' ";
            break;
          case SORT_ORDERSPHASES_MODE_BY_MODIFIED:
            $order = DATABASE_ORDERS_PHASES_TABLENAME . ".modified " . $direction . ", "
                   . DATABASE_ORDERS_PHASES_TABLENAME . ".name ASC, "
                   . DATABASE_ORDERS_PHASES_TABLENAME . ".created DESC ";
            if ($laconical) $where .= "AND " . DATABASE_ORDERS_PHASES_TABLENAME . ".modified IS NOT NULL "
                                        . "AND " . DATABASE_ORDERS_PHASES_TABLENAME . ".modified != " . DATABASE_ORDERS_PHASES_TABLENAME . ".created ";
            break;
          case SORT_ORDERSPHASES_MODE_BY_CREATED:
          case SORT_ORDERSPHASES_MODE_AS_IS:
          default:
            $order = DATABASE_ORDERS_PHASES_TABLENAME . ".created " . $direction . ", "
                   . DATABASE_ORDERS_PHASES_TABLENAME . ".name ASC ";
            if ($laconical) $where .= "AND " . DATABASE_ORDERS_PHASES_TABLENAME . ".created IS NOT NULL ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND " . DATABASE_ORDERS_PHASES_TABLENAME . ".phase_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      $where = "WHERE " . DATABASE_ORDERS_PHASES_TABLENAME . ".deleted = '" . (isset($params->deleted) ? $this->query_value($params->deleted) : 0) . "' " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS " . DATABASE_ORDERS_PHASES_TABLENAME . ".* "
             . "FROM " . DATABASE_ORDERS_PHASES_TABLENAME . " "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о стадии заказа, указанной в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->name] = название стадии
    //   [$params->deleted] = признак "удалена" запись
    // =======================================================================

    public function get_orders_phase (&$item, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_orders_phase");

      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND " . DATABASE_ORDERS_PHASES_TABLENAME . ".phase_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND " . DATABASE_ORDERS_PHASES_TABLENAME . ".name = '" . $this->query_value($params->name) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND " . DATABASE_ORDERS_PHASES_TABLENAME . ".phase_id != '" . $this->query_value($params->exclude_id) . "' ";
        $where = "WHERE " . DATABASE_ORDERS_PHASES_TABLENAME . ".deleted = '" . (isset($params->deleted) ? $this->query_value($params->deleted) : 0) . "' " . $where;

        // делаем запрос
        $query = "SELECT " . DATABASE_ORDERS_PHASES_TABLENAME . ".* "
               . "FROM " . DATABASE_ORDERS_PHASES_TABLENAME . " "
               . $where
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_orders_phases_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Очистка кеш-таблицы стадий заказа и зависимых кешей:
    //   [$item] = обрабатывавшаяся запись (содержащая меняемые поля)
    // =======================================================================

    public function reset_orders_phases_caches (&$item = null) {

      // если просят очистить безусловно или изменения в самом деле критичны
      if (is_null($item) || !isset($item->indifferent_caches) || !$item->indifferent_caches) {

        // здесь ничего не делаем (таблица не кешируется)
      }
    }

    // =======================================================================
    // Добавить в записи о стадиях заказа оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_orders_phases (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_orders_phases");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->phase_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "OrdersPhases",
                             REQUEST_PARAM_NAME_ITEMID => $item->phase_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "OrdersPhase";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о стадии заказа в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_orders_phase (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_orders_phase");

      $id = "";
      if (!empty($item)) {

        // готовим изменившиеся поля
        $fields = array(); $values = array();
        if (isset($item->phase_id)) {$fields[] = "phase_id"; $values[] = "'" . $this->query_value($this->value_as_integer($item->phase_id)) . "'";}
        if (isset($item->name))     {$fields[] = "name";     $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->created))  {$fields[] = "created";  $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified)) {$fields[] = "modified"; $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        if (isset($item->deleted))  {$fields[] = "deleted";  $values[] = "'" . $this->query_value($this->value_as_boolean($item->deleted)) . "'";}

        // обновляем / добавляем запись
        $id = $this->update_record($item, DATABASE_ORDERS_PHASES_TABLENAME, "phase_id", $fields, $values);

        // если выполнено
        if (!empty($id)) {

          // проверяем необходимость очистить кеш-таблицы стадий
          $this->reset_orders_phases_caches($item);
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем идентификатор обновленной / добавленной записи
      return $id;
    }

    // =======================================================================
    // Поправить поля записей о стадиях заказа:
    //   $items = массив записей
    // =======================================================================

    public function fix_orders_phases_records (&$items) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB fix_orders_phases_records");

      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_orders_phases_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Поправить поля записи о стадии заказа:
    //   $item = запись
    // =======================================================================

    public function fix_orders_phases_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);

      // поправляем адресующие поля
      if (isset($item->phase_id)) $item->phase_id = intval($item->phase_id);
    }

    // =======================================================================
    // Заполнить таблицу стадий заказа минимально необходимыми записями.
    // =======================================================================

    private function setup_orders_phases () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB setup_orders_phases");

      // создаем перечень минимально необходимых записей
      $records = array();
      $records[] = array("name" => "Ожидает уточнения адреса доставки");
      $records[] = array("name" => "Ожидает уточнения контактных данных");
      $records[] = array("name" => "Ожидает поступления отсутствующего товара");
      $records[] = array("name" => "Ожидает отправку");
      $records[] = array("name" => "Ожидает подтверждения оплаты");
      $records[] = array("name" => "Ожидает оплату");
      $records[] = array("name" => "Передан в комплектацию");
      $records[] = array("name" => "Отправлен почтой");
      $records[] = array("name" => "Отправлен курьером");
      $records[] = array("name" => "Возвращен почтой");
      $records[] = array("name" => "Возвращен курьером");

      // читаем список имеющихся записей
      $query = "SELECT name "
             . "FROM " . DATABASE_ORDERS_PHASES_TABLENAME . ";";
      $result = $this->query($query);
      $items = $this->results();

      // освобождаем память от запроса
      $this->free_result($result);

      // готовим результат для циклического перебора
      if (!empty($items)) {
        foreach ($items as &$item) $item = strtolower(trim($item->name));
      } else {
        $items = array();
      }

      // просматриваем перечень необходимых записей
      foreach ($records as &$record) {
        $value = strtolower($record["name"]);
        // перебираем имеющиеся записи и сравниваем с необходимой
        foreach ($items as &$item) {
          if ($item == $value) continue 2;
        }

        // необходимая запись не найдена, добавляем ее
        $value = new stdClass;
        $value->name = $record["name"];
        $value->deleted = 0;
        $value->created = time();
        $this->update_orders_phase($value);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу стадий заказа в базе данных.
    // =======================================================================

    private function check_database_orders_phases () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_orders_phases");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = DATABASE_ORDERS_PHASES_TABLENAME;
      $dbtable_field = "phase_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(" . DATABASE_ORDERS_PHASES_FIELDSIZE_ID . ") NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(" . DATABASE_ORDERS_PHASES_FIELDSIZE_ID . ") NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(" . DATABASE_ORDERS_PHASES_FIELDSIZE_ID . ") NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор стадии заказа'";
      } else {

        // стадия заказа
        $name = $dbtable_field;
        $type = "BIGINT(" . DATABASE_ORDERS_PHASES_FIELDSIZE_ID . ")";
        if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор стадии заказа'";
      }

      // название
      $name = "name";
      $type = "VARCHAR(" . DATABASE_ORDERS_PHASES_FIELDSIZE_NAME . ")";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Название стадии заказа'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // создано
      $name = "created";
      $type = "DATETIME";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата создания записи'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // изменено
      $name = "modified";
      $type = "DATETIME";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата изменения записи'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // удалена
      $name = "deleted";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Признак Запись удалена'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // если таблица не существовала, проверяем наличие минимально необходимых записей
      if (empty($columns)) $this->setup_orders_phases();

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Выбрать из базы данных записи о свойствах товаров согласно параметрам (опциональные взяты в квадратные скобки):
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->group] = название группы свойств
    //   [$params->ids] = идентификаторы свойств товаров (перечисленные через запятую)
    //   [$params->category_id] = идентификатор категории
    //   [$params->brand_id] = идентификатор бренда
    //   [$params->in_product] = признак "используется в товарах"
    //   [$params->in_filter] = признак "используется в фильтре"
    //   [$params->in_compare] = признак "используется в сравнении"
    //   [$params->optioned] = признак "имеющие возможные значения"
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_properties ( & $items, $params = null ) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB get_properties');

        $items = array();
        $where = '';
        $order = '';
        $limit = '';

        // сортируем указанным способом
        if (isset($params->sort)) {
            switch ($params->sort) {
                case SORT_PROPERTIES_MODE_BY_NAME:
                    $order = '`properties`.`group` ASC, '
                           . '`properties`.`name` ASC, '
                           . '`properties`.`order_num` DESC ';
                    break;
                case SORT_PROPERTIES_MODE_AS_IS:
                default:
                    $order = '`properties`.`order_num` DESC ';
            }
            $order = 'ORDER BY ' . $order;
        }

        // фильтруем по запрошенным параметрам
        if (isset($params->ids) && $params->ids != '') $where .= 'AND `properties`.`property_id` IN ("' . str_replace(',', '","', $this->query_value($params->ids)) . '") ';
        if (isset($params->group)) $where .= 'AND `properties`.`group` = "' . $this->query_value($params->group) . '" ';
        if (isset($params->category_id)) $where .= 'AND (`properties`.`categories` = "' . $this->query_value($params->category_id) . '" '
                                                      . 'OR LOCATE("' . $this->query_value(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER . $params->category_id . IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER) . '", `properties`.`categories`) != 0 '
                                                      . 'OR LEFT(`properties`.`categories`, ' . strlen($this->query_value($params->category_id . IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER)) . ') = "' . $this->query_value($params->category_id . IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER) . '" '
                                                      . 'OR RIGHT(`properties`.`categories`, ' . strlen($this->query_value(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER . $params->category_id)) . ') = "' . $this->query_value(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER . $params->category_id) . '") ';
        if (isset($params->brand_id)) $where .= 'AND (`properties`.`brands` = "' . $this->query_value($params->brand_id) . '" '
                                                   . 'OR LOCATE("' . $this->query_value(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER . $params->brand_id . IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER) . '", `properties`.`brands`) != 0 '
                                                   . 'OR LEFT(`properties`.`brands`, ' . strlen($this->query_value($params->brand_id . IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER)) . ') = "' . $this->query_value($params->brand_id . IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER) . '" '
                                                   . 'OR RIGHT(`properties`.`brands`, ' . strlen($this->query_value(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER . $params->brand_id)) . ') = "' . $this->query_value(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER . $params->brand_id) . '") ';
        if (isset($params->in_product)) $where .= 'AND `properties`.`in_product` = "' . $this->query_value($params->in_product) . '" ';
        if (isset($params->in_filter)) $where .= 'AND `properties`.`in_filter` = "' . $this->query_value($params->in_filter) . '" ';
        if (isset($params->in_compare)) $where .= 'AND `properties`.`in_compare` = "' . $this->query_value($params->in_compare) . '" ';
        if (isset($params->enabled)) $where .= 'AND `properties`.`enabled` = "' . $this->query_value($params->enabled) . '" ';
        if (isset($params->optioned)) $where .= 'AND TRIM(`properties`.`options`) != "" ';
        if ($where != '') $where = 'WHERE 1 ' . $where;

        // формируем параметр LIMIT запроса
        if (isset($params->start) || isset($params->maxcount)) {
            $limit = 'LIMIT ';
            if (isset($params->start)) {
                $params->start = intval($params->start);
                if ($params->start >= 0) $limit .= $params->start . ', ';
            }
            if (isset($params->maxcount)) {
                $params->maxcount = intval($params->maxcount);
                if ($params->maxcount >= 0) $limit .= $params->maxcount;
            }
        }

        // делаем запрос
        $query = 'SELECT SQL_CALC_FOUND_ROWS `properties`.* '
               . 'FROM `properties` '
               . $where
               . $order
               . $limit . ';';
        $result = $this->query($query);

        // заполняем возвращаемый массив результатом запроса, индексируя идентификатором свойства
        if ($result !== FALSE) {
            while ($row = $this->fetch_object($result)) {
                $items[$row->property_id] = $row;
            }
        }

        // берем полное количество подобных записей
        $result2 = $this->query('SELECT FOUND_ROWS() AS `count`;');
        $count = $this->result();
        $count = isset($count->count) ? $count->count : 0;

        // освобождаем память от запроса
        $this->free_result($result);
        $this->free_result($result2);

        // закрываем трассировку этого метода
        $this->close_tracing_method();

        // возвращаем количество записей
        return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о свойстве товара, указанном в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->name] = название свойства товара
    //   [$params->group] = название группы свойств
    //   [$params->in_product] = признак "используется в товарах"
    //   [$params->in_filter] = признак "используется в фильтре"
    //   [$params->in_compare] = признак "используется в сравнении"
    //   [$params->enabled] = признак "разрешена" запись
    // =======================================================================

    public function get_property ( & $item, $params ) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB get_property');

        $item = null;
        $where = '';

        // фильтруем по запрошенным параметрам
        if (isset($params->id) && !empty($params->id)) $where .= 'AND `properties`.`property_id` = "' . $this->query_value($params->id) . '" ';
        if (isset($params->name)) $where .= 'AND `properties`.`name` = "' . $this->query_value($params->name) . '" ';
        if ($where != '') {
            if (isset($params->group)) $where .= 'AND `properties`.`group` = "' . $this->query_value($params->group) . '" ';
            if (isset($params->exclude_id)) $where .= 'AND `properties`.`property_id` != "' . $this->query_value($params->exclude_id) . '" ';
            if (isset($params->in_product)) $where .= 'AND `properties`.`in_product` = "' . $this->query_value($params->in_product) . '" ';
            if (isset($params->in_filter)) $where .= 'AND `properties`.`in_filter` = "' . $this->query_value($params->in_filter) . '" ';
            if (isset($params->in_compare)) $where .= 'AND `properties`.`in_compare` = "' . $this->query_value($params->in_compare) . '" ';
            if (isset($params->enabled)) $where .= 'AND `properties`.`enabled` = "' . $this->query_value($params->enabled) . '" ';
            $where = 'WHERE 1 ' . $where;

            // делаем запрос
            $query = 'SELECT `properties`.* '
                   . 'FROM `properties` '
                   . $where
                   . 'LIMIT 1;';
            $result = $this->query($query);
            $item = $this->result();

            // освобождаем память от запроса
            $this->free_result($result);

            // поправляем поля записи
            if (!empty($item)) $this->fix_properties_record($item);
        }

        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }

    // =======================================================================
    // Актуализация (пометка актуальных) записей свойств согласно списка идентификаторов товаров:
    //   $items = массив записей свойств
    //   $product_ids = массив идентификаторов товаров
    // =======================================================================

    public function actualize_properties (&$items, &$product_ids) {

      // открываем трассировку этого метода
      $this->open_tracing_method('DB actualize_properties');

      if (is_array($items) && !empty($items)
      && is_array($product_ids) && !empty($product_ids)) {

        // запрашиваем список значений свойств указанных товаров
        $query = 'SELECT `properties_values`.`property_id`, '
                      . '`properties_values`.`value`, '
                      . 'COUNT(`properties_values`.`value`) AS `amount` '
               . 'FROM `properties_values` '
               . 'WHERE `properties_values`.`product_id` IN (' . implode(',', $product_ids) . ') '
               . 'GROUP BY `properties_values`.`property_id`, '
                        . '`properties_values`.`value` '
               . 'ORDER BY `property_id`;';
        $result = $this->query($query);

        // перебираем строки результата запроса
        if ($result !== FALSE) {
          while ($row = $this->fetch_object($result)) {
            $id = $row->property_id;
            if (isset($items[$id]->options) && is_array($items[$id]->options)) {

              // ищем значение в записях свойств и помечаем актуальным
              $value = strtolower(trim($row->value));
              foreach ($items[$id]->options as &$option) {
                if (isset($option->value) && strtolower(trim($option->value)) == $value) {
                  $option->actual = TRUE;

                  // запоминаем сколько товаров найдется по такому свойству
                  if (!isset($option->count)) $option->count = 0;
                  $option->count = $row->amount;
                  break;
                }
              }
            }
          }
        }

        // освобождаем память от запроса
        $this->free_result($result);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }



    // =======================================================================
    // Очистка кеш-таблицы свойств и зависимых кешей:
    //   [$item] = обрабатывавшаяся запись (содержащая меняемые поля)
    // =======================================================================

    public function reset_properties_caches ( & $item = null ) {
    }



    // =======================================================================
    // Добавить в записи о свойствах товаров оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_properties (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method('DB operable_properties');

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->property_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => 'Properties',
                             REQUEST_PARAM_NAME_ITEMID => $item->property_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "поднять выше"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEUP;
            $item->move_up_get = $this->parent->form_get($options);
            // создаем ссылку "опустить ниже"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEDOWN;
            $item->move_down_get = $this->parent->form_get($options);
            // создаем ссылку "поставить первым"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEFIRST;
            $item->move_first_get = $this->parent->form_get($options);
            // создаем ссылку "поставить последним"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVELAST;
            $item->move_last_get = $this->parent->form_get($options);
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешено"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "используется в товарах"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_INPRODUCT;
            $item->in_product_get = $this->parent->form_get($options);
            // создаем ссылку "используется в фильтре"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_INFILTER;
            $item->in_filter_get = $this->parent->form_get($options);
            // создаем ссылку "используется в сравнении"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_INCOMPARE;
            $item->in_compare_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = 'Property';
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }



    // =======================================================================
    // Обновить/добавить запись о свойстве товара в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_property ( & $item ) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB update_property');



        $id = '';
        if (!empty($item)) {

            // готовим изменившиеся поля
            $fields = array(); $values = array();
            if (isset($item->sync_id))    {$fields[] = 'sync_id';    $values[] = '\'' . $this->query_value($this->value_as_string($item->sync_id)) . '\'';}
            if (isset($item->group))      {$fields[] = 'group';      $values[] = '\'' . $this->query_value($this->value_as_string($item->group)) . '\'';}
            if (isset($item->name))       {$fields[] = 'name';       $values[] = '\'' . $this->query_value($this->value_as_string($item->name)) . '\'';}
            if (isset($item->in_product)) {$fields[] = 'in_product'; $values[] = '\'' . $this->query_value($this->value_as_boolean($item->in_product)) . '\'';}
            if (isset($item->in_filter))  {$fields[] = 'in_filter';  $values[] = '\'' . $this->query_value($this->value_as_boolean($item->in_filter)) . '\'';}
            if (isset($item->in_compare)) {$fields[] = 'in_compare'; $values[] = '\'' . $this->query_value($this->value_as_boolean($item->in_compare)) . '\'';}
            if (isset($item->enabled))    {$fields[] = 'enabled';    $values[] = '\'' . $this->query_value($this->value_as_boolean($item->enabled)) . '\'';}
            if (isset($item->options))    {$fields[] = 'options';    $values[] = '\'' . $this->query_value($this->value_as_string($this->unfixed_properties_record_options($item))) . '\'';}
            if (isset($item->categories)) {$fields[] = 'categories'; $values[] = '\'' . $this->query_value($this->value_as_string($this->unfixed_properties_record_categories($item))) . '\'';}
            if (isset($item->brands))     {$fields[] = 'brands';     $values[] = '\'' . $this->query_value($this->value_as_string($this->unfixed_properties_record_brands($item))) . '\'';}
            if (isset($item->order_num))  {$fields[] = 'order_num';  $values[] = '\'' . $this->query_value($this->value_as_integer($item->order_num)) . '\'';}
            if (isset($item->created))    {$fields[] = 'created';    $values[] = '\'' . $this->query_value($this->value_as_date($item->created)) . '\'';}
            if (isset($item->modified))   {$fields[] = 'modified';   $values[] = '\'' . $this->query_value($this->value_as_date($item->modified)) . '\'';}



            // обновляем / добавляем запись
            $id = $this->update_record($item, DATABASE_PROPERTIES_TABLENAME, 'property_id', $fields, $values);



            // если выполнено
            if (!empty($id)) {

                // проверяем необходимость очистить кеш-таблицы свойств
                $this->reset_properties_caches($item);
            }
        }



        // закрываем трассировку этого метода
        $this->close_tracing_method();

        // возвращаем идентификатор обновленной / добавленной записи
        return $id;
    }



    // =======================================================================
    // Поправить поля записей о свойствах товаров:
    //   $items = массив записей
    // =======================================================================

    public function fix_properties_records ( & $items ) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB fix_properties_records');

        if (!empty($items)) {
            foreach ($items as & $item) $this->fix_properties_record($item);
        }

        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }



    // =======================================================================
    // Поправить поля записи о свойстве товара:
    //   $item = запись
    // =======================================================================

    public function fix_properties_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);

      // поправляем адресующие поля
      if (isset($item->property_id)) $item->property_id = intval($item->property_id);

      // поправляем поле значений
      if (isset($item->options) && is_string($item->options)) {
        if (trim($item->options) == "") {
          $item->options = array();
        } else {
          $options = & $this->unserialize_data($item->options);
          $item->options = array();
          if (is_array($options)) {
            foreach ($options as &$option) {
              $option = trim($option);
              if ($option != "") $item->options[] = $option;
            }
          }
        }
      }

      // поправляем поле категорий
      if (isset($item->categories) && !is_array($item->categories)) {
        $values = array();
        $item->categories = explode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->categories);
        foreach ($item->categories as $id) {
          if (trim($id) != "") {
            $id = intval($id);
            $values[$id] = $id;
          }
        }
        $item->categories = $values;
      }

      //  поправляем поле брендов
      if (isset($item->brands) && !is_array($item->brands)) {
        $values = array();
        $item->brands = explode(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, $item->brands);
        foreach ($item->brands as $id) {
          if (trim($id) != "") {
            $id = intval($id);
            $values[$id] = $id;
          }
        }
        $item->brands = $values;
      }
    }

    // =======================================================================
    // Возвратить в виде строки массив, находящийся в поле вариантов записи о свойстве товара:
    //   $item = запись
    // =======================================================================

    public function unfixed_properties_record_options (&$item) {
      $result = "";
      if (isset($item->options)) {
        if (is_string($item->options)) return $item->options;
        if (!empty($item->options)) {
          $result = array_values($item->options);
          $result = serialize($result);
        }
      }
      return $result;
    }

    // =======================================================================
    // Возвратить в виде строки массив, находящийся в поле категорий записи о свойстве товара:
    //   $item = запись
    // =======================================================================

    public function unfixed_properties_record_categories (&$item) {
      $result = "";
      if (isset($item->categories)) {
        if (!is_array($item->categories)) return $item->categories;
        foreach ($item->categories as $value) {
          $value = trim(str_replace(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, "", $value));
          if (!empty($value)) {
            if ($result != "") $result .= IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER;
            $result .= $value;
            if (strlen($result) > 8388608) break;
          }
        }
      }
      return $result;
    }

    // =======================================================================
    // Возвратить в виде строки массив, находящийся в поле брендов записи о свойстве товара:
    //   $item = запись
    // =======================================================================

    public function unfixed_properties_record_brands (&$item) {
      $result = "";
      if (isset($item->brands)) {
        if (!is_array($item->brands)) return $item->brands;
        foreach ($item->brands as $value) {
          $value = trim(str_replace(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER, "", $value));
          if (!empty($value)) {
            if ($result != "") $result .= IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER;
            $result .= $value;
            if (strlen($result) > 8388608) break;
          }
        }
      }
      return $result;
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу свойств товаров в базе данных.
    //
    // Связанная с ней таблица properties_categories более не используется, и если
    // она существует, то в записи с незаполненным новым полем categories проверяемой
    // таблицы переносятся соответствующие данные из поля category_id неиспользуемой
    // таблицы. После неиспользуемая таблица удаляется.
    // =======================================================================

    private function check_database_properties () {

      // открываем трассировку этого метода
      $this->open_tracing_method('DB check_database_properties');

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = 'properties';
      $dbtable_field = 'property_id';
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query('CREATE TABLE IF NOT EXISTS `' . $dbtable . '` (`' . $dbtable_field . '` BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;');

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = 'DROP PRIMARY KEY';
        $query[] = 'ADD PRIMARY KEY (`' . $dbtable_field . '`)';
        $query[] = 'CHANGE `' . $dbtable_field . '` `' . $dbtable_field . '` BIGINT(20) NOT NULL AUTO_INCREMENT';
      }

        // синхронизационный ИД
        $name = 'sync_id';
        $type = 'VARCHAR(40)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' `' . $name . '` ' . $type . ' DEFAULT "" NOT NULL COMMENT "Синхронизационный идентификатор"';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // группа
        $name = 'group';
        $type = 'VARCHAR(256)';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' `' . $name . '` ' . $type . ' DEFAULT "" NOT NULL COMMENT "Название группы"';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      if (!isset($columns['name'])) {
        $query[] = 'ADD `name` VARCHAR(256) DEFAULT "" NOT NULL';
        $query[] = 'ADD INDEX (`name`)';
      }
      if (!isset($columns['in_product'])) {
        $query[] = 'ADD `in_product` TINYINT(1) DEFAULT 0 NOT NULL';
        $query[] = 'ADD INDEX (`in_product`)';
      }
      if (!isset($columns['in_filter'])) {
        $query[] = 'ADD `in_filter` TINYINT(1) DEFAULT 0 NOT NULL';
        $query[] = 'ADD INDEX (`in_filter`)';
      }
      if (!isset($columns['in_compare'])) {
        $query[] = 'ADD `in_compare` TINYINT(1) DEFAULT 0 NOT NULL';
        $query[] = 'ADD INDEX (`in_compare`)';
      }
      if (!isset($columns['enabled'])) {
        $query[] = 'ADD `enabled` TINYINT(1) DEFAULT 1 NOT NULL';
        $query[] = 'ADD INDEX (`enabled`)';
      }
      if (!isset($columns['options'])) {
        $query[] = 'ADD `options` TEXT DEFAULT "" NOT NULL';
      }
      if (!isset($columns['categories'])) {
        $query[] = 'ADD `categories` MEDIUMTEXT DEFAULT "" NOT NULL';
      }
      if (!isset($columns['brands'])) {
        $query[] = 'ADD `brands` MEDIUMTEXT DEFAULT "" NOT NULL';
      }
      if (!isset($columns['order_num'])) {
        $query[] = 'ADD `order_num` INT(11) DEFAULT 0 NOT NULL';
        $query[] = 'ADD INDEX (`order_num`)';
        $subquery[] = 'UPDATE `' . $dbtable . '` '
                    . 'SET `order_num` = `' . $dbtable_field . '` '
                    . 'WHERE `order_num` = 0 OR `order_num` IS NULL;';
      }

        // создан
        $name = 'created';
        $type = 'DATETIME';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' `' . $name . '` ' . $type . ' DEFAULT "0000-00-00 00:00:00" NOT NULL COMMENT "Дата создания записи"';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // исправлен
        $name = 'modified';
        $type = 'DATETIME';
        if (($command = $this->check_field($columns, $name, $type)) != '') $query[] = $command . ' `' . $name . '` ' . $type . ' DEFAULT "0000-00-00 00:00:00" NOT NULL COMMENT "Дата изменения записи"';
        if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

        // выполняем сформированные запросы
        foreach ($query as & $command) {
            if (trim($command) != '') {
                $command = 'ALTER TABLE `' . $dbtable . '` ' . $command . ';';
                $this->query($command);
            }
        }
        foreach ($subquery as & $command) {
            if (trim($command) != '') $this->query($command);
        }

      // если существует неиспользуемая более таблица, делаем перенос ее значений
      $columns = $this->get_dbtable_fields($dbtable . '_categories');
      if (isset($columns[$dbtable_field]) && isset($columns['category_id'])) {

        // расширяем объем доступной памяти до 128 Кбайт для GROUP_CONCAT (по умолчанию было бы 1024 байта)
        $query = 'SET group_concat_max_len = 131072;';
        $this->query($query);

        // в строку собираем из неиспользуемой таблицы значения ее поля category_id
        $query = 'SELECT `' . $dbtable_field . '`, '
                      . 'GROUP_CONCAT(DISTINCT `category_id` '
                                   . 'ORDER BY `category_id` ASC '
                                   . 'SEPARATOR "' . $this->query_value(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER) . '") AS `categories` '
                . 'FROM `' . $dbtable . '_categories` '
                . 'GROUP BY `' . $dbtable_field . '`;';
        $result = $this->query($query);
        $items = $this->results();

        // освобождаем память от запроса
        $this->free_result($result);

        // передаем строки в новое предназначенное для этого поле categories, если оно незаполнено
        if (!empty($items)) {
          foreach ($items as & $item) {
            $query = 'UPDATE `' . $dbtable . '` '
                   . 'SET `categories` = "' . $this->query_value($item->categories) . '" '
                   . 'WHERE `' . $dbtable_field . '` = "' . $this->query_value($item->$dbtable_field) . '" '
                         . 'AND TRIM(`categories`) = "";';
            $this->query($query);
          }
        }

        // удаляем неиспользуемую таблицу
        $query = 'DROP TABLE `' . $dbtable . '_categories`;';
        $this->query($query);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу значений свойств товаров в базе данных.
    // =======================================================================

    private function check_database_properties_values () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_properties_values");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = DATABASE_PROPERTIES_VALUES_TABLENAME;
      $dbtable_field = "product_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) DEFAULT '0' NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "DROP PRIMARY KEY";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
      }
      if (!isset($columns["property_id"])) {
        $query[] = "ADD property_id BIGINT(20) DEFAULT '0' NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ", property_id)";
      }
      if (!isset($columns["value"])) {
        $query[] = "ADD value VARCHAR(512) DEFAULT '' NOT NULL";
        $query[] = "ADD INDEX (value)";
      }
      if (!isset($columns["price_plus"])) {
        $query[] = "ADD price_plus VARCHAR(16) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["quantity_plus"])) {
        $query[] = "ADD quantity_plus VARCHAR(16) DEFAULT '' NOT NULL";
      }
      if (!isset($columns["order_num"])) {
        $query[] = "ADD order_num INT(11) DEFAULT '0' NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ", property_id, order_num)";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }






    // =======================================================================
    // Выбрать из базы данных записи о областях:
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->sort_direction] = направление сортировки
    //   [$params->sort_laconical] = признак лаконичного режима сортировки
    //   [$params->ids] = идентификаторы областей (перечисленные через запятую)
    //   [$params->country_id] = идентификатор страны
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->imaged] = с загруженными изображениями
    //   [$params->browsed] = просмотренные
    //   [$params->SEOed] = с SEO текстом
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_regions (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_regions");

      $items = array();
      $where = "";
      $having = "";
      $order = "";
      $limit = "";

      // запоминаем направление сортировки и режим лаконичности
      $direction = (isset($params->sort_direction) && ($params->sort_direction == SORT_DIRECTION_DESCENDING)) ? "DESC " : "ASC ";
      $laconical = !empty($params->sort_laconical);

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_REGIONS_MODE_BY_NAME:
            $order = "regions.name " . $direction . ", "
                   . "country " . $direction . ", "
                   . "regions.order_num DESC ";
            if ($laconical) $where .= "AND TRIM(regions.name) != '' ";
            break;
          case SORT_REGIONS_MODE_BY_URL:
            $order = "regions.url " . $direction;
            if ($laconical) $where .= "AND TRIM(regions.url) != '' ";
            break;
          case SORT_REGIONS_MODE_BY_BROWSED:
            $order = "browsed " . $direction . ", "
                   . "country ASC, "
                   . "regions.name ASC, "
                   . "regions.order_num DESC ";
            if ($laconical) $where .= "AND ABS(regions.browsed) > 0 ";
            break;
          case SORT_REGIONS_MODE_BY_COUNTRIESCOUNT:
            $order = "countries_count " . $direction . ", "
                   . "country ASC, "
                   . "regions.name ASC, "
                   . "regions.order_num DESC ";
            if ($laconical) $having .= "AND COUNT(countries.country_id) > 0 ";
            break;
          case SORT_REGIONS_MODE_BY_TOWNSCOUNT:
            $order = "towns_count " . $direction . ", "
                   . "country ASC, "
                   . "regions.name ASC, "
                   . "regions.order_num DESC ";
            if ($laconical) $having .= "AND COUNT(towns.town_id) > 0 ";
            break;
          case SORT_REGIONS_MODE_BY_USERSCOUNT:
            $order = "users_count " . $direction . ", "
                   . "country ASC, "
                   . "regions.name ASC, "
                   . "regions.order_num DESC ";
            if ($laconical) $having .= "AND COUNT(" . DATABASE_USERS_TABLENAME . ".user_id) > 0 ";
            break;
          case SORT_REGIONS_MODE_BY_ORDERSCOUNT:
            $order = "orders_count " . $direction . ", "
                   . "country ASC, "
                   . "regions.name ASC, "
                   . "regions.order_num DESC ";
            if ($laconical) $having .= "AND COUNT(" . DATABASE_ORDERS_TABLENAME . ".order_id) > 0 ";
            break;
          case SORT_REGIONS_MODE_BY_CREATED:
            $order = "regions.created " . $direction . ", "
                   . "country ASC, "
                   . "regions.name ASC, "
                   . "regions.order_num DESC ";
            if ($laconical) $where .= "AND regions.created IS NOT NULL ";
            break;
          case SORT_REGIONS_MODE_BY_MODIFIED:
            $order = "regions.modified " . $direction . ", "
                   . "country ASC, "
                   . "regions.name ASC, "
                   . "regions.order_num DESC ";
            if ($laconical) $where .= "AND regions.modified IS NOT NULL "
                                        . "AND regions.modified != regions.created ";
            break;
          case SORT_REGIONS_MODE_AS_IS:
          default:
            $order = "regions.order_num DESC ";
            if ($laconical) $where .= "AND TRIM(regions.name) != '' ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND regions.region_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if (isset($params->country_id)) $where .= "AND regions.country_id = '" . $this->query_value($params->country_id) . "' ";
      if (isset($params->enabled)) $where .= "AND regions.enabled = '" . $this->query_value($params->enabled) . "' ";
      if (isset($params->imaged)) $where .= "AND TRIM(REPLACE(regions.images, '" . $this->query_value(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER) . "', '')) != '' ";
      if (isset($params->browsed)) $where .= "AND ABS(regions.browsed) != 0 ";
      if (isset($params->SEOed)) $where .= "AND TRIM(regions.seo_description) != '' ";
      if ($where != "") $where = "WHERE 1 " . $where;
      if ($having != "") $having = "HAVING 1 " . $having;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS regions.*, "
                                        . "countries.name AS country, "
                                        . "countries.phone_code AS country_phone_code, "
                                        . "countries.url AS country_url, "
                                        . "ABS(regions.browsed) AS browsed, "
                                        . "COUNT(DISTINCT countries.country_id) AS countries_count, "
                                        . "COUNT(DISTINCT towns.town_id) AS towns_count, "
                                        . "COUNT(DISTINCT " . DATABASE_USERS_TABLENAME . ".user_id) AS users_count, "
                                        . "COUNT(DISTINCT " . DATABASE_ORDERS_TABLENAME . ".order_id) AS orders_count "
             . "FROM regions "
             . "LEFT JOIN countries "
                       . "ON countries.country_id = regions.country_id "
                          . "AND countries.enabled = 1 "
             . "LEFT JOIN towns "
                       . "ON towns.region_id = regions.region_id "
                          . "AND towns.enabled = 1 "
             . "LEFT JOIN " . DATABASE_USERS_TABLENAME . " "
                       . "ON " . DATABASE_USERS_TABLENAME . ".region_id = regions.region_id "
                          . "AND " . DATABASE_USERS_TABLENAME . ".enabled = 1 "
             . "LEFT JOIN " . DATABASE_ORDERS_TABLENAME . " "
                       . "ON " . DATABASE_ORDERS_TABLENAME . ".region_id = regions.region_id "
             . $where
             . "GROUP BY regions.region_id "
             . $having
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Выбрать из базы данных дерево записей о областях:
    //   $items = результат будет помещен в эту переменную
    //   [$nonempty] = признак "только непустые ветви"
    // =======================================================================

    public function get_regions_tree (&$items, $nonempty = FALSE) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_regions_tree");

      // делаем запрос
      $query = "SELECT countries.country_id, "
                    . "countries.name AS country, "
                    . "countries.url AS country_url, "
                    . "regions.region_id, "
                    . "regions.name, "
                    . "regions.url "
             . "FROM countries "
             . "LEFT JOIN regions "
                       . "ON regions.country_id = countries.country_id "
             . "WHERE countries.enabled = 1 "
                   . "AND TRIM(countries.name) != '' "
                   . "AND " . ($nonempty ? "regions.enabled = 1 " : "(regions.enabled = 1 OR regions.enabled IS NULL) ")
             . "ORDER BY country ASC, "
                      . "regions.name ASC;";
      $result = $this->query($query);

      // строим дерево записей
      $items = array();
      if (!empty($result)) {
        while ($item = $this->fetch_object($result)) {
          $cid = $item->country_id;
          if (!isset($items[$cid])) {
            $value = new stdClass;
            $value->id = $cid;
            $value->name = $item->country;
            $value->url = $item->country_url;
            $value->items = array();
            $items[$cid] = $value;
          }
          if (trim($item->name) != "") {
            $rid = $item->region_id;
            if (!isset($items[$cid]->items[$rid])) {
              $value = new stdClass;
              $value->id = $rid;
              $value->name = $item->name;
              $value->url = $item->url;
              $items[$cid]->items[$rid] = $value;
            }
          }
        }
      }

      // освобождаем память от запроса
      $this->free_result($result);

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Взять из базы данных запись о области, указанной в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->country] = название страны
    //   [$params->country_id] = идентификатор страны
    //   [$params->name] = название области
    //   [$params->town] = название города
    //   [$params->town_id] = идентификатор города
    //   [$params->user_id] = идентификатор пользователя
    //   [$params->order_id] = идентификатор заказа
    //   [$params->url] = адрес страницы записи
    //   [$params->enabled] = признак "разрешена" запись
    // =======================================================================

    public function get_region (&$item, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_region");

      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND regions.region_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND regions.name = '" . $this->query_value($params->name) . "' ";
      if (isset($params->country)) $where .= "AND countries.name = '" . $this->query_value($params->country) . "' ";
      if (isset($params->country_id)) $where .= "AND countries.country_id = '" . $this->query_value($params->country_id) . "' ";
      if (isset($params->town)) $where .= "AND towns.name = '" . $this->query_value($params->town) . "' ";
      if (isset($params->town_id)) $where .= "AND towns.town_id = '" . $this->query_value($params->town_id) . "' ";
      if (isset($params->user_id)) $where .= "AND " . DATABASE_USERS_TABLENAME . ".user_id = '" . $this->query_value($params->user_id) . "' ";
      if (isset($params->order_id)) $where .= "AND " . DATABASE_ORDERS_TABLENAME . ".order_id = '" . $this->query_value($params->order_id) . "' ";
      if (isset($params->url)) $where .= "AND regions.url = '" . $this->query_value($params->url) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND regions.region_id != '" . $this->query_value($params->exclude_id) . "' ";
        if (isset($params->enabled)) $where .= "AND regions.enabled = '" . $this->query_value($params->enabled) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT regions.*, "
                      . "countries.name AS country, "
                      . "countries.phone_code AS country_phone_code, "
                      . "countries.url AS country_url, "
                      . "ABS(regions.browsed) AS browsed, "
                      . "COUNT(DISTINCT countries.country_id) AS countries_count, "
                      . "COUNT(DISTINCT towns.town_id) AS towns_count, "
                      . "COUNT(DISTINCT " . DATABASE_USERS_TABLENAME . ".user_id) AS users_count, "
                      . "COUNT(DISTINCT " . DATABASE_ORDERS_TABLENAME . ".order_id) AS orders_count "
               . "FROM regions "
               . "LEFT JOIN countries "
                         . "ON countries.country_id = regions.country_id "
                            . "AND countries.enabled = 1 "
               . "LEFT JOIN towns "
                         . "ON towns.region_id = regions.region_id "
                            . "AND towns.enabled = 1 "
               . "LEFT JOIN " . DATABASE_USERS_TABLENAME . " "
                         . "ON " . DATABASE_USERS_TABLENAME . ".region_id = regions.region_id "
                            . "AND " . DATABASE_USERS_TABLENAME . ".enabled = 1 "
               . "LEFT JOIN " . DATABASE_ORDERS_TABLENAME . " "
                         . "ON " . DATABASE_ORDERS_TABLENAME . ".region_id = regions.region_id "
               . $where
               . "GROUP BY regions.region_id "
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_regions_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Добавить в записи о областях оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_regions (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_regions");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->region_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "Regions",
                             REQUEST_PARAM_NAME_ITEMID => $item->region_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "поднять выше"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEUP;
            $item->move_up_get = $this->parent->form_get($options);
            // создаем ссылку "опустить ниже"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEDOWN;
            $item->move_down_get = $this->parent->form_get($options);
            // создаем ссылку "поставить первым"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEFIRST;
            $item->move_first_get = $this->parent->form_get($options);
            // создаем ссылку "поставить последним"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVELAST;
            $item->move_last_get = $this->parent->form_get($options);
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "Region";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о области в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_region (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_region");

      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->country_id))       {$fields[] = "country_id";       $values[] = "'" . $this->query_value($this->value_as_integer($item->country_id)) . "'";}
        if (isset($item->enabled))          {$fields[] = "enabled";          $values[] = "'" . $this->query_value($this->value_as_boolean($item->enabled)) . "'";}
        if (isset($item->url))              {$fields[] = "url";              $values[] = "'" . $this->query_value($this->value_as_string($item->url)) . "'";}
        if (isset($item->meta_title))       {$fields[] = "meta_title";       $values[] = "'" . $this->query_value($this->value_as_string($item->meta_title)) . "'";}
        if (isset($item->meta_keywords))    {$fields[] = "meta_keywords";    $values[] = "'" . $this->query_value($this->value_as_string($item->meta_keywords)) . "'";}
        if (isset($item->meta_description)) {$fields[] = "meta_description"; $values[] = "'" . $this->query_value($this->value_as_string($item->meta_description)) . "'";}
        if (isset($item->name))             {$fields[] = "name";             $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->description))      {$fields[] = "description";      $values[] = "'" . $this->query_value($this->value_as_string($item->description)) . "'";}
        if (isset($item->seo_description))  {$fields[] = "seo_description";  $values[] = "'" . $this->query_value($this->value_as_string($item->seo_description)) . "'";}
        if (isset($item->phone_code))       {$fields[] = "phone_code";       $values[] = "'" . $this->query_value($this->value_as_string($item->phone_code)) . "'";}
        if (isset($item->images))           {$fields[] = "images";           $values[] = "'" . $this->query_value($this->value_as_string($item->images)) . "'";}
        if (isset($item->images_alts))      {$fields[] = "images_alts";      $values[] = "'" . $this->query_value($this->value_as_string($item->images_alts)) . "'";}
        if (isset($item->images_texts))     {$fields[] = "images_texts";     $values[] = "'" . $this->query_value($this->value_as_string($item->images_texts)) . "'";}
        if (isset($item->images_view))      {$fields[] = "images_view";      $values[] = "'" . $this->query_value($this->value_as_string($item->images_view)) . "'";}
        if (isset($item->tags))             {$fields[] = "tags";             $values[] = "'" . $this->query_value($this->value_as_string($item->tags)) . "'";}
        if (isset($item->created))          {$fields[] = "created";          $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified))         {$fields[] = "modified";         $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        if (isset($item->browsed))          {$fields[] = "browsed";          $values[] = "'" . $this->query_value($this->value_as_natural($item->browsed)) . "'";}
        if (isset($item->order_num))        {$fields[] = "order_num";        $values[] = "'" . $this->query_value($this->value_as_integer($item->order_num)) . "'";}
        $id = $this->update_record($item, "regions", "region_id", $fields, $values);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      return $id;
    }

    // =======================================================================
    // Поправить поля записей о областях:
    //   $items = массив записей
    // =======================================================================

    public function fix_regions_records (&$items) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB fix_regions_records");

      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_regions_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Поправить поля записи о области:
    //   $item = запись
    // =======================================================================

    public function fix_regions_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);

      // поправляем адресующие поля
      if (isset($item->country_id)) $item->country_id = intval($item->country_id);
      if (isset($item->region_id)) {
        $item->region_id = intval($item->region_id);
        if (isset($item->url) && empty($item->url)) $item->url = $item->region_id;
        $item->url_path = "regions/";
      }

      // поправляем поля изображений
      $this->fix_regions_record_images($item);
    }

    // =======================================================================
    // Превратить строки полей изображений записи о области в массивы:
    //   $item = запись (при отсутствии полей images, images_alts, images_texts, images_view они станут пустыми массивами)
    // =======================================================================

    public function fix_regions_record_images (&$item) {
      $this->fix_articles_record_images($item);
    }

    // =======================================================================
    // Превратить массивы, находящиеся в полях изображений записи о области,
    // в строки, готовые для передачи в базу данных:
    //   $item = запись (при отсутствии полей images, images_alts, images_texts, images_view они появятся пустыми)
    // =======================================================================

    public function unfix_regions_record_images (&$item) {
      $this->unfix_articles_record_images($item);
    }

    // =======================================================================
    // Заполнить таблицу областей минимально необходимыми записями.
    // =======================================================================

    private function setup_regions () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB setup_regions");

      // создаем перечень минимально необходимых записей
      $records = array();
      $records[] = array("country" => "Украина", "name" => "АР Крым");
      $records[] = array("country" => "Украина", "name" => "Винницкая область");
      $records[] = array("country" => "Украина", "name" => "Волынская область");
      $records[] = array("country" => "Украина", "name" => "Днепропетровская область");
      $records[] = array("country" => "Украина", "name" => "Донецкая область");
      $records[] = array("country" => "Украина", "name" => "Житомирская область");
      $records[] = array("country" => "Украина", "name" => "Закарпатская область");
      $records[] = array("country" => "Украина", "name" => "Запорожская область");
      $records[] = array("country" => "Украина", "name" => "Ивано-Франковская область");
      $records[] = array("country" => "Украина", "name" => "Киевская область");
      $records[] = array("country" => "Украина", "name" => "Кировоградская область");
      $records[] = array("country" => "Украина", "name" => "Луганская область");
      $records[] = array("country" => "Украина", "name" => "Львовская область");
      $records[] = array("country" => "Украина", "name" => "Николаевская область");
      $records[] = array("country" => "Украина", "name" => "Одесская область");
      $records[] = array("country" => "Украина", "name" => "Полтавская область");
      $records[] = array("country" => "Украина", "name" => "Ровенская область");
      $records[] = array("country" => "Украина", "name" => "Сумская область");
      $records[] = array("country" => "Украина", "name" => "Тернопольская область");
      $records[] = array("country" => "Украина", "name" => "Харьковская область");
      $records[] = array("country" => "Украина", "name" => "Херсонская область");
      $records[] = array("country" => "Украина", "name" => "Хмельницкая область");
      $records[] = array("country" => "Украина", "name" => "Черкасская область");
      $records[] = array("country" => "Украина", "name" => "Черниговская область");
      $records[] = array("country" => "Украина", "name" => "Черновицкая область");

      // читаем список имеющихся записей
      $query = "SELECT countries.name AS country, "
                    . "regions.name "
             . "FROM regions "
             . "LEFT JOIN countries "
                       . "ON countries.country_id = regions.country_id;";
      $result = $this->query($query);
      $items = $this->results();

      // освобождаем память от запроса
      $this->free_result($result);

      // читаем список имеющихся стран
      $query = "SELECT country_id, "
                    . "name "
             . "FROM countries;";
      $result = $this->query($query);
      $countries = $this->results();

      // освобождаем память от запроса
      $this->free_result($result);

      // готовим результат для циклического перебора
      if (!empty($items)) {
        foreach ($items as &$item) {
          $item->country = strtolower(trim($item->country));
          $item->name = strtolower(trim($item->name));
        }
      } else {
        $items = array();
      }

      // готовим страны для циклического перебора
      if (!empty($countries)) {
        foreach ($countries as &$item) {
          $item->name = strtolower(trim($item->name));
        }
      } else {
        $countries = array();
      }

      // просматриваем перечень необходимых записей
      foreach ($records as &$record) {
        $country = strtolower($record["country"]);
        $region = strtolower($record["name"]);

        // перебираем имеющиеся записи и сравниваем с необходимой
        foreach ($items as &$item) {
          if (($item->country == $country) && ($item->name == $region)) continue 2;
        }

        // ищем идентификатор страны
        $id = 0;
        foreach ($countries as &$item) {
          if ($item->name == $country) {
            $id = $item->country_id;
            break;
          }
        }
        if (empty($id)) continue;

        // необходимая запись не найдена, добавляем ее
        $value = new stdClass;
        $value->name = $record["name"];
        $value->country_id = $id;
        $value->enabled = 1;
        $value->created = time();
        $this->update_region($value);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу областей в базе данных.
    // =======================================================================

    private function check_database_regions () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_regions");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "regions";
      $dbtable_field = "region_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(20) NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор области'";
      }
      if (!isset($columns["country_id"])) {
        $query[] = "ADD country_id BIGINT(20) DEFAULT '0' NOT NULL COMMENT 'Идентификатор страны'";
        $query[] = "ADD INDEX (country_id)";
      }
      if (!isset($columns["enabled"])) {
        $query[] = "ADD enabled TINYINT(1) DEFAULT '1' NOT NULL COMMENT 'Разрешена ли запись к использованию'";
        $query[] = "ADD INDEX (enabled)";
      }
      if (!isset($columns["url"])) {
        $query[] = "ADD url VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Адрес страницы записи'";
        $query[] = "ADD INDEX (url)";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET url = " . $dbtable_field . " "
                    . "WHERE url = '' OR url IS NULL;";
      }
      if (!isset($columns["meta_title"])) {
        $query[] = "ADD meta_title VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Мета заголовок страницы записи'";
      }
      if (!isset($columns["meta_keywords"])) {
        $query[] = "ADD meta_keywords VARCHAR(512) DEFAULT '' NOT NULL COMMENT 'Мета ключевые слова страницы записи'";
      }
      if (!isset($columns["meta_description"])) {
        $query[] = "ADD meta_description VARCHAR(512) DEFAULT '' NOT NULL COMMENT 'Мета описание страницы записи'";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Название области'";
        $query[] = "ADD INDEX (name)";
      }
      if (!isset($columns["description"])) {
        $query[] = "ADD description TEXT DEFAULT '' NOT NULL COMMENT 'Описание области'";
      }
      if (!isset($columns["seo_description"])) {
        $query[] = "ADD seo_description TEXT DEFAULT '' NOT NULL COMMENT 'SEO текст'";
      }
      if (!isset($columns["phone_code"])) {
        $query[] = "ADD phone_code VARCHAR(16) DEFAULT '' NOT NULL COMMENT 'Телефонный стационарный код области'";
        $query[] = "ADD INDEX (phone_code)";
      }
      if (!isset($columns["images"])) {
        $query[] = "ADD images TEXT DEFAULT '' NOT NULL COMMENT 'Изображения записи'";
      }
      if (!isset($columns["images_alts"])) {
        $query[] = "ADD images_alts TEXT DEFAULT '' NOT NULL COMMENT 'Подписи изображений записи'";
      }
      if (!isset($columns["images_texts"])) {
        $query[] = "ADD images_texts LONGTEXT DEFAULT '' NOT NULL COMMENT 'Описания изображений записи'";
      }
      if (!isset($columns["images_view"])) {
        $query[] = "ADD images_view TEXT DEFAULT '' NOT NULL COMMENT 'Признаки использования в слайдере изображений записи'";
      }
      if (!isset($columns["tags"])) {
        $query[] = "ADD tags VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Теги записи'";
        $query[] = "ADD INDEX (tags)";
      }
      if (!isset($columns["created"])) {
        $query[] = "ADD created DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата создания записи'";
        $query[] = "ADD INDEX (created)";
      }
      if (!isset($columns["modified"])) {
        $query[] = "ADD modified DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата изменения записи'";
        $query[] = "ADD INDEX (modified)";
      }
      if (!isset($columns["browsed"])) {
        $query[] = "ADD browsed INT(11) DEFAULT '0' NOT NULL COMMENT 'Количество просмотров записи'";
        $query[] = "ADD INDEX (browsed)";
      }
      if (!isset($columns["order_num"])) {
        $query[] = "ADD order_num INT(11) DEFAULT '0' NOT NULL COMMENT 'Порядковый номер записи'";
        $query[] = "ADD INDEX (order_num)";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET order_num = " . $dbtable_field . " "
                    . "WHERE order_num = 0 OR order_num IS NULL;";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // если таблица не существовала, проверяем наличие минимально необходимых записей
      if (empty($columns)) $this->setup_regions();

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Выбрать из базы данных записи о городах:
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->sort_direction] = направление сортировки
    //   [$params->sort_laconical] = признак лаконичного режима сортировки
    //   [$params->ids] = идентификаторы городов (перечисленные через запятую)
    //   [$params->country_id] = идентификатор страны
    //   [$params->region_id] = идентификатор области
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->imaged] = с загруженными изображениями
    //   [$params->browsed] = просмотренные
    //   [$params->SEOed] = с SEO текстом
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_towns (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_towns");

      $items = array();
      $where = "";
      $having = "";
      $order = "";
      $limit = "";

      // запоминаем направление сортировки и режим лаконичности
      $direction = (isset($params->sort_direction) && ($params->sort_direction == SORT_DIRECTION_DESCENDING)) ? "DESC " : "ASC ";
      $laconical = !empty($params->sort_laconical);

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_TOWNS_MODE_BY_NAME:
            $order = "country " . $direction . ", "
                   . "region " . $direction . ", "
                   . "towns.name " . $direction . ", "
                   . "towns.order_num DESC ";
            if ($laconical) $where .= "AND TRIM(towns.name) != '' ";
            break;
          case SORT_TOWNS_MODE_BY_URL:
            $order = "towns.url " . $direction;
            if ($laconical) $where .= "AND TRIM(towns.url) != '' ";
            break;
          case SORT_TOWNS_MODE_BY_BROWSED:
            $order = "browsed " . $direction . ", "
                   . "country ASC, "
                   . "region ASC, "
                   . "towns.name ASC, "
                   . "towns.order_num DESC ";
            if ($laconical) $where .= "AND ABS(towns.browsed) > 0 ";
            break;
          case SORT_TOWNS_MODE_BY_COUNTRIESCOUNT:
            $order = "countries_count " . $direction . ", "
                   . "country ASC, "
                   . "region ASC, "
                   . "towns.name ASC, "
                   . "towns.order_num DESC ";
            if ($laconical) $having .= "AND COUNT(countries.country_id) > 0 ";
            break;
          case SORT_TOWNS_MODE_BY_REGIONSCOUNT:
            $order = "regions_count " . $direction . ", "
                   . "country ASC, "
                   . "region ASC, "
                   . "towns.name ASC, "
                   . "towns.order_num DESC ";
            if ($laconical) $having .= "AND COUNT(regions.region_id) > 0 ";
            break;
          case SORT_TOWNS_MODE_BY_USERSCOUNT:
            $order = "users_count " . $direction . ", "
                   . "country ASC, "
                   . "region ASC, "
                   . "towns.name ASC, "
                   . "towns.order_num DESC ";
            if ($laconical) $having .= "AND COUNT(" . DATABASE_USERS_TABLENAME . ".user_id) > 0 ";
            break;
          case SORT_TOWNS_MODE_BY_ORDERSCOUNT:
            $order = "orders_count " . $direction . ", "
                   . "country ASC, "
                   . "region ASC, "
                   . "towns.name ASC, "
                   . "towns.order_num DESC ";
            if ($laconical) $having .= "AND COUNT(" . DATABASE_ORDERS_TABLENAME . ".order_id) > 0 ";
            break;
          case SORT_TOWNS_MODE_BY_CREATED:
            $order = "towns.created " . $direction . ", "
                   . "country ASC, "
                   . "region ASC, "
                   . "towns.name ASC, "
                   . "towns.order_num DESC ";
            if ($laconical) $where .= "AND towns.created IS NOT NULL ";
            break;
          case SORT_TOWNS_MODE_BY_MODIFIED:
            $order = "towns.modified " . $direction . ", "
                   . "country ASC, "
                   . "region ASC, "
                   . "towns.name ASC, "
                   . "towns.order_num DESC ";
            if ($laconical) $where .= "AND towns.modified IS NOT NULL "
                                        . "AND towns.modified != towns.created ";
            break;
          case SORT_TOWNS_MODE_AS_IS:
          default:
            $order = "country ASC, "
                   . "region ASC, "
                   . "towns.order_num DESC ";
            if ($laconical) $where .= "AND TRIM(towns.name) != '' ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND towns.town_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if (isset($params->country_id)) $where .= "AND towns.country_id = '" . $this->query_value($params->country_id) . "' ";
      if (isset($params->region_id)) $where .= "AND towns.region_id = '" . $this->query_value($params->region_id) . "' ";
      if (isset($params->enabled)) $where .= "AND towns.enabled = '" . $this->query_value($params->enabled) . "' ";
      if (isset($params->imaged)) $where .= "AND TRIM(REPLACE(towns.images, '" . $this->query_value(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER) . "', '')) != '' ";
      if (isset($params->browsed)) $where .= "AND ABS(towns.browsed) != 0 ";
      if (isset($params->SEOed)) $where .= "AND TRIM(towns.seo_description) != '' ";
      if ($where != "") $where = "WHERE 1 " . $where;
      if ($having != "") $having = "HAVING 1 " . $having;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS towns.*, "
                                        . "countries.name AS country, "
                                        . "countries.phone_code AS country_phone_code, "
                                        . "countries.url AS country_url, "
                                        . "regions.name AS region, "
                                        . "regions.phone_code AS region_phone_code, "
                                        . "regions.url AS region_url, "
                                        . "ABS(towns.browsed) AS browsed, "
                                        . "COUNT(DISTINCT countries.country_id) AS countries_count, "
                                        . "COUNT(DISTINCT regions.region_id) AS regions_count, "
                                        . "COUNT(DISTINCT " . DATABASE_USERS_TABLENAME . ".user_id) AS users_count, "
                                        . "COUNT(DISTINCT " . DATABASE_ORDERS_TABLENAME . ".order_id) AS orders_count "
             . "FROM towns "
             . "LEFT JOIN countries "
                       . "ON countries.country_id = towns.country_id "
                          . "AND countries.enabled = 1 "
             . "LEFT JOIN regions "
                       . "ON regions.region_id = towns.region_id "
                          . "AND regions.enabled = 1 "
             . "LEFT JOIN " . DATABASE_USERS_TABLENAME . " "
                       . "ON " . DATABASE_USERS_TABLENAME . ".town_id = towns.town_id "
                          . "AND " . DATABASE_USERS_TABLENAME . ".enabled = 1 "
             . "LEFT JOIN " . DATABASE_ORDERS_TABLENAME . " "
                       . "ON " . DATABASE_ORDERS_TABLENAME . ".town_id = towns.town_id "
             . $where
             . "GROUP BY towns.town_id "
             . $having
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Выбрать из базы данных дерево записей о городах:
    //   $items = результат будет помещен в эту переменную
    //   [$nonempty] = признак "только непустые ветви"
    // =======================================================================

    public function get_towns_tree (&$items, $nonempty = FALSE) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_towns_tree");

      // делаем запрос
      $query = "SELECT countries.country_id, "
                    . "countries.name AS country, "
                    . "countries.url AS country_url, "
                    . "regions.region_id, "
                    . "regions.name AS region, "
                    . "regions.url AS region_url, "
                    . "towns.town_id, "
                    . "towns.name, "
                    . "towns.url "
             . "FROM countries "
             . "LEFT JOIN regions "
                       . "ON regions.country_id = countries.country_id "
             . "LEFT JOIN towns "
                       . "ON towns.country_id = countries.country_id "
                          . "AND towns.region_id = regions.region_id "
             . "WHERE countries.enabled = 1 "
                   . "AND TRIM(countries.name) != '' "
                   . "AND " . ($nonempty ? "regions.enabled = 1 " : "(regions.enabled = 1 OR regions.enabled IS NULL) ")
                   . "AND " . ($nonempty ? "towns.enabled = 1 " : "(towns.enabled = 1 OR towns.enabled IS NULL) ")
             . "ORDER BY country ASC, "
                      . "region ASC, "
                      . "towns.name ASC;";
      $result = $this->query($query);

      // строим дерево записей
      $items = array();
      if (!empty($result)) {
        while ($item = $this->fetch_object($result)) {
          $cid = $item->country_id;
          if (!isset($items[$cid])) {
            $value = new stdClass;
            $value->id = $cid;
            $value->name = $item->country;
            $value->url = $item->country_url;
            $value->items = array();
            $items[$cid] = $value;
          }
          if (trim($item->region) != "") {
            $rid = $item->region_id;
            if (!isset($items[$cid]->items[$rid])) {
              $value = new stdClass;
              $value->id = $rid;
              $value->name = $item->region;
              $value->url = $item->region_url;
              $value->items = array();
              $items[$cid]->items[$rid] = $value;
            }
            if (trim($item->name) != "") {
              $tid = $item->town_id;
              if (!isset($items[$cid]->items[$rid]->items[$tid])) {
                $value = new stdClass;
                $value->id = $tid;
                $value->name = $item->name;
                $value->url = $item->url;
                $items[$cid]->items[$rid]->items[$tid] = $value;
              }
            }
          }
        }
      }

      // освобождаем память от запроса
      $this->free_result($result);

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Взять из базы данных запись о городе, указанной в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->country] = название страны
    //   [$params->country_id] = идентификатор страны
    //   [$params->region] = название области
    //   [$params->region_id] = идентификатор области
    //   [$params->name] = название города
    //   [$params->user_id] = идентификатор пользователя
    //   [$params->order_id] = идентификатор заказа
    //   [$params->url] = адрес страницы записи
    //   [$params->enabled] = признак "разрешена" запись
    // =======================================================================

    public function get_town (&$item, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_town");

      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND towns.town_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND towns.name = '" . $this->query_value($params->name) . "' ";
      if (isset($params->country)) $where .= "AND countries.name = '" . $this->query_value($params->country) . "' ";
      if (isset($params->country_id)) $where .= "AND countries.country_id = '" . $this->query_value($params->country_id) . "' ";
      if (isset($params->region)) $where .= "AND regions.name = '" . $this->query_value($params->region) . "' ";
      if (isset($params->region_id)) $where .= "AND regions.region_id = '" . $this->query_value($params->region_id) . "' ";
      if (isset($params->user_id)) $where .= "AND " . DATABASE_USERS_TABLENAME . ".user_id = '" . $this->query_value($params->user_id) . "' ";
      if (isset($params->order_id)) $where .= "AND " . DATABASE_ORDERS_TABLENAME . ".order_id = '" . $this->query_value($params->order_id) . "' ";
      if (isset($params->url)) $where .= "AND towns.url = '" . $this->query_value($params->url) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND towns.town_id != '" . $this->query_value($params->exclude_id) . "' ";
        if (isset($params->enabled)) $where .= "AND towns.enabled = '" . $this->query_value($params->enabled) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT towns.*, "
                      . "countries.name AS country, "
                      . "countries.phone_code AS country_phone_code, "
                      . "countries.url AS country_url, "
                      . "regions.name AS region, "
                      . "regions.phone_code AS region_phone_code, "
                      . "regions.url AS region_url, "
                      . "ABS(towns.browsed) AS browsed, "
                      . "COUNT(DISTINCT countries.country_id) AS countries_count, "
                      . "COUNT(DISTINCT regions.region_id) AS regions_count, "
                      . "COUNT(DISTINCT " . DATABASE_USERS_TABLENAME . ".user_id) AS users_count, "
                      . "COUNT(DISTINCT " . DATABASE_ORDERS_TABLENAME . ".order_id) AS orders_count "
               . "FROM towns "
               . "LEFT JOIN countries "
                         . "ON countries.country_id = towns.country_id "
                            . "AND countries.enabled = 1 "
               . "LEFT JOIN regions "
                         . "ON regions.region_id = towns.region_id "
                            . "AND regions.enabled = 1 "
               . "LEFT JOIN " . DATABASE_USERS_TABLENAME . " "
                         . "ON " . DATABASE_USERS_TABLENAME . ".town_id = towns.town_id "
                            . "AND " . DATABASE_USERS_TABLENAME . ".enabled = 1 "
               . "LEFT JOIN " . DATABASE_ORDERS_TABLENAME . " "
                         . "ON " . DATABASE_ORDERS_TABLENAME . ".town_id = towns.town_id "
               . $where
               . "GROUP BY towns.town_id "
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_towns_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Добавить в записи о городах оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_towns (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_towns");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->town_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "Towns",
                             REQUEST_PARAM_NAME_ITEMID => $item->town_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "поднять выше"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEUP;
            $item->move_up_get = $this->parent->form_get($options);
            // создаем ссылку "опустить ниже"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEDOWN;
            $item->move_down_get = $this->parent->form_get($options);
            // создаем ссылку "поставить первым"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEFIRST;
            $item->move_first_get = $this->parent->form_get($options);
            // создаем ссылку "поставить последним"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVELAST;
            $item->move_last_get = $this->parent->form_get($options);
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "Town";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о городе в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_town (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_town");

      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->country_id))       {$fields[] = "country_id";       $values[] = "'" . $this->query_value($this->value_as_integer($item->country_id)) . "'";}
        if (isset($item->region_id))        {$fields[] = "region_id";        $values[] = "'" . $this->query_value($this->value_as_integer($item->region_id)) . "'";}
        if (isset($item->enabled))          {$fields[] = "enabled";          $values[] = "'" . $this->query_value($this->value_as_boolean($item->enabled)) . "'";}
        if (isset($item->url))              {$fields[] = "url";              $values[] = "'" . $this->query_value($this->value_as_string($item->url)) . "'";}
        if (isset($item->meta_title))       {$fields[] = "meta_title";       $values[] = "'" . $this->query_value($this->value_as_string($item->meta_title)) . "'";}
        if (isset($item->meta_keywords))    {$fields[] = "meta_keywords";    $values[] = "'" . $this->query_value($this->value_as_string($item->meta_keywords)) . "'";}
        if (isset($item->meta_description)) {$fields[] = "meta_description"; $values[] = "'" . $this->query_value($this->value_as_string($item->meta_description)) . "'";}
        if (isset($item->name))             {$fields[] = "name";             $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->description))      {$fields[] = "description";      $values[] = "'" . $this->query_value($this->value_as_string($item->description)) . "'";}
        if (isset($item->seo_description))  {$fields[] = "seo_description";  $values[] = "'" . $this->query_value($this->value_as_string($item->seo_description)) . "'";}
        if (isset($item->phone_code))       {$fields[] = "phone_code";       $values[] = "'" . $this->query_value($this->value_as_string($item->phone_code)) . "'";}
        if (isset($item->post_code))        {$fields[] = "post_code";        $values[] = "'" . $this->query_value($this->value_as_string($item->post_code)) . "'";}
        if (isset($item->images))           {$fields[] = "images";           $values[] = "'" . $this->query_value($this->value_as_string($item->images)) . "'";}
        if (isset($item->images_alts))      {$fields[] = "images_alts";      $values[] = "'" . $this->query_value($this->value_as_string($item->images_alts)) . "'";}
        if (isset($item->images_texts))     {$fields[] = "images_texts";     $values[] = "'" . $this->query_value($this->value_as_string($item->images_texts)) . "'";}
        if (isset($item->images_view))      {$fields[] = "images_view";      $values[] = "'" . $this->query_value($this->value_as_string($item->images_view)) . "'";}
        if (isset($item->tags))             {$fields[] = "tags";             $values[] = "'" . $this->query_value($this->value_as_string($item->tags)) . "'";}
        if (isset($item->created))          {$fields[] = "created";          $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified))         {$fields[] = "modified";         $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        if (isset($item->browsed))          {$fields[] = "browsed";          $values[] = "'" . $this->query_value($this->value_as_natural($item->browsed)) . "'";}
        if (isset($item->order_num))        {$fields[] = "order_num";        $values[] = "'" . $this->query_value($this->value_as_integer($item->order_num)) . "'";}
        $id = $this->update_record($item, "towns", "town_id", $fields, $values);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      return $id;
    }

    // =======================================================================
    // Поправить поля записей о городах:
    //   $items = массив записей
    // =======================================================================

    public function fix_towns_records (&$items) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB fix_towns_records");

      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_towns_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Поправить поля записи о городе:
    //   $item = запись
    // =======================================================================

    public function fix_towns_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);

      // поправляем адресующие поля
      if (isset($item->country_id)) $item->country_id = intval($item->country_id);
      if (isset($item->region_id)) $item->region_id = intval($item->region_id);
      if (isset($item->town_id)) {
        $item->town_id = intval($item->town_id);
        if (isset($item->url) && empty($item->url)) $item->url = $item->town_id;
        $item->url_path = "towns/";
      }

      // поправляем поля изображений
      $this->fix_towns_record_images($item);
    }

    // =======================================================================
    // Превратить строки полей изображений записи о городе в массивы:
    //   $item = запись (при отсутствии полей images, images_alts, images_texts, images_view они станут пустыми массивами)
    // =======================================================================

    public function fix_towns_record_images (&$item) {
      $this->fix_articles_record_images($item);
    }

    // =======================================================================
    // Превратить массивы, находящиеся в полях изображений записи о городе,
    // в строки, готовые для передачи в базу данных:
    //   $item = запись (при отсутствии полей images, images_alts, images_texts, images_view они появятся пустыми)
    // =======================================================================

    public function unfix_towns_record_images (&$item) {
      $this->unfix_articles_record_images($item);
    }

    // =======================================================================
    // Заполнить таблицу городов минимально необходимыми записями.
    // =======================================================================

    private function setup_towns () {
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу городов в базе данных.
    // =======================================================================

    private function check_database_towns () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_towns");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "towns";
      $dbtable_field = "town_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(20) NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор города'";
      }
      if (!isset($columns["country_id"])) {
        $query[] = "ADD country_id BIGINT(20) DEFAULT '0' NOT NULL COMMENT 'Идентификатор страны'";
        $query[] = "ADD INDEX (country_id)";
      }
      if (!isset($columns["region_id"])) {
        $query[] = "ADD region_id BIGINT(20) DEFAULT '0' NOT NULL COMMENT 'Идентификатор области'";
        $query[] = "ADD INDEX (region_id)";
      }
      if (!isset($columns["enabled"])) {
        $query[] = "ADD enabled TINYINT(1) DEFAULT '1' NOT NULL COMMENT 'Разрешена ли запись к использованию'";
        $query[] = "ADD INDEX (enabled)";
      }
      if (!isset($columns["url"])) {
        $query[] = "ADD url VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Адрес страницы записи'";
        $query[] = "ADD INDEX (url)";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET url = " . $dbtable_field . " "
                    . "WHERE url = '' OR url IS NULL;";
      }
      if (!isset($columns["meta_title"])) {
        $query[] = "ADD meta_title VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Мета заголовок страницы записи'";
      }
      if (!isset($columns["meta_keywords"])) {
        $query[] = "ADD meta_keywords VARCHAR(512) DEFAULT '' NOT NULL COMMENT 'Мета ключевые слова страницы записи'";
      }
      if (!isset($columns["meta_description"])) {
        $query[] = "ADD meta_description VARCHAR(512) DEFAULT '' NOT NULL COMMENT 'Мета описание страницы записи'";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Название города'";
        $query[] = "ADD INDEX (name)";
      }
      if (!isset($columns["description"])) {
        $query[] = "ADD description TEXT DEFAULT '' NOT NULL COMMENT 'Описание города'";
      }
      if (!isset($columns["seo_description"])) {
        $query[] = "ADD seo_description TEXT DEFAULT '' NOT NULL COMMENT 'SEO текст'";
      }
      if (!isset($columns["phone_code"])) {
        $query[] = "ADD phone_code VARCHAR(16) DEFAULT '' NOT NULL COMMENT 'Телефонный стационарный код города'";
        $query[] = "ADD INDEX (phone_code)";
      }
      if (!isset($columns["post_code"])) {
        $query[] = "ADD post_code VARCHAR(24) DEFAULT '' NOT NULL COMMENT 'Почтовый код города'";
        $query[] = "ADD INDEX (post_code)";
      }
      if (!isset($columns["images"])) {
        $query[] = "ADD images TEXT DEFAULT '' NOT NULL COMMENT 'Изображения записи'";
      }
      if (!isset($columns["images_alts"])) {
        $query[] = "ADD images_alts TEXT DEFAULT '' NOT NULL COMMENT 'Подписи изображений записи'";
      }
      if (!isset($columns["images_texts"])) {
        $query[] = "ADD images_texts LONGTEXT DEFAULT '' NOT NULL COMMENT 'Описания изображений записи'";
      }
      if (!isset($columns["images_view"])) {
        $query[] = "ADD images_view TEXT DEFAULT '' NOT NULL COMMENT 'Признаки использования в слайдере изображений записи'";
      }
      if (!isset($columns["tags"])) {
        $query[] = "ADD tags VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Теги записи'";
        $query[] = "ADD INDEX (tags)";
      }
      if (!isset($columns["created"])) {
        $query[] = "ADD created DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата создания записи'";
        $query[] = "ADD INDEX (created)";
      }
      if (!isset($columns["modified"])) {
        $query[] = "ADD modified DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата изменения записи'";
        $query[] = "ADD INDEX (modified)";
      }
      if (!isset($columns["browsed"])) {
        $query[] = "ADD browsed INT(11) DEFAULT '0' NOT NULL COMMENT 'Количество просмотров записи'";
        $query[] = "ADD INDEX (browsed)";
      }
      if (!isset($columns["order_num"])) {
        $query[] = "ADD order_num INT(11) DEFAULT '0' NOT NULL COMMENT 'Порядковый номер записи'";
        $query[] = "ADD INDEX (order_num)";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET order_num = " . $dbtable_field . " "
                    . "WHERE order_num = 0 OR order_num IS NULL;";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // если таблица не существовала, проверяем наличие минимально необходимых записей
      if (empty($columns)) $this->setup_towns();

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Выбрать из базы данных записи о учебных заведениях:
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->sort_direction] = направление сортировки
    //   [$params->sort_laconical] = признак лаконичного режима сортировки
    //   [$params->ids] = идентификаторы заведений (перечисленные через запятую)
    //   [$params->country_id] = идентификатор страны
    //   [$params->region_id] = идентификатор области
    //   [$params->town_id] = идентификатор города
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->imaged] = с загруженными изображениями
    //   [$params->browsed] = просмотренные
    //   [$params->SEOed] = с SEO текстом
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_schools (&$items, $params = null) {
      $items = array();
      $where = "";
      $having = "";
      $order = "";
      $limit = "";

      // запоминаем направление сортировки и режим лаконичности
      $direction = (isset($params->sort_direction) && ($params->sort_direction == SORT_DIRECTION_DESCENDING)) ? "DESC " : "ASC ";
      $laconical = !empty($params->sort_laconical);

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_SCHOOLS_MODE_BY_NAME:
            $order = "country " . $direction . ", "
                   . "region " . $direction . ", "
                   . "town " . $direction . ", "
                   . "schools.name " . $direction . ", "
                   . "schools.order_num DESC ";
            if ($laconical) $where .= "AND TRIM(schools.name) != '' ";
            break;
          case SORT_SCHOOLS_MODE_BY_URL:
            $order = "schools.url " . $direction;
            if ($laconical) $where .= "AND TRIM(schools.url) != '' ";
            break;
          case SORT_SCHOOLS_MODE_BY_BROWSED:
            $order = "browsed " . $direction . ", "
                   . "country ASC, "
                   . "region ASC, "
                   . "town ASC, "
                   . "schools.name ASC, "
                   . "schools.order_num DESC ";
            if ($laconical) $where .= "AND ABS(schools.browsed) > 0 ";
            break;
          case SORT_SCHOOLS_MODE_BY_USERSCOUNT:
            $order = "users_count " . $direction . ", "
                   . "country ASC, "
                   . "region ASC, "
                   . "town ASC, "
                   . "schools.name ASC, "
                   . "schools.order_num DESC ";
            if ($laconical) $having .= "AND COUNT(" . DATABASE_USERS_TABLENAME . ".user_id) > 0 ";
            break;
          case SORT_SCHOOLS_MODE_BY_CREATED:
            $order = "schools.created " . $direction . ", "
                   . "country ASC, "
                   . "region ASC, "
                   . "town ASC, "
                   . "schools.name ASC, "
                   . "schools.order_num DESC ";
            if ($laconical) $where .= "AND schools.created IS NOT NULL ";
            break;
          case SORT_SCHOOLS_MODE_BY_MODIFIED:
            $order = "schools.modified " . $direction . ", "
                   . "country ASC, "
                   . "region ASC, "
                   . "town ASC, "
                   . "schools.name ASC, "
                   . "schools.order_num DESC ";
            if ($laconical) $where .= "AND schools.modified IS NOT NULL "
                                        . "AND schools.modified != schools.created ";
            break;
          case SORT_SCHOOLS_MODE_AS_IS:
          default:
            $order = "country ASC, "
                   . "region ASC, "
                   . "town ASC, "
                   . "schools.order_num DESC ";
            if ($laconical) $where .= "AND TRIM(schools.name) != '' ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND schools.school_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if (isset($params->country_id)) $where .= "AND schools.country_id = '" . $this->query_value($params->country_id) . "' ";
      if (isset($params->region_id)) $where .= "AND schools.region_id = '" . $this->query_value($params->region_id) . "' ";
      if (isset($params->town_id)) $where .= "AND schools.town_id = '" . $this->query_value($params->town_id) . "' ";
      if (isset($params->enabled)) $where .= "AND schools.enabled = '" . $this->query_value($params->enabled) . "' ";
      if (isset($params->imaged)) $where .= "AND TRIM(REPLACE(schools.images, '" . $this->query_value(IN_ONE_TEXT_LINE_RECORDS_FIELDS_DELIMITER) . "', '')) != '' ";
      if (isset($params->browsed)) $where .= "AND ABS(schools.browsed) != 0 ";
      if (isset($params->SEOed)) $where .= "AND TRIM(schools.seo_description) != '' ";
      if ($where != "") $where = "WHERE 1 " . $where;
      if ($having != "") $having = "HAVING 1 " . $having;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS schools.*, "
                                        . "countries.name AS country, "
                                        . "countries.phone_code AS country_phone_code, "
                                        . "countries.url AS country_url, "
                                        . "regions.name AS region, "
                                        . "regions.phone_code AS region_phone_code, "
                                        . "regions.url AS region_url, "
                                        . "towns.name AS town, "
                                        . "towns.phone_code AS town_phone_code, "
                                        . "towns.post_code AS town_post_code, "
                                        . "towns.url AS town_url, "
                                        . "ABS(schools.browsed) AS browsed, "
                                        . "COUNT(DISTINCT " . DATABASE_USERS_TABLENAME . ".user_id) AS users_count "
             . "FROM schools "
             . "LEFT JOIN countries "
                       . "ON countries.country_id = schools.country_id "
                          . "AND countries.enabled = 1 "
             . "LEFT JOIN regions "
                       . "ON regions.region_id = schools.region_id "
                          . "AND regions.enabled = 1 "
             . "LEFT JOIN towns "
                       . "ON towns.town_id = schools.town_id "
                          . "AND regions.enabled = 1 "
             . "LEFT JOIN " . DATABASE_USERS_TABLENAME . " "
                       . "ON " . DATABASE_USERS_TABLENAME . ".school_id = schools.school_id "
                          . "AND " . DATABASE_USERS_TABLENAME . ".enabled = 1 "
             . $where
             . "GROUP BY schools.school_id "
             . $having
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Выбрать из базы данных дерево записей о учебных заведениях:
    //   $items = результат будет помещен в эту переменную
    //   [$nonempty] = признак "только непустые ветви"
    // =======================================================================

    public function get_schools_tree (&$items, $nonempty = FALSE) {

      // делаем запрос
      $query = "SELECT countries.country_id, "
                    . "countries.name AS country, "
                    . "countries.url AS country_url, "
                    . "regions.region_id, "
                    . "regions.name AS region, "
                    . "regions.url AS region_url, "
                    . "towns.town_id, "
                    . "towns.name AS town, "
                    . "towns.url AS town_url, "
                    . "schools.school_id, "
                    . "schools.name, "
                    . "schools.lessons_ids, "
                    . "schools.classes_ids, "
                    . "schools.url "
             . "FROM countries "
             . "LEFT JOIN regions "
                       . "ON regions.country_id = countries.country_id "
             . "LEFT JOIN towns "
                       . "ON towns.country_id = countries.country_id "
                          . "AND towns.region_id = regions.region_id "
             . "LEFT JOIN schools "
                       . "ON schools.country_id = countries.country_id "
                          . "AND schools.region_id = regions.region_id "
                          . "AND schools.town_id = towns.town_id "
             . "WHERE countries.enabled = 1 "
                   . "AND TRIM(countries.name) != '' "
                   . "AND " . ($nonempty ? "regions.enabled = 1 " : "(regions.enabled = 1 OR regions.enabled IS NULL) ")
                   . "AND " . ($nonempty ? "towns.enabled = 1 " : "(towns.enabled = 1 OR towns.enabled IS NULL) ")
                   . "AND " . ($nonempty ? "schools.enabled = 1 " : "(schools.enabled = 1 OR schools.enabled IS NULL) ")
             . "ORDER BY country ASC, "
                      . "region ASC, "
                      . "town ASC, "
                      . "schools.name ASC;";
      $result = $this->query($query);

      // строим дерево записей
      $items = array();
      if (!empty($result)) {
        while ($item = $this->fetch_object($result)) {
          $this->fix_schools_record($item);
          $cid = $item->country_id;
          if (!isset($items[$cid])) {
            $value = new stdClass;
            $value->id = $cid;
            $value->name = $item->country;
            $value->url = $item->country_url;
            $value->items = array();
            $items[$cid] = $value;
          }
          if (trim($item->region) != "") {
            $rid = $item->region_id;
            if (!isset($items[$cid]->items[$rid])) {
              $value = new stdClass;
              $value->id = $rid;
              $value->name = $item->region;
              $value->url = $item->region_url;
              $value->items = array();
              $items[$cid]->items[$rid] = $value;
            }
            if (trim($item->town) != "") {
              $tid = $item->town_id;
              if (!isset($items[$cid]->items[$rid]->items[$tid])) {
                $value = new stdClass;
                $value->id = $tid;
                $value->name = $item->town;
                $value->url = $item->town_url;
                $value->items = array();
                $items[$cid]->items[$rid]->items[$tid] = $value;
              }
              if (trim($item->name) != "") {
                $sid = $item->school_id;
                if (!isset($items[$cid]->items[$rid]->items[$tid]->items[$sid])) {
                  $value = new stdClass;
                  $value->id = $sid;
                  $value->name = $item->name;
                  $value->url = $item->url;
                  $value->lessons_ids = $item->lessons_ids;
                  $value->classes_ids = $item->classes_ids;
                  $items[$cid]->items[$rid]->items[$tid]->items[$sid] = $value;
                }
              }
            }
          }
        }
      }

      // освобождаем память от запроса
      $this->free_result($result);
    }

    // =======================================================================
    // Взять из базы данных запись о учебном заведении, указанной в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->country] = название страны
    //   [$params->country_id] = идентификатор страны
    //   [$params->region] = название области
    //   [$params->region_id] = идентификатор области
    //   [$params->town] = название города
    //   [$params->town_id] = идентификатор города
    //   [$params->name] = название заведения
    //   [$params->user_id] = идентификатор пользователя
    //   [$params->url] = адрес страницы записи
    //   [$params->enabled] = признак "разрешена" запись
    // =======================================================================

    public function get_school (&$item, $params) {
      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND schools.school_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND schools.name = '" . $this->query_value($params->name) . "' ";
      if (isset($params->country)) $where .= "AND countries.name = '" . $this->query_value($params->country) . "' ";
      if (isset($params->country_id)) $where .= "AND countries.country_id = '" . $this->query_value($params->country_id) . "' ";
      if (isset($params->region)) $where .= "AND regions.name = '" . $this->query_value($params->region) . "' ";
      if (isset($params->region_id)) $where .= "AND regions.region_id = '" . $this->query_value($params->region_id) . "' ";
      if (isset($params->town)) $where .= "AND towns.name = '" . $this->query_value($params->region) . "' ";
      if (isset($params->town_id)) $where .= "AND towns.town_id = '" . $this->query_value($params->region_id) . "' ";
      if (isset($params->user_id)) $where .= "AND " . DATABASE_USERS_TABLENAME . ".user_id = '" . $this->query_value($params->user_id) . "' ";
      if (isset($params->url)) $where .= "AND schools.url = '" . $this->query_value($params->url) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND schools.school_id != '" . $this->query_value($params->exclude_id) . "' ";
        if (isset($params->enabled)) $where .= "AND schools.enabled = '" . $this->query_value($params->enabled) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT schools.*, "
                      . "countries.name AS country, "
                      . "countries.phone_code AS country_phone_code, "
                      . "countries.url AS country_url, "
                      . "regions.name AS region, "
                      . "regions.phone_code AS region_phone_code, "
                      . "regions.url AS region_url, "
                      . "towns.name AS town, "
                      . "towns.phone_code AS town_phone_code, "
                      . "towns.post_code AS town_post_code, "
                      . "towns.url AS town_url, "
                      . "ABS(schools.browsed) AS browsed, "
                      . "COUNT(DISTINCT " . DATABASE_USERS_TABLENAME . ".user_id) AS users_count "
               . "FROM schools "
               . "LEFT JOIN countries "
                         . "ON countries.country_id = schools.country_id "
                            . "AND countries.enabled = 1 "
               . "LEFT JOIN regions "
                         . "ON regions.region_id = schools.region_id "
                            . "AND regions.enabled = 1 "
               . "LEFT JOIN towns "
                         . "ON towns.town_id = schools.town_id "
                            . "AND towns.enabled = 1 "
               . "LEFT JOIN " . DATABASE_USERS_TABLENAME . " "
                         . "ON " . DATABASE_USERS_TABLENAME . ".school_id = schools.school_id "
                            . "AND " . DATABASE_USERS_TABLENAME . ".enabled = 1 "
               . $where
               . "GROUP BY schools.school_id "
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_schools_record($item);
      }
    }

    // =======================================================================
    // Добавить в записи о учебных заведениях оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_schools (&$items, $params) {
      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->school_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "Schools",
                             REQUEST_PARAM_NAME_ITEMID => $item->school_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "поднять выше"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEUP;
            $item->move_up_get = $this->parent->form_get($options);
            // создаем ссылку "опустить ниже"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEDOWN;
            $item->move_down_get = $this->parent->form_get($options);
            // создаем ссылку "поставить первым"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEFIRST;
            $item->move_first_get = $this->parent->form_get($options);
            // создаем ссылку "поставить последним"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVELAST;
            $item->move_last_get = $this->parent->form_get($options);
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "School";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }
    }

    // =======================================================================
    // Обновить/добавить запись о учебном заведении в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_school (&$item) {
      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->country_id))       {$fields[] = "country_id";       $values[] = "'" . $this->query_value($this->value_as_integer($item->country_id)) . "'";}
        if (isset($item->region_id))        {$fields[] = "region_id";        $values[] = "'" . $this->query_value($this->value_as_integer($item->region_id)) . "'";}
        if (isset($item->town_id))          {$fields[] = "town_id";          $values[] = "'" . $this->query_value($this->value_as_integer($item->town_id)) . "'";}
        if (isset($item->enabled))          {$fields[] = "enabled";          $values[] = "'" . $this->query_value($this->value_as_boolean($item->enabled)) . "'";}
        if (isset($item->url))              {$fields[] = "url";              $values[] = "'" . $this->query_value($this->value_as_string($item->url)) . "'";}
        if (isset($item->meta_title))       {$fields[] = "meta_title";       $values[] = "'" . $this->query_value($this->value_as_string($item->meta_title)) . "'";}
        if (isset($item->meta_keywords))    {$fields[] = "meta_keywords";    $values[] = "'" . $this->query_value($this->value_as_string($item->meta_keywords)) . "'";}
        if (isset($item->meta_description)) {$fields[] = "meta_description"; $values[] = "'" . $this->query_value($this->value_as_string($item->meta_description)) . "'";}
        if (isset($item->name))             {$fields[] = "name";             $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->description))      {$fields[] = "description";      $values[] = "'" . $this->query_value($this->value_as_string($item->description)) . "'";}
        if (isset($item->seo_description))  {$fields[] = "seo_description";  $values[] = "'" . $this->query_value($this->value_as_string($item->seo_description)) . "'";}
        if (isset($item->type_id))          {$fields[] = "type_id";          $values[] = "'" . $this->query_value($this->value_as_integer($item->type_id)) . "'";}
        if (isset($item->phone))            {$fields[] = "phone";            $values[] = "'" . $this->query_value($this->value_as_string($item->phone)) . "'";}
        if (isset($item->mobile))           {$fields[] = "mobile";           $values[] = "'" . $this->query_value($this->value_as_string($item->mobile)) . "'";}
        if (isset($item->director))         {$fields[] = "director";         $values[] = "'" . $this->query_value($this->value_as_string($item->director)) . "'";}
        if (isset($item->email))            {$fields[] = "email";            $values[] = "'" . $this->query_value($this->value_as_string($item->email)) . "'";}
        if (isset($item->lessons_ids))      {$fields[] = "lessons_ids";      $values[] = "'" . $this->query_value($this->value_as_string($item->lessons_ids)) . "'";}
        if (isset($item->classes_ids))      {$fields[] = "classes_ids";      $values[] = "'" . $this->query_value($this->value_as_string($item->classes_ids)) . "'";}
        if (isset($item->ringb))            {$fields[] = "ringb";            $values[] = "'" . $this->query_value($this->value_as_string($item->ringb)) . "'";}
        if (isset($item->ringe))            {$fields[] = "ringe";            $values[] = "'" . $this->query_value($this->value_as_string($item->ringe)) . "'";}
        if (isset($item->collective1))      {$fields[] = "collective1";      $values[] = "'" . $this->query_value($this->value_as_string($item->collective1)) . "'";}
        if (isset($item->collective2))      {$fields[] = "collective2";      $values[] = "'" . $this->query_value($this->value_as_string($item->collective2)) . "'";}
        if (isset($item->collective3))      {$fields[] = "collective3";      $values[] = "'" . $this->query_value($this->value_as_string($item->collective3)) . "'";}
        if (isset($item->collective4))      {$fields[] = "collective4";      $values[] = "'" . $this->query_value($this->value_as_string($item->collective4)) . "'";}
        if (isset($item->address))          {$fields[] = "address";          $values[] = "'" . $this->query_value($this->value_as_string($item->address)) . "'";}
        if (isset($item->images))           {$fields[] = "images";           $values[] = "'" . $this->query_value($this->value_as_string($item->images)) . "'";}
        if (isset($item->images_alts))      {$fields[] = "images_alts";      $values[] = "'" . $this->query_value($this->value_as_string($item->images_alts)) . "'";}
        if (isset($item->images_texts))     {$fields[] = "images_texts";     $values[] = "'" . $this->query_value($this->value_as_string($item->images_texts)) . "'";}
        if (isset($item->images_view))      {$fields[] = "images_view";      $values[] = "'" . $this->query_value($this->value_as_string($item->images_view)) . "'";}
        if (isset($item->tags))             {$fields[] = "tags";             $values[] = "'" . $this->query_value($this->value_as_string($item->tags)) . "'";}
        if (isset($item->created))          {$fields[] = "created";          $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified))         {$fields[] = "modified";         $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        if (isset($item->browsed))          {$fields[] = "browsed";          $values[] = "'" . $this->query_value($this->value_as_natural($item->browsed)) . "'";}
        if (isset($item->order_num))        {$fields[] = "order_num";        $values[] = "'" . $this->query_value($this->value_as_integer($item->order_num)) . "'";}
        $id = $this->update_record($item, "schools", "school_id", $fields, $values);
      }
      return $id;
    }

    // =======================================================================
    // Поправить поля записей о учебных заведениях:
    //   $items = массив записей
    // =======================================================================

    public function fix_schools_records (&$items) {
      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_schools_record($item);
      }
    }

    // =======================================================================
    // Поправить поля записи о учебном заведении:
    //   $item = запись
    // =======================================================================

    public function fix_schools_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);

      // поправляем адресующие поля
      if (isset($item->country_id)) $item->country_id = intval($item->country_id);
      if (isset($item->region_id)) $item->region_id = intval($item->region_id);
      if (isset($item->town_id)) $item->town_id = intval($item->town_id);
      if (isset($item->school_id)) {
        $item->school_id = intval($item->school_id);
        if (isset($item->url) && empty($item->url)) $item->url = $item->school_id;
        $item->url_path = "schools/";
      }

      // поправляем список идентификаторов преподаваемых предметов
      if (isset($item->lessons_ids) && is_string($item->lessons_ids)) {
        $ids = explode(",", $item->lessons_ids);
        $item->lessons_ids = array();
        foreach ($ids as $id) {
          $id = intval($id);
          if (!empty($id)) $item->lessons_ids[$id] = $id;
        }
        sort($item->lessons_ids, SORT_NUMERIC);
      }

      // поправляем список идентификаторов классов
      if (isset($item->classes_ids) && is_string($item->classes_ids)) {
        $ids = explode(",", $item->classes_ids);
        $item->classes_ids = array();
        foreach ($ids as $id) {
          $id = intval($id);
          if (!empty($id)) $item->classes_ids[$id] = $id;
        }
        sort($item->classes_ids, SORT_NUMERIC);
      }

      // поправляем расписание звонков
      if (isset($item->ringb) && is_string($item->ringb)) $item->ringb = explode(",", $item->ringb);
      if (isset($item->ringe) && is_string($item->ringe)) $item->ringe = explode(",", $item->ringe);

      // поправляем поля изображений
      $this->fix_schools_record_images($item);
    }

    // =======================================================================
    // Превратить строки полей изображений записи о учебном заведении в массивы:
    //   $item = запись (при отсутствии полей images, images_alts, images_texts, images_view они станут пустыми массивами)
    // =======================================================================

    public function fix_schools_record_images (&$item) {
      $this->fix_articles_record_images($item);
    }

    // =======================================================================
    // Превратить массивы, находящиеся в полях изображений записи о учебном заведении,
    // в строки, готовые для передачи в базу данных:
    //   $item = запись (при отсутствии полей images, images_alts, images_texts, images_view они появятся пустыми)
    // =======================================================================

    public function unfix_schools_record_images (&$item) {
      $this->unfix_articles_record_images($item);
    }

    // =======================================================================
    // Заполнить таблицу учебных заведений минимально необходимыми записями.
    // =======================================================================

    private function setup_schools () {
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу учебных заведений в базе данных.
    // =======================================================================

    private function check_database_schools () {

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "schools";
      $dbtable_field = "school_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(20) NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор учебного заведения'";
      }
      if (!isset($columns["country_id"])) {
        $query[] = "ADD country_id BIGINT(20) DEFAULT '0' NOT NULL COMMENT 'Идентификатор страны'";
        $query[] = "ADD INDEX (country_id)";
      }
      if (!isset($columns["region_id"])) {
        $query[] = "ADD region_id BIGINT(20) DEFAULT '0' NOT NULL COMMENT 'Идентификатор области'";
        $query[] = "ADD INDEX (region_id)";
      }
      if (!isset($columns["town_id"])) {
        $query[] = "ADD town_id BIGINT(20) DEFAULT '0' NOT NULL COMMENT 'Идентификатор города'";
        $query[] = "ADD INDEX (town_id)";
      }
      if (!isset($columns["enabled"])) {
        $query[] = "ADD enabled TINYINT(1) DEFAULT '1' NOT NULL COMMENT 'Разрешена ли запись к использованию'";
        $query[] = "ADD INDEX (enabled)";
      }
      if (!isset($columns["url"])) {
        $query[] = "ADD url VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Адрес страницы записи'";
        $query[] = "ADD INDEX (url)";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET url = " . $dbtable_field . " "
                    . "WHERE url = '' OR url IS NULL;";
      }
      if (!isset($columns["meta_title"])) {
        $query[] = "ADD meta_title VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Мета заголовок страницы записи'";
      }
      if (!isset($columns["meta_keywords"])) {
        $query[] = "ADD meta_keywords VARCHAR(512) DEFAULT '' NOT NULL COMMENT 'Мета ключевые слова страницы записи'";
      }
      if (!isset($columns["meta_description"])) {
        $query[] = "ADD meta_description VARCHAR(512) DEFAULT '' NOT NULL COMMENT 'Мета описание страницы записи'";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Название учебного заведения'";
        $query[] = "ADD INDEX (name)";
      }
      if (!isset($columns["description"])) {
        $query[] = "ADD description TEXT DEFAULT '' NOT NULL COMMENT 'Описание учебного заведения'";
      }
      if (!isset($columns["seo_description"])) {
        $query[] = "ADD seo_description TEXT DEFAULT '' NOT NULL COMMENT 'SEO текст'";
      }
      if (!isset($columns["type_id"])) {
        $query[] = "ADD type_id BIGINT(20) DEFAULT '0' NOT NULL COMMENT 'Идентификатор типа заведения'";
        $query[] = "ADD INDEX (type_id)";
      }
      if (!isset($columns["phone"])) {
        $query[] = "ADD phone VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Стационарные телефоны заведения'";
        $query[] = "ADD INDEX (phone)";
      }
      if (!isset($columns["mobile"])) {
        $query[] = "ADD mobile VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Мобильные телефоны заведения'";
        $query[] = "ADD INDEX (mobile)";
      }
      if (!isset($columns["director"])) {
        $query[] = "ADD director VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Директор заведения'";
        $query[] = "ADD INDEX (director)";
      }
      if (!isset($columns["email"])) {
        $query[] = "ADD email VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Емейл заведения'";
        $query[] = "ADD INDEX (email)";
      }
      if (!isset($columns["lessons_ids"])) {
        $query[] = "ADD lessons_ids TEXT DEFAULT '' NOT NULL COMMENT 'Идентификаторы преподаваемых предметов'";
        $query[] = "ADD INDEX (lessons_ids)";
      }
      if (!isset($columns["classes_ids"])) {
        $query[] = "ADD classes_ids TEXT DEFAULT '' NOT NULL COMMENT 'Идентификаторы классов'";
        $query[] = "ADD INDEX (classes_ids)";
      }
      if (!isset($columns["ringb"])) {
        $query[] = "ADD ringb VARCHAR(512) DEFAULT '' NOT NULL COMMENT 'Время начала уроков'";
      }
      if (!isset($columns["ringe"])) {
        $query[] = "ADD ringe VARCHAR(512) DEFAULT '' NOT NULL COMMENT 'Время конца уроков'";
      }
      if (!isset($columns["collective1"])) {
        $query[] = "ADD collective1 TEXT DEFAULT '' NOT NULL COMMENT 'Коллектив заведения - секция 1'";
      }
      if (!isset($columns["collective2"])) {
        $query[] = "ADD collective2 TEXT DEFAULT '' NOT NULL COMMENT 'Коллектив заведения - секция 2'";
      }
      if (!isset($columns["collective3"])) {
        $query[] = "ADD collective3 TEXT DEFAULT '' NOT NULL COMMENT 'Коллектив заведения - секция 3'";
      }
      if (!isset($columns["collective4"])) {
        $query[] = "ADD collective4 TEXT DEFAULT '' NOT NULL COMMENT 'Коллектив заведения - секция 4'";
      }
      if (!isset($columns["address"])) {
        $query[] = "ADD address VARCHAR(" . DATABASE_SCHOOLS_FIELDSIZE_ADDRESS . ") DEFAULT '' NOT NULL COMMENT 'Адрес заведения'";
      }
      if (!isset($columns["images"])) {
        $query[] = "ADD images TEXT DEFAULT '' NOT NULL COMMENT 'Изображения записи'";
      }
      if (!isset($columns["images_alts"])) {
        $query[] = "ADD images_alts TEXT DEFAULT '' NOT NULL COMMENT 'Подписи изображений записи'";
      }
      if (!isset($columns["images_texts"])) {
        $query[] = "ADD images_texts LONGTEXT DEFAULT '' NOT NULL COMMENT 'Описания изображений записи'";
      }
      if (!isset($columns["images_view"])) {
        $query[] = "ADD images_view TEXT DEFAULT '' NOT NULL COMMENT 'Признаки использования в слайдере изображений записи'";
      }
      if (!isset($columns["tags"])) {
        $query[] = "ADD tags VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Теги записи'";
        $query[] = "ADD INDEX (tags)";
      }
      if (!isset($columns["created"])) {
        $query[] = "ADD created DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата создания записи'";
        $query[] = "ADD INDEX (created)";
      }
      if (!isset($columns["modified"])) {
        $query[] = "ADD modified DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата изменения записи'";
        $query[] = "ADD INDEX (modified)";
      }
      if (!isset($columns["browsed"])) {
        $query[] = "ADD browsed INT(11) DEFAULT '0' NOT NULL COMMENT 'Количество просмотров записи'";
        $query[] = "ADD INDEX (browsed)";
      }
      if (!isset($columns["order_num"])) {
        $query[] = "ADD order_num INT(11) DEFAULT '0' NOT NULL COMMENT 'Порядковый номер записи'";
        $query[] = "ADD INDEX (order_num)";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET order_num = " . $dbtable_field . " "
                    . "WHERE order_num = 0 OR order_num IS NULL;";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // если таблица не существовала, проверяем наличие минимально необходимых записей
      if (empty($columns)) $this->setup_schools();
    }

    // =======================================================================
    // Выбрать из базы данных записи о типах учебных заведений:
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->sort_direction] = направление сортировки
    //   [$params->sort_laconical] = признак лаконичного режима сортировки
    //   [$params->ids] = идентификаторы типов (перечисленные через запятую)
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_schools_types (&$items, $params = null) {
      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // запоминаем направление сортировки и режим лаконичности
      $direction = (isset($params->sort_direction) && ($params->sort_direction == SORT_DIRECTION_DESCENDING)) ? "DESC " : "ASC ";
      $laconical = !empty($params->sort_laconical);

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_SCHOOLSTYPES_MODE_BY_NAME:
            $order = "schools_types.name " . $direction . ", "
                   . "schools_types.created DESC ";
            if ($laconical) $where .= "AND TRIM(schools_types.name) != '' ";
            break;
          case SORT_SCHOOLSTYPES_MODE_BY_MODIFIED:
            $order = "schools_types.modified " . $direction . ", "
                   . "schools_types.name ASC, "
                   . "schools_types.created DESC ";
            if ($laconical) $where .= "AND schools_types.modified IS NOT NULL "
                                        . "AND schools_types.modified != schools_types.created ";
            break;
          case SORT_SCHOOLSTYPES_MODE_AS_IS:
          case SORT_SCHOOLSTYPES_MODE_BY_CREATED:
          default:
            $order = "schools_types.created " . $direction . ", "
                   . "schools_types.name ASC ";
            if ($laconical) $where .= "AND schools_types.created IS NOT NULL ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND schools_types.type_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if ($where != "") $where = "WHERE 1 " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS schools_types.* "
             . "FROM schools_types "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о типе учебного заведения, указанном в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->name] = название типа
    // =======================================================================

    public function get_schools_type (&$item, $params) {
      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND schools_types.type_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND schools_types.name = '" . $this->query_value($params->name) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND schools_types.type_id != '" . $this->query_value($params->exclude_id) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT schools_types.* "
               . "FROM schools_types "
               . $where
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_schools_types_record($item);
      }
    }

    // =======================================================================
    // Добавить в записи о типах учебных заведений оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_schools_types (&$items, $params) {
      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->type_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "SchoolsTypes",
                             REQUEST_PARAM_NAME_ITEMID => $item->type_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "SchoolsType";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }
    }

    // =======================================================================
    // Обновить/добавить запись о типе учебного заведения в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_schools_type (&$item) {
      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->name))     {$fields[] = "name";     $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->created))  {$fields[] = "created";  $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified)) {$fields[] = "modified"; $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        $id = $this->update_record($item, "schools_types", "type_id", $fields, $values);
      }
      return $id;
    }

    // =======================================================================
    // Поправить поля записей о типах учебных заведений:
    //   $items = массив записей
    // =======================================================================

    public function fix_schools_types_records (&$items) {
      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_schools_types_record($item);
      }
    }

    // =======================================================================
    // Поправить поля записи о типе учебного заведения:
    //   $item = запись
    // =======================================================================

    public function fix_schools_types_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);

      // поправляем адресующие поля
      if (isset($item->type_id)) $item->type_id = intval($item->type_id);
    }

    // =======================================================================
    // Заполнить таблицу типов учебных заведений минимально необходимыми записями.
    // =======================================================================

    private function setup_schools_types () {

      // создаем перечень минимально необходимых записей
      $records = array();
      $records[] = array("name" => "Вечерняя школа");
      $records[] = array("name" => "Гимназия");
      $records[] = array("name" => "Детский дом");
      $records[] = array("name" => "Детский сад");
      $records[] = array("name" => "Кадетский корпус");
      $records[] = array("name" => "Колледж");
      $records[] = array("name" => "Лицей");
      $records[] = array("name" => "Общеобразовательная школа");
      $records[] = array("name" => "Техникум");
      $records[] = array("name" => "Училище");
      $records[] = array("name" => "Физико-математическая школа");
      $records[] = array("name" => "Центр дополнительного образования");
      $records[] = array("name" => "Центр образования");
      $records[] = array("name" => "Частная школа");
      $records[] = array("name" => "Школа-интернат");

      // читаем список имеющихся записей
      $query = "SELECT name "
             . "FROM schools_types;";
      $result = $this->query($query);
      $items = $this->results();

      // освобождаем память от запроса
      $this->free_result($result);

      // готовим результат для циклического перебора
      if (!empty($items)) {
        foreach ($items as &$item) $item = strtolower(trim($item->name));
      } else {
        $items = array();
      }

      // просматриваем перечень необходимых записей
      foreach ($records as &$record) {
        $value = isset($record["name"]) ? strtolower(trim($record["name"])) : "";
        if ($value == "") continue;

        // перебираем имеющиеся записи и сравниваем с необходимой
        foreach ($items as &$item) {
          if ($item == $value) continue 2;
        }

        // необходимая запись не найдена, добавляем ее
        $value = new stdClass;
        $value->name = $record["name"];
        $value->created = time();
        $this->update_schools_type($value);
      }
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу типов учебных заведений в базе данных.
    // =======================================================================

    private function check_database_schools_types () {

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "schools_types";
      $dbtable_field = "type_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(20) NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор типа учебного заведения'";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Название типа учебного заведения'";
        $query[] = "ADD INDEX (name)";
      }
      if (!isset($columns["created"])) {
        $query[] = "ADD created DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата создания записи'";
        $query[] = "ADD INDEX (created)";
      }
      if (!isset($columns["modified"])) {
        $query[] = "ADD modified DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата изменения записи'";
        $query[] = "ADD INDEX (modified)";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // если таблица не существовала, проверяем наличие минимально необходимых записей
      if (empty($columns)) $this->setup_schools_types();
    }

    // =======================================================================
    // Выбрать из базы данных записи о предметах учебных заведений:
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->sort_direction] = направление сортировки
    //   [$params->sort_laconical] = признак лаконичного режима сортировки
    //   [$params->ids] = идентификаторы предметов (перечисленные через запятую)
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_schools_lessons (&$items, $params = null) {
      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // запоминаем направление сортировки и режим лаконичности
      $direction = (isset($params->sort_direction) && ($params->sort_direction == SORT_DIRECTION_DESCENDING)) ? "DESC " : "ASC ";
      $laconical = !empty($params->sort_laconical);

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_SCHOOLSLESSONS_MODE_BY_NAME:
            $order = "schools_lessons.name " . $direction . ", "
                   . "schools_lessons.created DESC ";
            if ($laconical) $where .= "AND TRIM(schools_lessons.name) != '' ";
            break;
          case SORT_SCHOOLSLESSONS_MODE_BY_MODIFIED:
            $order = "schools_lessons.modified " . $direction . ", "
                   . "schools_lessons.name ASC, "
                   . "schools_lessons.created DESC ";
            if ($laconical) $where .= "AND schools_lessons.modified IS NOT NULL "
                                        . "AND schools_lessons.modified != schools_lessons.created ";
            break;
          case SORT_SCHOOLSLESSONS_MODE_AS_IS:
          case SORT_SCHOOLSLESSONS_MODE_BY_CREATED:
          default:
            $order = "schools_lessons.created " . $direction . ", "
                   . "schools_lessons.name ASC ";
            if ($laconical) $where .= "AND schools_lessons.created IS NOT NULL ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND schools_lessons.lesson_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if ($where != "") $where = "WHERE 1 " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS schools_lessons.* "
             . "FROM schools_lessons "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о предмете учебного заведения, указанном в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->name] = название предмета
    // =======================================================================

    public function get_schools_lesson (&$item, $params) {
      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND schools_lessons.lesson_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND schools_lessons.name = '" . $this->query_value($params->name) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND schools_lessons.lesson_id != '" . $this->query_value($params->exclude_id) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT schools_lessons.* "
               . "FROM schools_lessons "
               . $where
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_schools_lessons_record($item);
      }
    }

    // =======================================================================
    // Добавить в записи о предметах учебных заведений оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_schools_lessons (&$items, $params) {
      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->lesson_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "SchoolsLessons",
                             REQUEST_PARAM_NAME_ITEMID => $item->lesson_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "SchoolsLesson";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }
    }

    // =======================================================================
    // Обновить/добавить запись о предмете учебного заведения в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_schools_lesson (&$item) {
      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->name))     {$fields[] = "name";     $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->created))  {$fields[] = "created";  $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified)) {$fields[] = "modified"; $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        $id = $this->update_record($item, "schools_lessons", "lesson_id", $fields, $values);
      }
      return $id;
    }

    // =======================================================================
    // Поправить поля записей о предметах учебных заведений:
    //   $items = массив записей
    // =======================================================================

    public function fix_schools_lessons_records (&$items) {
      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_schools_lessons_record($item);
      }
    }

    // =======================================================================
    // Поправить поля записи о предмете учебного заведения:
    //   $item = запись
    // =======================================================================

    public function fix_schools_lessons_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);

      // поправляем адресующие поля
      if (isset($item->lesson_id)) $item->lesson_id = intval($item->lesson_id);
    }

    // =======================================================================
    // Заполнить таблицу предметов учебных заведений минимально необходимыми записями.
    // =======================================================================

    private function setup_schools_lessons () {

      // создаем перечень минимально необходимых записей
      $records = array();
      $records[] = array("name" => "Физика");
      $records[] = array("name" => "Алгебра");
      $records[] = array("name" => "Английский язык");
      $records[] = array("name" => "Биология");
      $records[] = array("name" => "География");
      $records[] = array("name" => "Геометрия");
      $records[] = array("name" => "Изобразительное искусство");
      $records[] = array("name" => "Информатика и ИКТ");
      $records[] = array("name" => "История");
      $records[] = array("name" => "Русская литература");
      $records[] = array("name" => "МХК");
      $records[] = array("name" => "Математика");
      $records[] = array("name" => "Немецкий язык");
      $records[] = array("name" => "Обществознание");
      $records[] = array("name" => "Основы безопасности жизнедеятельности");
      $records[] = array("name" => "Природоведение");
      $records[] = array("name" => "Русский язык");
      $records[] = array("name" => "Технология");
      $records[] = array("name" => "Физкультура");
      $records[] = array("name" => "Французский язык");
      $records[] = array("name" => "Химия");
      $records[] = array("name" => "Черчение");
      $records[] = array("name" => "Чтение");

      // читаем список имеющихся записей
      $query = "SELECT name "
             . "FROM schools_lessons;";
      $result = $this->query($query);
      $items = $this->results();

      // освобождаем память от запроса
      $this->free_result($result);

      // готовим результат для циклического перебора
      if (!empty($items)) {
        foreach ($items as &$item) $item = strtolower(trim($item->name));
      } else {
        $items = array();
      }

      // просматриваем перечень необходимых записей
      foreach ($records as &$record) {
        $value = isset($record["name"]) ? strtolower(trim($record["name"])) : "";
        if ($value == "") continue;

        // перебираем имеющиеся записи и сравниваем с необходимой
        foreach ($items as &$item) {
          if ($item == $value) continue 2;
        }

        // необходимая запись не найдена, добавляем ее
        $value = new stdClass;
        $value->name = $record["name"];
        $value->created = time();
        $this->update_schools_lesson($value);
      }
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу предметов учебных заведений в базе данных.
    // =======================================================================

    private function check_database_schools_lessons () {

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "schools_lessons";
      $dbtable_field = "lesson_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(20) NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор предмета учебного заведения'";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Название предмета учебного заведения'";
        $query[] = "ADD INDEX (name)";
      }
      if (!isset($columns["created"])) {
        $query[] = "ADD created DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата создания записи'";
        $query[] = "ADD INDEX (created)";
      }
      if (!isset($columns["modified"])) {
        $query[] = "ADD modified DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата изменения записи'";
        $query[] = "ADD INDEX (modified)";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // если таблица не существовала, проверяем наличие минимально необходимых записей
      if (empty($columns)) $this->setup_schools_lessons();
    }

    // =======================================================================
    // Выбрать из базы данных записи о классах учебных заведений:
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->sort_direction] = направление сортировки
    //   [$params->sort_laconical] = признак лаконичного режима сортировки
    //   [$params->ids] = идентификаторы классов (перечисленные через запятую)
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_schools_classes (&$items, $params = null) {
      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // запоминаем направление сортировки и режим лаконичности
      $direction = (isset($params->sort_direction) && ($params->sort_direction == SORT_DIRECTION_DESCENDING)) ? "DESC " : "ASC ";
      $laconical = !empty($params->sort_laconical);

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_SCHOOLSCLASSES_MODE_BY_NAME:
            $order = "schools_classes.name " . $direction . ", "
                   . "schools_classes.created DESC ";
            if ($laconical) $where .= "AND TRIM(schools_classes.name) != '' ";
            break;
          case SORT_SCHOOLSCLASSES_MODE_BY_MODIFIED:
            $order = "schools_classes.modified " . $direction . ", "
                   . "schools_classes.name ASC, "
                   . "schools_classes.created DESC ";
            if ($laconical) $where .= "AND schools_classes.modified IS NOT NULL "
                                        . "AND schools_classes.modified != schools_classes.created ";
            break;
          case SORT_SCHOOLSCLASSES_MODE_AS_IS:
          case SORT_SCHOOLSCLASSES_MODE_BY_CREATED:
          default:
            $order = "schools_classes.created " . $direction . ", "
                   . "schools_classes.name ASC ";
            if ($laconical) $where .= "AND schools_classes.created IS NOT NULL ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND schools_classes.class_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if ($where != "") $where = "WHERE 1 " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS schools_classes.* "
             . "FROM schools_classes "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о классе учебного заведения, указанном в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->name] = название класса
    // =======================================================================

    public function get_schools_class (&$item, $params) {
      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND schools_classes.class_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND schools_classes.name = '" . $this->query_value($params->name) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND schools_classes.class_id != '" . $this->query_value($params->exclude_id) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT schools_classes.* "
               . "FROM schools_classes "
               . $where
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_schools_classes_record($item);
      }
    }

    // =======================================================================
    // Добавить в записи о классах учебных заведений оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_schools_classes (&$items, $params) {
      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->class_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "SchoolsClasses",
                             REQUEST_PARAM_NAME_ITEMID => $item->class_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "SchoolsClass";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }
    }

    // =======================================================================
    // Обновить/добавить запись о классе учебного заведения в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_schools_class (&$item) {
      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->name))        {$fields[] = "name";        $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->lessons_ids)) {$fields[] = "lessons_ids"; $values[] = "'" . $this->query_value($this->value_as_string($item->lessons_ids)) . "'";}
        if (isset($item->created))     {$fields[] = "created";     $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified))    {$fields[] = "modified";    $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        $id = $this->update_record($item, "schools_classes", "class_id", $fields, $values);
      }
      return $id;
    }

    // =======================================================================
    // Поправить поля записей о классах учебных заведений:
    //   $items = массив записей
    // =======================================================================

    public function fix_schools_classes_records (&$items) {
      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_schools_classes_record($item);
      }
    }

    // =======================================================================
    // Поправить поля записи о классе учебного заведения:
    //   $item = запись
    // =======================================================================

    public function fix_schools_classes_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);

      // поправляем адресующие поля
      if (isset($item->class_id)) $item->class_id = intval($item->class_id);

      // поправляем список идентификаторов преподаваемых предметов
      if (isset($item->lessons_ids) && is_string($item->lessons_ids)) {
        $ids = explode(",", $item->lessons_ids);
        $item->lessons_ids = array();
        foreach ($ids as $id) {
          $id = intval($id);
          if (!empty($id)) $item->lessons_ids[$id] = $id;
        }
        sort($item->lessons_ids, SORT_NUMERIC);
      }
    }

    // =======================================================================
    // Заполнить таблицу классов учебных заведений минимально необходимыми записями.
    // =======================================================================

    private function setup_schools_classes () {

      // создаем перечень минимально необходимых записей
      $records = array();
      for ($i = 1; $i <= 11; $i++) {
        $records[] = array("name" => $i . "-А класс");
        $records[] = array("name" => $i . "-Б класс");
        $records[] = array("name" => $i . "-В класс");
      }

      // читаем список имеющихся записей
      $query = "SELECT name "
             . "FROM schools_classes;";
      $result = $this->query($query);
      $items = $this->results();

      // освобождаем память от запроса
      $this->free_result($result);

      // готовим результат для циклического перебора
      if (!empty($items)) {
        foreach ($items as &$item) $item = strtolower(trim($item->name));
      } else {
        $items = array();
      }

      // просматриваем перечень необходимых записей
      foreach ($records as &$record) {
        $value = isset($record["name"]) ? strtolower(trim($record["name"])) : "";
        if ($value == "") continue;

        // перебираем имеющиеся записи и сравниваем с необходимой
        foreach ($items as &$item) {
          if ($item == $value) continue 2;
        }

        // необходимая запись не найдена, добавляем ее
        $value = new stdClass;
        $value->name = $record["name"];
        $value->created = time();
        $this->update_schools_class($value);
      }
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу классов учебных заведений в базе данных.
    // =======================================================================

    private function check_database_schools_classes () {

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "schools_classes";
      $dbtable_field = "class_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(20) NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор класса учебного заведения'";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Название класса учебного заведения'";
        $query[] = "ADD INDEX (name)";
      }
      if (!isset($columns["lessons_ids"])) {
        $query[] = "ADD lessons_ids TEXT DEFAULT '' NOT NULL COMMENT 'Идентификаторы преподаваемых предметов'";
        $query[] = "ADD INDEX (lessons_ids)";
      }
      if (!isset($columns["created"])) {
        $query[] = "ADD created DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата создания записи'";
        $query[] = "ADD INDEX (created)";
      }
      if (!isset($columns["modified"])) {
        $query[] = "ADD modified DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата изменения записи'";
        $query[] = "ADD INDEX (modified)";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // если таблица не существовала, проверяем наличие минимально необходимых записей
      if (empty($columns)) $this->setup_schools_classes();
    }

    // =======================================================================
    // Выбрать из базы данных записи о способах доставки:
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->sort_direction] = направление сортировки
    //   [$params->sort_laconical] = признак лаконичного режима сортировки
    //   [$params->ids] = идентификаторы способов (перечисленные через запятую)
    //   [$params->require_address] = признак "требует ли заполнения адреса доставки"
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_deliveries (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_deliveries");

      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // запоминаем направление сортировки и режим лаконичности
      $direction = (isset($params->sort_direction) && ($params->sort_direction == SORT_DIRECTION_DESCENDING)) ? "DESC " : "ASC ";
      $laconical = !empty($params->sort_laconical);

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_DELIVERIES_MODE_BY_NAME:
            $order = "delivery_methods.name " . $direction . ", "
                   . "delivery_methods.order_num DESC ";
            if ($laconical) $where .= "AND TRIM(delivery_methods.name) != '' ";
            break;
          case SORT_DELIVERIES_MODE_BY_PRICE:
            $order = "delivery_methods.price " . $direction . ", "
                   . "delivery_methods.order_num DESC ";
            if ($laconical) $where .= "AND delivery_methods.price != 0 ";
            break;
          case SORT_DELIVERIES_MODE_BY_FREEFROM:
            $order = "delivery_methods.free_from " . $direction . ", "
                   . "delivery_methods.order_num DESC ";
            if ($laconical) $where .= "AND delivery_methods.free_from != 0 ";
            break;
          case SORT_DELIVERIES_MODE_BY_DISCOUNT:
            $order = "delivery_methods.discount " . $direction . ", "
                   . "delivery_methods.order_num DESC ";
            if ($laconical) $where .= "AND delivery_methods.discount >= 0 ";
            break;
          case SORT_DELIVERIES_MODE_BY_CREATED:
            $order = "delivery_methods.created " . $direction . ", "
                   . "delivery_methods.name ASC, "
                   . "delivery_methods.order_num DESC ";
            if ($laconical) $where .= "AND delivery_methods.created IS NOT NULL ";
            break;
          case SORT_DELIVERIES_MODE_BY_MODIFIED:
            $order = "delivery_methods.modified " . $direction . ", "
                   . "delivery_methods.name ASC, "
                   . "delivery_methods.order_num DESC ";
            if ($laconical) $where .= "AND delivery_methods.modified IS NOT NULL "
                                        . "AND delivery_methods.modified != delivery_methods.created ";
            break;
          case SORT_DELIVERIES_MODE_AS_IS:
          default:
            $order = "delivery_methods.order_num DESC, "
                   . "delivery_methods.name ASC ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND delivery_methods.delivery_method_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if (isset($params->require_address)) $where .= "AND delivery_methods.require_address = '" . $this->query_value($params->require_address) . "' ";
      if (isset($params->enabled)) $where .= "AND delivery_methods.enabled = '" . $this->query_value($params->enabled) . "' ";
      if ($where != "") $where = "WHERE 1 " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS delivery_methods.* "
             . "FROM delivery_methods "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о способе доставки, указанном в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->name] = название способа
    // =======================================================================

    public function get_delivery (&$item, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_delivery");

      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND delivery_methods.delivery_method_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND delivery_methods.name = '" . $this->query_value($params->name) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND delivery_methods.delivery_method_id != '" . $this->query_value($params->exclude_id) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT delivery_methods.* "
               . "FROM delivery_methods "
               . $where
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_deliveries_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Добавить в записи о способах доставки оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_deliveries (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_deliveries");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->delivery_method_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "Deliveries",
                             REQUEST_PARAM_NAME_ITEMID => $item->delivery_method_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "поднять выше"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEUP;
            $item->move_up_get = $this->parent->form_get($options);
            // создаем ссылку "опустить ниже"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEDOWN;
            $item->move_down_get = $this->parent->form_get($options);
            // создаем ссылку "поставить первым"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEFIRST;
            $item->move_first_get = $this->parent->form_get($options);
            // создаем ссылку "поставить последним"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVELAST;
            $item->move_last_get = $this->parent->form_get($options);
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "разрешена"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
            $item->enable_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "Delivery";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о способе доставки в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_delivery (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_delivery");

      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->name))                    {$fields[] = "name";                    $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->description))             {$fields[] = "description";             $values[] = "'" . $this->query_value($this->value_as_string($item->description)) . "'";}
        if (isset($item->free_from))               {$fields[] = "free_from";               $values[] = "'" . $this->query_value($this->value_as_positive($item->free_from)) . "'";}
        if (isset($item->price))                   {$fields[] = "price";                   $values[] = "'" . $this->query_value($this->value_as_positive($item->price)) . "'";}
        if (isset($item->discount))                {$fields[] = "discount";                $values[] = "'" . $this->query_value($this->value_as_float($item->discount)) . "'";}
        if (isset($item->types_ids))               {$fields[] = "types_ids";               $values[] = "'" . $this->query_value($this->value_as_string($item->types_ids)) . "'";}
        if (isset($item->undelivery_category_ids)) {$fields[] = "undelivery_category_ids"; $values[] = "'" . $this->query_value($this->value_as_string($item->undelivery_category_ids)) . "'";}
        if (isset($item->tracking_url))            {$fields[] = "tracking_url";            $values[] = "'" . $this->query_value($this->value_as_string($item->tracking_url)) . "'";}
        if (isset($item->require_address))         {$fields[] = "require_address";         $values[] = "'" . $this->query_value($this->value_as_boolean($item->require_address)) . "'";}
        if (isset($item->enabled))                 {$fields[] = "enabled";                 $values[] = "'" . $this->query_value($this->value_as_boolean($item->enabled)) . "'";}
        if (isset($item->created))                 {$fields[] = "created";                 $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified))                {$fields[] = "modified";                $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        if (isset($item->order_num))               {$fields[] = "order_num";               $values[] = "'" . $this->query_value($this->value_as_integer($item->order_num)) . "'";}
        $id = $this->update_record($item, "delivery_methods", "delivery_method_id", $fields, $values);

        // если запись обновлена
        if (!empty($id)) {

          // если существуют способы оплаты
          if (isset($item->payments_ids)) {
            // удаляем прежние записи о способах оплаты
            $query = "DELETE FROM delivery_payment "
                   . "WHERE delivery_method_id = '" . $this->query_value($id) . "';";
            $this->query($query);
            // добавляем новые записи
            if (is_string($item->payments_ids)) $item->payments_ids = explode(",", $item->payments_ids);
            foreach ($item->payments_ids as &$row) {
              $row = intval($row);
              if (!empty($row)) {
                $query = "INSERT INTO delivery_payment (delivery_method_id, "
                                                     . "payment_method_id) "
                       . "VALUES ('" . $this->query_value($id) . "', "
                               . "'" . $this->query_value($row) . "');";
                $this->query($query);
              }
            }
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      return $id;
    }

    // =======================================================================
    // Поправить поля записей о способах доставки:
    //   $items = массив записей
    // =======================================================================

    public function fix_deliveries_records (&$items) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB fix_deliveries_records");

      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_deliveries_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Поправить поля записи о способе доставки:
    //   $item = запись
    // =======================================================================

    public function fix_deliveries_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);
      if (isset($item->description)) $this->fix_textfield_as_product_description($item->description);

      // поправляем адресующие поля
      if (isset($item->delivery_method_id)) {
        $item->delivery_method_id = intval($item->delivery_method_id);

        // моделируем поле способов оплаты
        if (!isset($item->payments_ids)) {
          $item->payments_ids = array();
          $query = "SELECT payment_methods.payment_method_id "
                 . "FROM payment_methods "
                 . "LEFT JOIN delivery_payment "
                           . "ON payment_methods.payment_method_id = delivery_payment.payment_method_id "
                 . "WHERE delivery_payment.delivery_method_id = '" . $this->query_value($item->delivery_method_id) . "';";
          $result = $this->query($query);
          $items = $this->results();

          // освобождаем память от запроса
          $this->free_result($result);

          foreach ($items as &$id) {
            $id = intval($id->payment_method_id);
            if (!empty($id)) $item->payments_ids[$id] = $id;
          }
          sort($item->payments_ids, SORT_NUMERIC);
        }
      }

      // поправляем поле способов оплаты
      if (isset($item->payments_ids) && is_string($item->payments_ids)) {
        $ids = explode(",", $item->payments_ids);
        $item->payments_ids = array();
        foreach ($ids as &$id) {
          $id = intval($id);
          if (!empty($id)) $item->payments_ids[$id] = $id;
        }
        sort($item->payments_ids, SORT_NUMERIC);
      }

      // поправляем поле типов доставки
      if (isset($item->types_ids) && is_string($item->types_ids)) {
        $ids = explode(",", $item->types_ids);
        $item->types_ids = array();
        foreach ($ids as &$id) {
          $id = intval($id);
          if (!empty($id)) $item->types_ids[$id] = $id;
        }
        sort($item->types_ids, SORT_NUMERIC);
      }

      // поправляем поле необслуживаемых категорий
      if (isset($item->undelivery_category_ids) && is_string($item->undelivery_category_ids)) {
        $ids = explode(",", $item->undelivery_category_ids);
        $item->undelivery_category_ids = array();
        foreach ($ids as &$id) {
          $id = intval($id);
          if (!empty($id)) $item->undelivery_category_ids[$id] = $id;
        }
        sort($item->undelivery_category_ids, SORT_NUMERIC);
      }
    }

    // =======================================================================
    // Заполнить таблицу способов доставки минимально необходимыми записями.
    // =======================================================================

    private function setup_deliveries () {
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу способов доставки в базе данных.
    // =======================================================================

    private function check_database_delivery_methods () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_delivery_methods");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "delivery_methods";
      $dbtable_field = "delivery_method_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(20) NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор способа доставки'";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Название способа доставки'";
        $query[] = "ADD INDEX (name)";
      }
      if (!isset($columns["description"])) {
        $query[] = "ADD description TEXT DEFAULT '' NOT NULL COMMENT 'Описание способа доставки'";
      }
      if (!isset($columns["free_from"])) {
        $query[] = "ADD free_from FLOAT(17,6) DEFAULT '0.00' NOT NULL COMMENT 'Бесплатен начиная с суммы'";
      }
      if (!isset($columns["price"])) {
        $query[] = "ADD price FLOAT(17,6) DEFAULT '0.00' NOT NULL COMMENT 'Цена доставки'";
      }
      if (!isset($columns["discount"])) {
        $query[] = "ADD discount FLOAT(5,2) DEFAULT '-1.00' NOT NULL COMMENT 'Скидка на споособ доставки'";
      }
      if (!isset($columns["types_ids"])) {
        $query[] = "ADD types_ids TEXT DEFAULT '' NOT NULL COMMENT 'Идентификаторы типов доставки'";
      }
      if (!isset($columns["undelivery_category_ids"])) {
        $query[] = "ADD undelivery_category_ids TEXT DEFAULT '' NOT NULL COMMENT 'Идентификаторы необслуживаемых категорий'";
      }
      if (!isset($columns["tracking_url"])) {
        $query[] = "ADD tracking_url VARCHAR(1024) DEFAULT '' NOT NULL COMMENT 'Адрес страницы отслеживания посылки'";
      }
      if (!isset($columns["require_address"])) {
        $query[] = "ADD require_address TINYINT(1) DEFAULT '1' NOT NULL COMMENT 'Требует ли заполнения адреса доставки'";
        $query[] = "ADD INDEX (require_address)";
      }
      if (!isset($columns["enabled"])) {
        $query[] = "ADD enabled TINYINT(1) DEFAULT '1' NOT NULL COMMENT 'Разрешена ли запись к использованию'";
        $query[] = "ADD INDEX (enabled)";
      }
      if (!isset($columns["created"])) {
        $query[] = "ADD created DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата создания записи'";
        $query[] = "ADD INDEX (created)";
      }
      if (!isset($columns["modified"])) {
        $query[] = "ADD modified DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата изменения записи'";
        $query[] = "ADD INDEX (modified)";
      }
      if (!isset($columns["order_num"])) {
        $query[] = "ADD order_num INT(11) DEFAULT '0' NOT NULL COMMENT 'Порядковый номер записи'";
        $query[] = "ADD INDEX (order_num)";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET order_num = " . $dbtable_field . " "
                    . "WHERE order_num = 0 OR order_num IS NULL;";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // если таблица не существовала, проверяем наличие минимально необходимых записей
      if (empty($columns)) $this->setup_deliveries();

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу связи способов доставки и оплаты в базе данных.
    // =======================================================================

    private function check_database_delivery_payment () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_delivery_payment");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "delivery_payment";
      $dbtable_field = "delivery_method_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(20) NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL COMMENT 'Идентификатор способа доставки'";
      }
      if (!isset($columns["payment_method_id"])) {
        $query[] = "ADD payment_method_id BIGINT(" . DATABASE_PAYMENTS_FIELDSIZE_ID . ") NOT NULL COMMENT 'Идентификатор способа оплаты'";
        $query[] = "DROP PRIMARY KEY";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ", payment_method_id)";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Выбрать из базы данных записи о типах доставки:
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->sort_direction] = направление сортировки
    //   [$params->sort_laconical] = признак лаконичного режима сортировки
    //   [$params->ids] = идентификаторы типов (перечисленные через запятую)
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_deliveries_types (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_deliveries_types");

      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // запоминаем направление сортировки и режим лаконичности
      $direction = (isset($params->sort_direction) && ($params->sort_direction == SORT_DIRECTION_DESCENDING)) ? "DESC " : "ASC ";
      $laconical = !empty($params->sort_laconical);

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_DELIVERIESTYPES_MODE_BY_NAME:
            $order = "deliveries_types.name " . $direction . ", "
                   . "deliveries_types.created DESC ";
            if ($laconical) $where .= "AND TRIM(deliveries_types.name) != '' ";
            break;
          case SORT_DELIVERIESTYPES_MODE_BY_MODIFIED:
            $order = "deliveries_types.modified " . $direction . ", "
                   . "deliveries_types.name ASC, "
                   . "deliveries_types.created DESC ";
            if ($laconical) $where .= "AND deliveries_types.modified IS NOT NULL "
                                        . "AND deliveries_types.modified != deliveries_types.created ";
            break;
          case SORT_DELIVERIESTYPES_MODE_BY_CREATED:
          case SORT_DELIVERIESTYPES_MODE_AS_IS:
          default:
            $order = "deliveries_types.created " . $direction . ", "
                   . "deliveries_types.name ASC ";
            if ($laconical) $where .= "AND deliveries_types.created IS NOT NULL ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND deliveries_types.type_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if ($where != "") $where = "WHERE 1 " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS deliveries_types.* "
             . "FROM deliveries_types "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о типе доставки, указанном в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->name] = название типа
    // =======================================================================

    public function get_deliveries_type (&$item, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_deliveries_type");

      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND deliveries_types.type_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND deliveries_types.name = '" . $this->query_value($params->name) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND deliveries_types.type_id != '" . $this->query_value($params->exclude_id) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT deliveries_types.* "
               . "FROM deliveries_types "
               . $where
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_deliveries_types_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Добавить в записи о типах доставки оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_deliveries_types (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_deliveries_types");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->type_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "DeliveriesTypes",
                             REQUEST_PARAM_NAME_ITEMID => $item->type_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "DeliveriesType";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о типе доставки в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_deliveries_type (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_deliveries_type");

      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->name))     {$fields[] = "name";     $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->created))  {$fields[] = "created";  $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified)) {$fields[] = "modified"; $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        $id = $this->update_record($item, "deliveries_types", "type_id", $fields, $values);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      return $id;
    }

    // =======================================================================
    // Поправить поля записей о типах доставки:
    //   $items = массив записей
    // =======================================================================

    public function fix_deliveries_types_records (&$items) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB fix_deliveries_types_records");

      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_deliveries_types_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Поправить поля записи о типе доставки:
    //   $item = запись
    // =======================================================================

    public function fix_deliveries_types_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);

      // поправляем адресующие поля
      if (isset($item->type_id)) $item->type_id = intval($item->type_id);
    }

    // =======================================================================
    // Заполнить таблицу типов доставки минимально необходимыми записями.
    // =======================================================================

    private function setup_deliveries_types () {
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу типов доставки в базе данных.
    // =======================================================================

    private function check_database_deliveries_types () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_deliveries_types");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "deliveries_types";
      $dbtable_field = "type_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(20) NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор типа доставки'";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Название типа доставки'";
        $query[] = "ADD INDEX (name)";
      }
      if (!isset($columns["created"])) {
        $query[] = "ADD created DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата создания записи'";
        $query[] = "ADD INDEX (created)";
      }
      if (!isset($columns["modified"])) {
        $query[] = "ADD modified DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата изменения записи'";
        $query[] = "ADD INDEX (modified)";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // если таблица не существовала, проверяем наличие минимально необходимых записей
      if (empty($columns)) $this->setup_deliveries_types();

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Выбрать из базы данных записи о сроках отправки:
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->sort_direction] = направление сортировки
    //   [$params->sort_laconical] = признак лаконичного режима сортировки
    //   [$params->ids] = идентификаторы сроков (перечисленные через запятую)
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_shippings_terms (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_shippings_terms");

      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // запоминаем направление сортировки и режим лаконичности
      $direction = (isset($params->sort_direction) && ($params->sort_direction == SORT_DIRECTION_DESCENDING)) ? "DESC " : "ASC ";
      $laconical = !empty($params->sort_laconical);

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_SHIPPINGSTERMS_MODE_BY_NAME:
            $order = "shippings_terms.name " . $direction . ", "
                   . "shippings_terms.created DESC ";
            if ($laconical) $where .= "AND TRIM(shippings_terms.name) != '' ";
            break;
          case SORT_SHIPPINGSTERMS_MODE_BY_MODIFIED:
            $order = "shippings_terms.modified " . $direction . ", "
                   . "shippings_terms.name ASC, "
                   . "shippings_terms.created DESC ";
            if ($laconical) $where .= "AND shippings_terms.modified IS NOT NULL "
                                        . "AND shippings_terms.modified != shippings_terms.created ";
            break;
          case SORT_SHIPPINGSTERMS_MODE_BY_CREATED:
          case SORT_SHIPPINGSTERMS_MODE_AS_IS:
          default:
            $order = "shippings_terms.created " . $direction . ", "
                   . "shippings_terms.name ASC ";
            if ($laconical) $where .= "AND shippings_terms.created IS NOT NULL ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND shippings_terms.term_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if ($where != "") $where = "WHERE 1 " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS shippings_terms.* "
             . "FROM shippings_terms "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о сроке отправки, указанном в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->name] = название срока
    // =======================================================================

    public function get_shippings_term (&$item, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_shippings_term");

      $item = null;
      $where = "";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND shippings_terms.term_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND shippings_terms.name = '" . $this->query_value($params->name) . "' ";
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND shippings_terms.term_id != '" . $this->query_value($params->exclude_id) . "' ";
        $where = "WHERE 1 " . $where;

        // делаем запрос
        $query = "SELECT shippings_terms.* "
               . "FROM shippings_terms "
               . $where
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_shippings_terms_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Добавить в записи о сроках отправки оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_shippings_terms (&$items, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB operable_shippings_terms");

      if (!empty($items) && isset($params->token)) {
        foreach ($items as &$item) {
          if (isset($item->term_id)) {
            // собираем параметры
            $options = array(REQUEST_PARAM_NAME_SECTION => "ShippingsTerms",
                             REQUEST_PARAM_NAME_ITEMID => $item->term_id,
                             REQUEST_PARAM_NAME_TOKEN => $params->token);
            if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;
            // создаем ссылку "удалить"
            $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
            $item->delete_get = $this->parent->form_get($options);
            // создаем ссылку "редактировать"
            unset($options[REQUEST_PARAM_NAME_ACTION]);
            $options[REQUEST_PARAM_NAME_SECTION] = "ShippingsTerm";
            $item->edit_get = $this->parent->form_get($options);
          }
        }
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о сроке отправки в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_shippings_term (&$item) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB update_shippings_term");

      $id = "";
      if (!empty($item)) {
        $fields = array(); $values = array();
        if (isset($item->name))     {$fields[] = "name";     $values[] = "'" . $this->query_value($this->value_as_string($item->name)) . "'";}
        if (isset($item->created))  {$fields[] = "created";  $values[] = "'" . $this->query_value($this->value_as_date($item->created)) . "'";}
        if (isset($item->modified)) {$fields[] = "modified"; $values[] = "'" . $this->query_value($this->value_as_date($item->modified)) . "'";}
        $id = $this->update_record($item, "shippings_terms", "term_id", $fields, $values);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      return $id;
    }

    // =======================================================================
    // Поправить поля записей о сроках отправки:
    //   $items = массив записей
    // =======================================================================

    public function fix_shippings_terms_records (&$items) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB fix_shippings_terms_records");

      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_shippings_terms_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Поправить поля записи о сроке отправки:
    //   $item = запись
    // =======================================================================

    public function fix_shippings_terms_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);

      // поправляем адресующие поля
      if (isset($item->term_id)) $item->term_id = intval($item->term_id);
    }

    // =======================================================================
    // Заполнить таблицу сроков отправки минимально необходимыми записями.
    // =======================================================================

    private function setup_shippings_terms () {
    }

    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу сроков отправки в базе данных.
    // =======================================================================

    private function check_database_shippings_terms () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_shippings_terms");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "shippings_terms";
      $dbtable_field = "term_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(20) NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор срока отправки'";
      }
      if (!isset($columns["name"])) {
        $query[] = "ADD name VARCHAR(256) DEFAULT '' NOT NULL COMMENT 'Название срока отправки'";
        $query[] = "ADD INDEX (name)";
      }
      if (!isset($columns["created"])) {
        $query[] = "ADD created DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата создания записи'";
        $query[] = "ADD INDEX (created)";
      }
      if (!isset($columns["modified"])) {
        $query[] = "ADD modified DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата изменения записи'";
        $query[] = "ADD INDEX (modified)";
      }

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // если таблица не существовала, проверяем наличие минимально необходимых записей
      if (empty($columns)) $this->setup_shippings_terms();

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }



    // =======================================================================
    // Выбрать из базы данных записи о валютах:
    //   $items = результат будет помещен в эту переменную
    //   [$params->sort] = способ сортировки записей
    //   [$params->sort_direction] = направление сортировки
    //   [$params->sort_laconical] = признак лаконичного режима сортировки
    //   [$params->ids] = идентификаторы валют (перечисленные через запятую)
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->deleted] = признак "удалена" запись
    //   [$params->start] = начиная с такой позиции
    //   [$params->maxcount] = не более такого количества
    // =======================================================================

    public function get_currencies (&$items, $params = null) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_currencies");

      $items = array();
      $where = "";
      $order = "";
      $limit = "";

      // запоминаем направление сортировки и режим лаконичности
      $direction = (isset($params->sort_direction) && ($params->sort_direction == SORT_DIRECTION_DESCENDING)) ? "DESC " : "ASC ";
      $laconical = !empty($params->sort_laconical);

      // сортируем указанным способом
      if (isset($params->sort)) {
        switch ($params->sort) {
          case SORT_CURRENCIES_MODE_BY_NAME:
            $order = "currencies.name " . $direction . ", "
                   . "currencies.order_num DESC ";
            if ($laconical) $where .= "AND TRIM(currencies.name) != '' ";
            break;
          case SORT_CURRENCIES_MODE_BY_ISOCODE:
            $order = "currencies.code " . $direction . ", "
                   . "currencies.order_num DESC ";
            if ($laconical) $where .= "AND TRIM(currencies.code) != '' ";
            break;
          case SORT_CURRENCIES_MODE_BY_RATEFROM:
            $order = "currencies.rate_from " . $direction . ", "
                   . "currencies.name ASC, "
                   . "currencies.order_num DESC ";
            if ($laconical) $where .= "AND currencies.rate_from != '1.0000' ";
            break;
          case SORT_CURRENCIES_MODE_BY_RATETO:
            $order = "currencies.rate_to " . $direction . ", "
                   . "currencies.name ASC, "
                   . "currencies.order_num DESC ";
            if ($laconical) $where .= "AND currencies.rate_to != '1.0000' ";
            break;
          case SORT_CURRENCIES_MODE_BY_CREATED:
            $order = "currencies.created " . $direction . ", "
                   . "currencies.name ASC, "
                   . "currencies.order_num DESC ";
            if ($laconical) $where .= "AND currencies.created IS NOT NULL ";
            break;
          case SORT_CURRENCIES_MODE_BY_MODIFIED:
            $order = "currencies.modified " . $direction . ", "
                   . "currencies.name ASC, "
                   . "currencies.order_num DESC ";
            if ($laconical) $where .= "AND currencies.modified IS NOT NULL "
                                        . "AND currencies.modified != currencies.created ";
            break;
          case SORT_CURRENCIES_MODE_AS_IS:
          default:
            $order = "currencies.order_num DESC, "
                   . "currencies.name ASC ";
        }
        $order = "ORDER BY " . $order;
      }

      // фильтруем по запрошенным параметрам
      if (isset($params->ids) && ($params->ids != "")) $where .= "AND currencies.currency_id IN ('" . str_replace(",", "','", $this->query_value($params->ids)) . "') ";
      if (isset($params->enabled)) $where .= "AND currencies.enabled = '" . $this->query_value($params->enabled) . "' ";
      if ($where != "") $where = "WHERE currencies.deleted = '" . (isset($params->deleted) ? $this->query_value($params->deleted) : 0) . "' " . $where;

      // формируем параметр LIMIT запроса
      if (isset($params->start) || isset($params->maxcount)) {
        $limit = "LIMIT ";
        if (isset($params->start)) {
          $params->start = intval($params->start);
          if ($params->start >= 0) $limit .= $params->start . ", ";
        }
        if (isset($params->maxcount)) {
          $params->maxcount = intval($params->maxcount);
          if ($params->maxcount >= 0) $limit .= $params->maxcount;
        }
      }

      // делаем запрос
      $query = "SELECT SQL_CALC_FOUND_ROWS currencies.* "
             . "FROM currencies "
             . $where
             . $order
             . $limit . ";";
      $result = $this->query($query);
      $items = $this->results();

      // берем полное количество подобных записей
      $result2 = $this->query("SELECT FOUND_ROWS() AS count;");
      $count = $this->result();
      $count = isset($count->count) ? $count->count : 0;

      // освобождаем память от запроса
      $this->free_result($result);
      $this->free_result($result2);

      // закрываем трассировку этого метода
      $this->close_tracing_method();

      // возвращаем количество записей
      return $count;
    }

    // =======================================================================
    // Взять из базы данных запись о валюте, указанной в параметрах:
    //   $item = результат будет помещен в эту переменную
    //   [$params->id] = идентификатор записи
    //   [$params->exclude_id] = кроме идентификатора записи
    //   [$params->enabled] = признак "разрешена" запись
    //   [$params->deleted] = признак "удалена" запись
    //   [$params->main] = признак "базовая" запись
    //   [$params->def] = признак "для клиента" запись
    //   [$params->defa] = признак "для админа" запись
    //   [$params->ymarket] = признак "для Яндекс.Маркет" запись
    //   [$params->name] = название валюты
    //   [$params->sign] = надпись
    //   [$params->code] = ISO код
    // =======================================================================

    public function get_currency (&$item, $params) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB get_currency");

      $item = null;
      $where = "";
      $order = "ORDER BY currencies.main DESC ";

      // фильтруем по запрошенным параметрам
      if (isset($params->id) && !empty($params->id)) $where .= "AND currencies.currency_id = '" . $this->query_value($params->id) . "' ";
      if (isset($params->name)) $where .= "AND currencies.name = '" . $this->query_value($params->name) . "' ";
      if (isset($params->sign)) $where .= "AND currencies.sign = '" . $this->query_value($params->sign) . "' ";
      if (isset($params->code)) $where .= "AND currencies.code = '" . $this->query_value($params->code) . "' ";
      if (isset($params->def)) {
        $where .= " ";
        $order = "ORDER BY currencies.def DESC, "
                        . "currencies.main DESC ";
      }
      if (isset($params->defa)) {
        $where .= " ";
        $order = "ORDER BY currencies.defa DESC, "
                        . "currencies.main DESC ";
      }
      if (isset($params->ymarket)) {
        $where .= " ";
        $order = "ORDER BY currencies.ymarket DESC, "
                        . "currencies.main DESC ";
      }
      if ($where != "") {
        if (isset($params->exclude_id)) $where .= "AND currencies.currency_id != '" . $this->query_value($params->exclude_id) . "' ";
        if (isset($params->enabled)) $where .= "AND currencies.enabled = '" . $this->query_value($params->enabled) . "' ";
        $where = "WHERE currencies.deleted = '" . (isset($params->deleted) ? $this->query_value($params->deleted) : 0) . "' " . $where;

        // делаем запрос
        $query = "SELECT currencies.* "
               . "FROM currencies "
               . $where
               . $order
               . "LIMIT 1;";
        $result = $this->query($query);
        $item = $this->result();

        // освобождаем память от запроса
        $this->free_result($result);

        // поправляем поля записи
        if (!empty($item)) $this->fix_currencies_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Очистка кеш-таблицы валют и зависимых кешей:
    //   [$item] = обрабатывавшаяся запись (содержащая меняемые поля)
    // =======================================================================

    public function reset_currencies_caches (&$item = null) {

      // если просят очистить безусловно или изменения в самом деле критичны
      if (is_null($item) || !isset($item->indifferent_caches) || !$item->indifferent_caches) {

        // здесь ничего не делаем (таблица не кешируется)
      }
    }

    // =======================================================================
    // Добавить в записи о валютах оперативные ссылки админпанели:
    //   $items = массив записей
    //   $params->token = аутентификатор операции
    //   [$params->sort] = способ сортировки записей
    // =======================================================================

    public function operable_currencies ( & $items, $params ) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB operable_currencies');

        if (!empty($items) && isset($params->token)) {
            foreach ($items as & $item) {
                if (isset($item->currency_id)) {
                    // собираем параметры
                    $options = array(REQUEST_PARAM_NAME_SECTION => 'Currencies',
                                     REQUEST_PARAM_NAME_ITEMID => $item->currency_id,
                                     REQUEST_PARAM_NAME_TOKEN => $params->token);
                    if (isset($params->sort)) $options[REQUEST_PARAM_NAME_SORT] = $params->sort;

                    // создаем ссылку 'поднять выше'
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEUP;
                    $item->move_up_get = $this->parent->form_get($options);

                    // создаем ссылку 'опустить ниже'
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEDOWN;
                    $item->move_down_get = $this->parent->form_get($options);

                    // создаем ссылку 'поставить первым'
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVEFIRST;
                    $item->move_first_get = $this->parent->form_get($options);

                    // создаем ссылку 'поставить последним'
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MOVELAST;
                    $item->move_last_get = $this->parent->form_get($options);

                    // создаем ссылку 'удалить'
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DELETE;
                    $item->delete_get = $this->parent->form_get($options);

                    // создаем ссылку 'разрешена'
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_ENABLED;
                    $item->enable_get = $this->parent->form_get($options);

                    // создаем ссылку 'базовая'
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_MAIN;
                    $item->main_get = $this->parent->form_get($options);

                    // создаем ссылку 'по умолчанию для клиента'
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DEFAULT;
                    $item->default_get = $this->parent->form_get($options);

                    // создаем ссылку 'по умолчанию для админа'
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_DEFAULTA;
                    $item->defaulta_get = $this->parent->form_get($options);

                    // создаем ссылку 'для Яндекс.Маркет'
                    $options[REQUEST_PARAM_NAME_ACTION] = ACTION_REQUEST_PARAM_VALUE_YMARKET;
                    $item->ymarket_get = $this->parent->form_get($options);

                    // создаем ссылку 'редактировать'
                    unset($options[REQUEST_PARAM_NAME_ACTION]);
                    $options[REQUEST_PARAM_NAME_SECTION] = 'Currency';
                    $item->edit_get = $this->parent->form_get($options);
                }
            }
        }

        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }

    // =======================================================================
    // Обновить/добавить запись о валюте в базе данных:
    //   $item = запись (обычно содержащая только изменившиеся поля),
    //           лишние (не относящиеся к таблице) поля в записи игнорируются,
    //           запись добавляется, если не имеет поля идентификатора записи
    // =======================================================================

    public function update_currency ( & $item ) {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB update_currency');

        $id = '';
        if (!empty($item)) {

            // если возможно поменяется курс, запоминаем старый
            $old_rate = 1;
            if (isset($item->currency_id)) {
                if (isset($item->rate_from) || isset($item->rate_to)) {
                    $filter = new stdClass;
                    $filter->id = $item->currency_id;
                    $row = null;
                    $this->get_currency($row, $filter);
                    $old_rate = $this->cms->any->currency->rate($row);
                }
            }

            // готовим изменившиеся поля
            $fields = array(); $values = array();
            if (isset($item->currency_id)) {$fields[] = 'currency_id'; $values[] = '"' . $this->query_value($this->value_as_integer($item->currency_id)) . '"';}
            if (isset($item->enabled))     {$fields[] = 'enabled';     $values[] = '"' . $this->query_value($this->value_as_boolean($item->enabled)) . '"';}
            if (isset($item->main))        {$fields[] = 'main';        $values[] = '"' . $this->query_value($this->value_as_boolean($item->main)) . '"';}
            if (isset($item->def))         {$fields[] = 'def';         $values[] = '"' . $this->query_value($this->value_as_boolean($item->def)) . '"';}
            if (isset($item->defa))        {$fields[] = 'defa';        $values[] = '"' . $this->query_value($this->value_as_boolean($item->defa)) . '"';}
            if (isset($item->ymarket))     {$fields[] = 'ymarket';     $values[] = '"' . $this->query_value($this->value_as_boolean($item->ymarket)) . '"';}
            if (isset($item->name))        {$fields[] = 'name';        $values[] = '"' . $this->query_value($this->value_as_string($item->name)) . '"';}
            if (isset($item->sign))        {$fields[] = 'sign';        $values[] = '"' . $this->query_value($this->value_as_string($item->sign)) . '"';}
            if (isset($item->code))        {$fields[] = 'code';        $values[] = '"' . $this->query_value($this->value_as_string($item->code)) . '"';}
            if (isset($item->rate_from))   {$fields[] = 'rate_from';   $values[] = '"' . $this->query_value($this->value_as_positive($item->rate_from)) . '"';}
            if (isset($item->rate_to))     {$fields[] = 'rate_to';     $values[] = '"' . $this->query_value($this->value_as_positive($item->rate_to)) . '"';}
            if (isset($item->created))     {$fields[] = 'created';     $values[] = '"' . $this->query_value($this->value_as_date($item->created)) . '"';}
            if (isset($item->modified))    {$fields[] = 'modified';    $values[] = '"' . $this->query_value($this->value_as_date($item->modified)) . '"';}
            if (isset($item->order_num))   {$fields[] = 'order_num';   $values[] = '"' . $this->query_value($this->value_as_integer($item->order_num)) . '"';}
            if (isset($item->deleted))     {$fields[] = 'deleted';     $values[] = '"' . $this->query_value($this->value_as_boolean($item->deleted)) . '"';}

            // обновляем / добавляем запись
            $id = $this->update_record($item, 'currencies', 'currency_id', $fields, $values);

            // если успешно
            if (!empty($id)) {

                // если возможно поменялся курс
                if (isset($item->rate_from) || isset($item->rate_to)) {
                    $filter = new stdClass;
                    $filter->id = $id;
                    $row = null;
                    $this->get_currency($row, $filter);
                    $rate = $this->cms->any->currency->rate($row);
                    if ($old_rate != $rate) {

                        // обновляем цены товаров в такой валюте
                        $rate = $this->cms->number->safeFloatValueString($old_rate / $rate);
                        $query = '';
                        for ($i = 1; $i <= PRICE_TYPES_MAXCOUNT; $i++) {
                            $field = 'price' . ($i > 1 ? $i : '');
                            $query .= '`' . $field . '` = `' . $field . '` * ' . $rate . ', ';
                        }
                        $this->query('UPDATE `products_variants` '
                                   . 'SET ' . $query
                                        . '`temp_price` = `temp_price` * ' . $rate . ', '
                                        . '`old_price` = `old_price` * ' . $rate . ' '
                                   . 'WHERE `currency_id` = "' . $this->query_value($id) . '";');
                    }
                }
            }
        }

        // закрываем трассировку этого метода
        $this->close_tracing_method();

        // возвращаем идентификатор обновленной / добавленной записи
        return $id;
    }

    // =======================================================================
    // Поправить поля записей о валютах:
    //   $items = массив записей
    // =======================================================================

    public function fix_currencies_records (&$items) {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB fix_currencies_records");

      if (!empty($items)) {
        foreach ($items as &$item) $this->fix_currencies_record($item);
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Поправить поля записи о валюте:
    //   $item = запись
    // =======================================================================

    public function fix_currencies_record (&$item) {

      // поправляем строковые поля
      if (isset($item->name)) $this->fix_textfield_as_product_name($item->name);

      // поправляем адресующие поля
      if (isset($item->currency_id)) $item->currency_id = intval($item->currency_id);
    }



    // ===================================================================
    /**
    *  Заполнение таблицы минимально необходимыми записями
    *
    *  @access  private
    *  @return  void
    */
    // ===================================================================

    private function setup_currencies () {

        // открываем трассировку этого метода
        $this->open_tracing_method('DB setup_currencies');



        // создаем перечень минимально необходимых записей
        $records = array();
        $records[] = array('main' => 1, 'def' => 1, 'defa' => 1, 'name' => 'доллары', 'sign' => '$', 'code' => 'USD', 'rate_from' => 1, 'rate_to' => 1);



        // читаем список имеющихся записей
        $query = 'SELECT code '
               . 'FROM currencies;';
        $result = $this->query($query);
        $items = $this->results();



        // освобождаем память от запроса
        $this->free_result($result);



        // готовим результат для циклического перебора
        if (!empty($items)) {
            foreach ($items as & $item) $item = strtolower(trim($item->code));
        } else {
            $items = array();
        }



        // просматриваем перечень необходимых записей
        foreach ($records as & $record) {
            $value = strtolower($record['code']);



            // перебираем имеющиеся записи и сравниваем с необходимой
            foreach ($items as & $item) {
                if ($item == $value) continue 2;
            }



            // необходимая запись не найдена, добавляем ее
            $value = new stdClass;
            $value->main = $record['main'];
            $value->def = $record['def'];
            $value->defa = $record['defa'];
            $value->name = $record['name'];
            $value->sign = $record['sign'];
            $value->code = $record['code'];
            $value->rate_from = $record['rate_from'];
            $value->rate_to = $record['rate_to'];
            $value->enabled = 1;
            $this->update_currency($value);
        }



        // закрываем трассировку этого метода
        $this->close_tracing_method();
    }



    // =======================================================================
    // Проверить и поправить (если нет, создать) таблицу валют в базе данных.
    // =======================================================================

    private function check_database_currencies () {

      // открываем трассировку этого метода
      $this->open_tracing_method("DB check_database_currencies");

      // проверяем наличие таблицы, при отсутствии создаем
      $dbtable = "currencies";
      $dbtable_field = "currency_id";
      $columns = $this->get_dbtable_fields($dbtable);
      if (empty($columns)) $this->query("CREATE TABLE IF NOT EXISTS " . $dbtable . " (" . $dbtable_field . " BIGINT(20) NOT NULL) ENGINE = MyISAM DEFAULT CHARSET = utf8 AUTO_INCREMENT = 1;");

      // проверяем наличие нужных столбцов, при отсутствии формируем соответствующие запросы
      $query = array();
      $subquery = array();
      if (!isset($columns[$dbtable_field])) {
        $query[] = "ADD " . $dbtable_field . " BIGINT(20) NOT NULL";
        $query[] = "DROP PRIMARY KEY";
        $query[] = ">SET @a := 0";
        $query[] = ">UPDATE " . $dbtable . " SET " . $dbtable_field . " = @a := @a + 1";
        $query[] = "ADD PRIMARY KEY (" . $dbtable_field . ")";
        $query[] = "CHANGE " . $dbtable_field . " " . $dbtable_field . " BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор валюты'";
      } else {

        // валюта
        $name = $dbtable_field;
        $type = "BIGINT(20)";
        if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " NOT NULL AUTO_INCREMENT COMMENT 'Идентификатор валюты'";
      }

      // разрешена
      $name = "enabled";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '1' NOT NULL COMMENT 'Признак Запись разрешена'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // базовая
      $name = "main";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Признак Базовая валюта'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // по умолчанию для клиентской стороны
      $name = "def";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Признак Выбрана по умолчанию для клиентской стороны'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // по умолчанию для админпанели
      $name = "defa";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") {
        $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Признак Выбрана по умолчанию для админпанели'";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET " . $name . " = def;";
      }
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // для Яндекс.Маркет
      $name = "ymarket";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") {
        $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Признак Выбрана для Яндекс.Маркет'";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET " . $name . " = main;";
      }
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // название
      $name = "name";
      $type = "VARCHAR(" . DATABASE_CURRENCIES_FIELDSIZE_NAME . ")";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Название валюты'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // надпись
      $name = "sign";
      $type = "VARCHAR(" . DATABASE_CURRENCIES_FIELDSIZE_SIGN . ")";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'Надпись валюты'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // ISO код
      $name = "code";
      $type = "VARCHAR(" . DATABASE_CURRENCIES_FIELDSIZE_ISOCODE . ")";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '' NOT NULL COMMENT 'ISO код валюты'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // курс (за единицу базовой валюты)
      $name = "rate_from";
      $type = "FLOAT(12,4)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '1.0000' NOT NULL COMMENT 'Курс (за единицу базовой валюты)'";

      // обратный курс (сколько единиц базовой валюты)
      $name = "rate_to";
      $type = "FLOAT(12,4)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '1.0000' NOT NULL COMMENT 'Обратный курс (сколько единиц базовой валюты)'";

      // создано
      $name = "created";
      $type = "DATETIME";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата создания записи'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // изменено
      $name = "modified";
      $type = "DATETIME";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0000-00-00 00:00:00' NOT NULL COMMENT 'Дата изменения записи'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // вес в ветке
      $name = "order_num";
      $type = "INT(11)";
      if (($command = $this->check_field($columns, $name, $type)) != "") {
        $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Вес записи среди прочих в ветке'";
        $subquery[] = "UPDATE " . $dbtable . " "
                    . "SET " . $name . " = " . $dbtable_field . " "
                    . "WHERE " . $name . " = 0 OR " . $name . " IS NULL;";
      }
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // удалена
      $name = "deleted";
      $type = "TINYINT(1)";
      if (($command = $this->check_field($columns, $name, $type)) != "") $query[] = $command . " " . $name . " " . $type . " DEFAULT '0' NOT NULL COMMENT 'Признак Запись удалена'";
      if (!$this->check_key($columns, $name)) $this->add_key($query, $name);

      // выполняем сформированные запросы
      foreach ($query as &$command) {
        if (trim($command) != "") {
          if (substr($command, 0, 1) == ">") {
            $command = trim(substr($command, 1));
            if ($command != "") $command .= ";";
          } else {
            $command = "ALTER TABLE " . $dbtable . " " . $command . ";";
          }
          if ($command != "") $this->query($command);
        }
      }
      foreach ($subquery as &$command) {
        if (trim($command) != "") $this->query($command);
      }

      // если таблица не существовала, проверяем наличие минимально необходимых записей
      if (empty($columns)) $this->setup_currencies();

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }


    // =======================================================================
    // Проверить и поправить (если нет, создать) все таблицы в базе данных:
    //   [$full_checking] = булевой признак "выполнить полную проверку"
    // =======================================================================

    public function check_databases ($full_checking = FALSE) {

      // открываем трассировку этого метода
      $this->open_tracing_method('DB check_databases');

      // если проверка контрольной таблицы сообщает ВЫПОЛНИТЬ ПЕРЕПРОВЕРКУ ОСТАЛЬНЫХ
      if (!$this->check_database_menu() || $full_checking) {

        // перепроверяем все таблицы
        @ set_time_limit(0);
        $this->check_database_categories();
        $this->check_database_brands();

        $this->stocks->check();
        $this->callme->check();

        $this->check_database_notifies();
        $this->check_database_products_comments();
        $this->check_database_articles_comments();
        $this->check_database_news_comments();
        $this->check_database_articles();

        $this->news->check();
        $this->sections->check();

        $this->check_database_files();
        $this->check_database_modules();

        $this->imports->check();
        $this->settings->check();
        $this->users->check();

        $this->check_database_banneds();

        $this->products->check();
        $this->products->check_categories();
        $this->products->check_variants();
        $this->products->check_related();
        $this->products_kits->check();

        $this->orders->check();
        $this->orders->check_products();

        $this->check_database_orders_phases();
        $this->check_database_properties();
        $this->check_database_properties_values();

        $this->countries->check();

        $this->check_database_regions();
        $this->check_database_towns();
        $this->check_database_schools();
        $this->check_database_schools_types();
        $this->check_database_schools_lessons();
        $this->check_database_schools_classes();

        $this->groups->check();

        $this->check_database_delivery_methods();
        $this->check_database_delivery_payment();
        $this->check_database_deliveries_types();
        $this->check_database_shippings_terms();

        $this->payments->check();

        $this->check_database_currencies();

        $this->feedback->check();
        $this->credit_programs->check();
        $this->coupons->check();
        $this->searches->check();
      }

      // закрываем трассировку этого метода
      $this->close_tracing_method();
    }

    // =======================================================================
    // Распаковать данные из последовательной формы:
    //   $data = данные в последовательной форме
    // =======================================================================

    public function unserialize_data (&$data) {

      // если данные не в последовательной форме, возвращаем входные данные
      if (!is_string($data)) return $data;

      // если данные не заполнены, возвращаем пустой массив
      if (trim($data) == "") return array();

      // распаковываем данные
      $result = @unserialize($data);

      // если данные не распаковываются, пробуем сменить локаль
      // (возможно упаковка происходила в Win1251, после чего MySQL
      // конвертировал результат в UTF-8)
      if (($result === FALSE) && function_exists("iconv")) {
        $result = @iconv("UTF-8", "Windows-1251//IGNORE", $data);
        $result = @unserialize($result);

        // если распаковано
        if ($result !== FALSE) {

          // если это строка, восстанавливаем локаль
          if (is_string($result)) {
            $result = @iconv("Windows-1251", "UTF-8//IGNORE", $result);

          // иначе если это массив, восстанавливаем локаль
          } elseif (is_array($result)) {
            $real = array();
            foreach ($result as $index => $value) {
              if (is_string($index)) $index = @iconv("Windows-1251", "UTF-8//IGNORE", $index);
              if (is_string($value)) $value = @iconv("Windows-1251", "UTF-8//IGNORE", $value);
              $real[$index] = $value;
            }
            $result = $real;
          }
        }
      }

      // возвращаем результат
      return $result;
    }
  }

  return;
?>